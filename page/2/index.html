<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.134.3"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>RLTEA BLOG</title>
<meta name=keywords content="Blog,Portfolio,PaperMod"><meta name=description content="ExampleSite description"><meta name=author content="RLTea"><link rel=canonical href=https://roaraeonliou.github.io/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.258803b0f0cc9a4a109c6fe78a9d39f2e0437217d71c5c9848255af9250f2b1b.css integrity="sha256-JYgDsPDMmkoQnG/nip058uBDchfXHFyYSCVa+SUPKxs=" rel="preload stylesheet" as=style><link rel=icon href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://roaraeonliou.github.io/index.xml><link rel=alternate type=application/json href=https://roaraeonliou.github.io/index.json><link rel=alternate hreflang=en href=https://roaraeonliou.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="RLTEA BLOG"><meta property="og:description" content="ExampleSite description"><meta property="og:type" content="website"><meta property="og:url" content="https://roaraeonliou.github.io/"><meta property="og:image" content="https://roaraeonliou.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="RLTEA BLOG"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://roaraeonliou.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="RLTEA BLOG"><meta name=twitter:description content="ExampleSite description"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"RLTEA BLOG","url":"https://roaraeonliou.github.io/","description":"ExampleSite description","thumbnailUrl":"https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E","sameAs":["https://x.com/","https://stackoverflow.com","https://github.com/"]}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["\\(","\\)"],["$","$"]]}}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://roaraeonliou.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://roaraeonliou.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://roaraeonliou.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://roaraeonliou.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://roaraeonliou.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://roaraeonliou.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Dynamic Programming</h2></header><div class=entry-content><p>Dynamic Programming 算法-动态规划 Dynamic Programming–从菜鸟到老鸟-CSDN博客
拆分子问题，记住过往，减少重复计算
1.最优子结构
如果一个问题的解结构包含其子问题的最优解，就称此问题具有最优子结构性质。因此，某个问题是否适合应用动态规划算法，它是否具有最优子结构性质是一个很好的线索。使用动态规划算法时，用子问题的最优解来构造原问题的最优解。因此必须考查最优解中用到的所有子问题。
2.重叠子问题
在斐波拉契数列和钢条切割结构图中，可以看到大量的重叠子问题，比如说在求fib（6）的时候，fib（2）被调用了5次，在求cut（4）的时候cut（0）被调用了4次。如果使用递归算法的时候会反复的求解相同的子问题，不停的调用函数，而不是生成新的子问题。如果递归算法反复求解相同的子问题，就称为具有重叠子问题（overlapping subproblems）性质。在动态规划算法中使用数组来保存子问题的解，这样子问题多次求解的时候可以直接查表不用调用函数递归。
自顶向下备忘录 自底向上动态规划 public int minPathCost(int[][] grid, int[][] moveCost) { int[] cost = new int[grid[0].length]; int min_cost = 0x7fffffff; for(int i=0;i&lt;cost.length;i++){ cost[i] = grid[grid.length-1][i]; } // hop loop for(int i=grid.length-2;i>=0;i--){ // update cost loop for(int j=0;j&lt;cost.length;j++){ min_cost = 0x7fffffff; for(int k=0;k&lt;moveCost[grid[i][j]].length;k++){ min_cost = Math.min(moveCost[grid[i][j]][k]+grid[i][j], min_cost); } cost[j] = min_cost; } } for(int i=0;i&lt;cost.length;i++){ min_cost = Math.min(min_cost, cost[i]); } return min_cost; }</p></div><footer class=entry-footer><span title='2024-09-26 00:00:00 +0000 UTC'>September 26, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;71 words&nbsp;·&nbsp;RLTEA</footer><a class=entry-link aria-label="post link to Dynamic Programming" href=https://roaraeonliou.github.io/posts/interviewnotes/algorithm/dynamic-programming/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Git</h2></header><div class=entry-content><p>Git 1 使用 1.1 初始化仓库 git init git clone [url] directoryName 1.2 记录每次更新 检测文件状态：git status 将文件加入到暂存区：git add filename 忽略文件：.gitignore 提交更新：git commot -m ”message” 跳过使用暂存区域更新方式：git commit -a -m “message” 从暂存区移除文件：git rm filename 对文件重命名：git mv README.md README（相当于 mv README.md README, git rm README.md, git add README） 1.3 推送改动到远程仓库 链接远程服务器：git remote add origin 提交改动 git push origin master 1.4 远程仓库的移除与重命名 git remote rename test test1 git remote rm test1 1.5 查看提交历史 git log –author=name
...</p></div><footer class=entry-footer><span title='2024-09-26 00:00:00 +0000 UTC'>September 26, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;113 words&nbsp;·&nbsp;RLTEA</footer><a class=entry-link aria-label="post link to Git" href=https://roaraeonliou.github.io/posts/interviewnotes/developmenttool/git/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>HTTP</h2></header><div class=entry-content><p>1 HTTP 基础 1.1 HTTP常见状态码 1XX： 提示信息，表示目前是协议处理的中间状态，还需要后续的操作 2XX：成功，报文已经被收到并正确处理 200：成功，如果是非HEAD请求，返回响应头会有body数据 204：与200基本相同，但还是响应头没有body数据 206：用于HTTP分块下载或断点续传，表示返回的body不是全部资源 3XX：重定向，资源位置发生变动，需要客户端重新发送请求 301：永久重定向 302：临时重定向 304：资源未修改，重定向缓冲文件，告诉客户端可以使用缓冲资源 4XX：客户端错误，请求报文有误，服务器无法处理 400：请求报文有错，笼统错误 403：服务器禁止访问资源 404：请求资源在服务器不存在或未找到 5XX：服务器错误，服务器在处理请求时内部发生了错误 500：服务器发生错误，笼统错误 501：客户端请求的功能不支持 502：服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，但是访问后端服务器发生错误 503：表示服务器忙碌，展示无法响应客户端 1.2 HTTP常见字段 Host字段：指定服务器域名 Content-Length字段：表示本子回应的数据长度 Connection字段：常用于客户端要求服务器使用长连接 Content-Type字段：用于服务端响应时，告诉客户端本次数据是什么格式 Accept字段：客户端告诉服务器可以接受哪些数据 Content-Encoding字段：表示数据压缩方法 Accept-Encoding字段：客户端告诉服务器可以接受哪些压缩方式 1.3 GET和POST 语义上：GET表示从服务器获取指定资源，POST表示根据请求负荷对指定资源作出处理 安全和幂等：GET方法是安全且幂等的，浏览器可以对GET做数据缓存，也可以在代理层做缓存，GET可以被保存为书签；POST是不安全的，并且不是幂等的，浏览器也不会缓存POST请求，也不能把POST请求保存为书签。 如果不按照规范开发：GET可以变为不安全且不幂等的，POST也可以变为安全和幂等的。 GET可以携带body数据，POST也可以在URL中携带参数 1.4 HTTP缓存技术 分为强制缓存和协商缓存两种。
强制缓存 浏览器判断缓存没有过期，就直接读本地缓存，主动权在浏览器 使用字段： Cache-Control，一个相对时间，优先级更高 Expires，一个绝对时间 协商缓存 响应码304 使用字段： 请求携带If-Modified-Since和响应携带Last-Modified，基于时间比较 请求携带If-None-Match和响应携带Etag，基于唯一标识比较 Etag优先级更高 强制缓存未命中才会走协商缓存 1.5 HTTP 特性 HTTP/1.1
简单：header+body，头部信息为key-value形式 灵活易于扩展：请求方法、状态码等允许开发人员自定义和扩充，工作在应用层（7层），下层可以随意变化 跨平台 无状态：基于Cookie和Session等方式记录操作状态 明文传输，不验证双方身份，无法证明报文完整性，不安全 长连接 管道网络传输，不必等待上一个请求响应，可以连续发送，但是默认不开启 队头阻塞：一个请求因为某些原因被阻塞时，后面排队的请求会一同被阻塞 HTTP/2.0做了什么优化
...</p></div><footer class=entry-footer><span title='2024-09-26 00:00:00 +0000 UTC'>September 26, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;359 words&nbsp;·&nbsp;RLTEA</footer><a class=entry-link aria-label="post link to HTTP" href=https://roaraeonliou.github.io/posts/interviewnotes/new/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/http/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>IP</h2></header><div class=entry-content><p>1 IP基础知识 1.1 IPv4地址分类 主机号全0或者全1有特殊意义：
全0：指定某个网络 全1：指定某个网络下全部主机 1.2 无分类地址CIDR 表示形式 a.b.c.d/x，其中 /x 表示前 x 位属于网络号，x 的范围是 0 ~ 32，这就使得 IP 地址更加具有灵活性。
还有另一种划分网络号与主机号形式，那就是子网掩码，掩码的意思就是掩盖掉主机号，剩余的就是网络号。
1.3 公有IP地址和私有IP地址 公有 IP 地址是有个组织统一分配的，假设你要开一个博客网站，那么你就需要去申请购买一个公有 IP，这样全世界的人才能访问。
1.4 IPv6 IPv4 的地址是 32 位的，大约可以提供 42 亿个地址，但是 IPv6 的地址是 128 位的。
IPv6 可自动配置，即使没有 DHCP 服务器也可以实现自动分配IP地址，便捷到即插即用。 IPv6 包头包首部长度采用固定的值 40 字节，去掉了包头校验和，简化了首部结构，减轻了路由器负荷，大大提高了传输的性能。 IPv6 有应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能，大大提升了安全性。 1.5 IPv4和IPv6首部 2 相关协议 2.1 DNS 将域名网址自动转换为具体的 IP 地址，域名的层级关系类似一个树状结构：
...</p></div><footer class=entry-footer><span title='2024-09-26 00:00:00 +0000 UTC'>September 26, 2024</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;511 words&nbsp;·&nbsp;RLTEA</footer><a class=entry-link aria-label="post link to IP" href=https://roaraeonliou.github.io/posts/interviewnotes/new/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ip/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MongoDB</h2></header><div class=entry-content><p>MongoDB MongoDB 是一个基于 分布式文件存储 的开源 NoSQL 数据库系统，由 C++ 编写的。MongoDB 提供了 面向文档 的存储方式，操作起来比较简单和容易，支持“无模式”的数据建模，可以存储比较复杂的数据类型，是一款非常流行的 文档类型数据库 。 在高负载的情况下，MongoDB 天然支持水平扩展和高可用，可以很方便地添加更多的节点/实例，以保证服务性能和可用性。在许多场景下，MongoDB 可以用于代替传统的关系型数据库或键/值存储方式，皆在为 Web 应用提供可扩展的高可用高性能数据存储解决方案。
1 MongoDB基础 1.1 MongoDB存储结构 MongoDB 的存储结构区别于传统的关系型数据库，主要由如下三个单元组成：
文档（Document）：MongoDB 中最基本的单元，由 BSON 键值对（key-value）组成，类似于关系型数据库中的行（Row）。 集合（Collection）：一个集合可以包含多个文档，类似于关系型数据库中的表（Table）。 数据库（Database）：一个数据库中可以包含多个集合，可以在 MongoDB 中创建多个数据库，类似于关系型数据库中的数据库（Database）。 也就是说，MongoDB 将数据记录存储为文档 （更具体来说是BSON 文档open in new window），这些文档在集合中聚集在一起，数据库中存储一个或多个文档集合。
与SQL的术语对比
SQL MongoDB Table（表） Collection（集合） Row（行） Document（文档） Col（列） Field（字段） Primary Key（主键） Object ID （对象ID） Index（索引） Index（索引） Embedded Table（嵌套表） Embedded Document（嵌入式文档） Array（数组） Array（数组） 1.2 MongoDB特点 数据记录被存储为文档：MongoDB 中的记录就是一个 BSON 文档，它是由键值对组成的数据结构，类似于 JSON 对象，是 MongoDB 中的基本数据单元。 模式自由：集合的概念类似 MySQL 里的表，但它不需要定义任何模式，能够用更少的数据对象表现复杂的领域模型对象。 支持多种查询方式：MongoDB 查询 API 支持读写操作 (CRUD)以及数据聚合、文本搜索和地理空间查询。 支持 ACID 事务：NoSQL 数据库通常不支持事务，为了可扩展和高性能进行了权衡。不过，也有例外，MongoDB 就支持事务。与关系型数据库一样，MongoDB 事务同样具有 ACID 特性。MongoDB 单文档原生支持原子性，也具备事务的特性。MongoDB 4.0 加入了对多文档事务的支持，但只支持复制集部署模式下的事务，也就是说事务的作用域限制为一个副本集内。MongoDB 4.2 引入了分布式事务，增加了对分片集群上多文档事务的支持，并合并了对副本集上多文档事务的现有支持。 高效的二进制存储：存储在集合中的文档，是以键值对的形式存在的。键用于唯一标识一个文档，一般是 ObjectId 类型，值是以 BSON 形式存在的。BSON = Binary JSON， 是在 JSON 基础上加了一些类型及元数据描述的格式。 自带数据压缩功能：存储同样的数据所需的资源更少。 支持 mapreduce：通过分治的方式完成复杂的聚合任务。不过，从 MongoDB 5.0 开始，map-reduce 已经不被官方推荐使用了，替代方案是 聚合管道open in new window。聚合管道提供比 map-reduce 更好的性能和可用性。 支持多种类型的索引：MongoDB 支持多种类型的索引，包括单字段索引、复合索引、多键索引、哈希索引、文本索引、 地理位置索引等，每种类型的索引有不同的使用场合。 支持 failover：提供自动故障恢复的功能，主节点发生故障时，自动从从节点中选举出一个新的主节点，确保集群的正常使用，这对于客户端来说是无感知的。 支持分片集群：MongoDB 支持集群自动切分数据，让集群存储更多的数据，具备更强的性能。在数据插入和更新时，能够自动路由和存储。 支持存储大文件：MongoDB 的单文档存储空间要求不超过 16MB。对于超过 16MB 的大文件，MongoDB 提供了 GridFS 来进行存储，通过 GridFS，可以将大型数据进行分块处理，然后将这些切分后的小文档保存在数据库中。 1.3 MongoDB应用场景 MongoDB 的优势在于其数据模型和存储引擎的灵活性、架构的可扩展性以及对强大的索引支持。
...</p></div><footer class=entry-footer><span title='2024-09-26 00:00:00 +0000 UTC'>September 26, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;173 words&nbsp;·&nbsp;RLTEA</footer><a class=entry-link aria-label="post link to MongoDB" href=https://roaraeonliou.github.io/posts/interviewnotes/database/nosql/mongodb/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MySQL</h2></header><div class=entry-content><p>MySQL 0 参考资料 黑马程序员 MySQL数据库入门到精通
图解MySQL介绍
MySQL | CS-Notes 面试笔记
MySQL面试题
MySQL常见面试题总结
SQL语句 通用语法
分号结尾，可多行书写 不区分大小写 注释采用–、#、/**/ 分类
DDL(Data Defination Language): 数据定义语言，用来定义数据库对象（数据库，表，字段）。 DML(Data Manipulation Language): 数据操作语言，用来对数据库表中数据进行增删改 DQL(Data Query Language): 数据查询语言，用来查询数据库中表的记录。 DCL(Data Control Language): 数据控制语言，用来创建数据库用户、控制数据库访问权限。 1 存储引擎 1.1 MySQL体系结构 连接层：负责连接处理、授权认证，以及相关的安全服务。 服务层：提供SQL借口，完成缓存查询，SQL的分析和优化，部分内置函数的执行，跨存储引擎功能的实现（过程、函数等）。 引擎层：负责数据的存储和提取，服务层通过API和存储引擎通话，不同存储引擎有不同功能。 存储层：将数据存储在文件系统上，完成于存储引擎的交互。 1.2 存储引擎特点 InnoDB：支持事务、支持行级锁、支持外键。 MyISAM：不支持事务，支持表级锁，访问速度快。 Memory：数据存放在内存，访问速度快，支持Hash索引。 2 索引 索引是帮助MySql高效获取数据的数据结构。
2.1 索引结构 索引是在存储引擎层实现的，不同存储引擎有不同的结构
索引结构 描述 B+Tree索引 大部分存储引擎都支持 Hash索引 底层使用Hash表实现，针对精确匹配有效，不支持范围查询 R-Tree索引（空间索引） MyISAM引擎拥有的特殊索引，用于地理空间数据类型 Full-Text索引 倒排索引，类似于Lucene、ES InnoDB和MyISAM都支持B+Tree索引和全文索引。
...</p></div><footer class=entry-footer><span title='2024-09-26 00:00:00 +0000 UTC'>September 26, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;736 words&nbsp;·&nbsp;RLTEA</footer><a class=entry-link aria-label="post link to MySQL" href=https://roaraeonliou.github.io/posts/interviewnotes/database/mysql/mysql/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MySQL补充</h2></header><div class=entry-content><p>MySQL补充 1 InnoDB中数据如何存放 InnoDB引擎中，一张表的数据是存放在“tableName.idb”表空间文件中的。
表空间由段（segment）、区（extent）、页（page）、行（row）组成。
行：记录按行存放 页：记录的读取写入是以页为单位，页是InnoDB存储引擎磁盘管理的最小单元。页的类型有数据页、undo log页、溢出页等。16KB。 区：表中数据量大的时候，为某个索引分配空间不再按照页为单位划分，而是以区为单位进行分配。1M。 段：表空间有索引段（B+Tree非叶子节点）、数据段（B+Tree叶子节点）、回滚段（MVCC）。 Compact行格式中，一条完整的记录分为「记录的额外信息」和「记录的真实数据」两个部分。
记录的额外信息：
变长字段长度列表：存储变长字段的数据占用的大小，当数据表没有变长字段的时候，表里的行格式就不会有「变长字段长度列表」。 NULL值列表：表中的某些列可能会存储 NULL 值，如果把这些 NULL 值都放到记录的真实数据中会比较浪费空间，所以 Compact 行格式把这些值为 NULL 的列存储到 NULL值列表中。如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。（1标识该列为NULL，0标识不为NULL）。当数据表的字段都定义成 NOT NULL 的时，表里的行格式就不会有 NULL 值列表。 记录头信息： delete_mask ：标识此条数据是否被删除。 next_record：下一条记录的位置。 record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录。 记录的真实数据：
记录真实数据部分除了我们定义的字段，还有三个隐藏字段，分别为：row_id、trx_id、roll_pointer。
row_id：如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id不是必需的，占用 6 个字节。 trx_id：事务id，表示这个数据是由哪个事务生成的。 trx_id是必需的，占用 6 个字节。 roll_pointer：这条记录上一个版本的指针。roll_pointer 是必需的，占用 7 个字节。 2 两阶段提交 事务提交后，redolog和binlog都要持久化到磁盘，但是这两个日志是独立的逻辑，可能会出现半成功的情况，也就是两个日志逻辑不一致：
如果在将 redo log 刷入到磁盘之后， MySQL 突然宕机了，而 binlog 还没有来得及写入。 导致从库的值是旧值，主库的是新值。 如果在将 binlog 刷入到磁盘之后， MySQL 突然宕机了，而 redo log 还没有来得及写入。 导致从库的值是新值，主库的是旧值。 MySQL 为了避免出现两份日志之间的逻辑不一致的问题，使用了「两阶段提交」来解决，两阶段提交其实是分布式事务一致性协议，它可以保证多个逻辑操作要不全部成功，要不全部失败，不会出现半成功的状态。
...</p></div><footer class=entry-footer><span title='2024-09-26 00:00:00 +0000 UTC'>September 26, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1215 words&nbsp;·&nbsp;RLTEA</footer><a class=entry-link aria-label="post link to MySQL补充" href=https://roaraeonliou.github.io/posts/interviewnotes/database/mysql/mysql%E8%A1%A5%E5%85%85/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>MySQL面试</h2></header><div class=entry-content><p>MySQL面试 1 基础 MySQL执行一条Select语句期间发生了什么？
通过连接器建立连接，管理链接、校验用户身份。
查询缓存：命中直接返回。
解析SQL，解析器对SQL查询语句进行词法语法分析。
执行SQL：
预处理：检查表或者字段是否存在；
优化：选择查询成本最小的执行计划；
执行：根据查询计划执行SQL语句，从存储引擎读取数据，返回给客户端。
MySQL 的 NULL 值是怎么存放的？
MySQL 的 Compact 行格式中会用「NULL值列表」来标记值为 NULL 的列，NULL 值并不会存储在行格式中的真实数据部分。
NULL值列表会占用 1 字节空间，当表中所有字段都定义成 NOT NULL，行格式中就不会有 NULL值列表，这样可节省 1 字节的空间。
MySQL 怎么知道 varchar(n) 实际占用数据的大小？
MySQL 的 Compact 行格式中会用「变长字段长度列表」存储变长字段实际占用的数据大小。
varchar(n) 中 n 最大取值为多少？
一行记录最大能存储 65535 字节的数据，但是这个是包含「变长字段字节数列表所占用的字节数」和「NULL值列表所占用的字节数」。所以， 我们在算 varchar(n) 中 n 最大值时，需要减去这两个列表所占用的字节数。
行溢出后，MySQL 是怎么处理的？
如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。
Compact 行格式针对行溢出的处理是这样的：当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。
Compressed 和 Dynamic 这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中。
2 索引 索引的分类
按数据结构分类：B+tree索引、Hash索引、Full-text索引
...</p></div><footer class=entry-footer><span title='2024-09-26 00:00:00 +0000 UTC'>September 26, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;415 words&nbsp;·&nbsp;RLTEA</footer><a class=entry-link aria-label="post link to MySQL面试" href=https://roaraeonliou.github.io/posts/interviewnotes/database/mysql/mysql%E9%9D%A2%E8%AF%95/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>NoSQL</h2></header><div class=entry-content><p>NoSQL NoSQL（Not Only SQL 的缩写）泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。 一个常见的误解是 NoSQL 数据库或非关系型数据库不能很好地存储关系型数据。NoSQL 数据库可以存储关系型数据—它们与关系型数据库的存储方式不同。 NoSQL 数据库代表：HBase、Cassandra、MongoDB、Redis。
SQL与NoSQL区别 SQL NoSQL 数据存储模型 结构化存储，具有固定的行和列的表格 非结构化存储。文档（JSON）、键值对、宽列、图 代表 Oracle、MySQL、SQL Sever MongoDB、Redis、Cassandra、HBase、Neo4j ACID 支持 通常不支持 性能 取决于磁盘子系统 取决于集群大小、网络延迟等 扩展 垂直扩展（升级机器）、读写分离、分库分表 横向（增加服务器，基于分片机制） 用途 普通企业项目数据存储 图数据库支持分析和遍历连接数据之间的关系、键值数据库可以处理大量数据扩展和极高的状态变化 查询语法 结构化查询语言 数据访问语法可能因数据库而异 NoSQL数据库优势 NoSQL 数据库非常适合许多现代应用程序，例如移动、Web 和游戏等应用程序，它们需要灵活、可扩展、高性能和功能强大的数据库以提供卓越的用户体验。
灵活性： NoSQL 数据库通常提供灵活的架构，以实现更快速、更多的迭代开发。灵活的数据模型使 NoSQL 数据库成为半结构化和非结构化数据的理想之选。 可扩展性： NoSQL 数据库通常被设计为通过使用分布式硬件集群来横向扩展，而不是通过添加昂贵和强大的服务器来纵向扩展。 高性能： NoSQL 数据库针对特定的数据模型和访问模式进行了优化，这与尝试使用关系数据库完成类似功能相比可实现更高的性能。 强大的功能： NoSQL 数据库提供功能强大的 API 和数据类型，专门针对其各自的数据模型而构建。 NoSQL数据库类型 NoSQL 数据库主要可以分为下面四种类型：
键值：键值数据库是一种较简单的数据库，其中每个项目都包含键和值。这是极为灵活的 NoSQL 数据库类型，因为应用可以完全控制 value 字段中存储的内容，没有任何限制。Redis 和 DynanoDB 是两款非常流行的键值数据库。 文档：文档数据库中的数据被存储在类似于 JSON（JavaScript 对象表示法）对象的文档中，非常清晰直观。每个文档包含成对的字段和值。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的结构通常与开发者在代码中使用的对象保持一致。MongoDB 就是一款非常流行的文档数据库。 图形：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。图形数据库的典型使用案例包括社交网络、推荐引擎、欺诈检测和知识图形。Neo4j 和 Giraph 是两款非常流行的图形数据库。 宽列：宽列存储数据库非常适合需要存储大量的数据。Cassandra 和 HBase 是两款非常流行的宽列存储数据库。</p></div><footer class=entry-footer><span title='2024-09-26 00:00:00 +0000 UTC'>September 26, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;80 words&nbsp;·&nbsp;RLTEA</footer><a class=entry-link aria-label="post link to NoSQL" href=https://roaraeonliou.github.io/posts/interviewnotes/database/nosql/nosql/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Redis</h2></header><div class=entry-content><p>Redis 黑马程序员Redis入门到实战教程
1 基本概念 1.1 Redis（::Re::mote ::Di::ctionary ::S::erver） 键值型存储，value支持多种不同数据结构。 单线程，每个命令具备原子性。（6.0之后的多线程仅是在网络处理部分，核心命令执行还是单线程） 低延迟，速度快（基于内存、IO多路复用、良好的编码）。 支持数据持久化。 支持主从集群和分片集群。 支持多语言客户端。 1.2 SQL和NoSQL SQL（Structured Query Language）：结构化的、关联的、SQL查询（语法固定）、事务（ACID） NoSQL（Not only SQL）：非结构的、非关联的、非SQL的（语法不固定，不统一）、不一定满足事务全部要求（BASE） 键值对：Redis 文档：MongoDB 图：Neo4j 列：HBase 1.3 Redis通用命令 // 1. 列出所有符合条件的key : KEYS [pattern] KEYS * KEYS a* // 2. 删除所有指定的key : DEL key [key ...] // 3. 判断key是否存在 : EXISTS key [key ...] // 4. 给一个key设置有效期，过期自动删除 : EXPIRE key seconds // 5. 查看命令具体用法 : help [command] // 6. 查看一个key的有效期 : TTL key 2 底层数据结构 Redis是一个key-value数据库，key一般是String类型，不过value的类型有很多：
...</p></div><footer class=entry-footer><span title='2024-09-26 00:00:00 +0000 UTC'>September 26, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1108 words&nbsp;·&nbsp;RLTEA</footer><a class=entry-link aria-label="post link to Redis" href=https://roaraeonliou.github.io/posts/interviewnotes/redis/redis/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://roaraeonliou.github.io/>«&nbsp;Prev&nbsp;
</a><a class=next href=https://roaraeonliou.github.io/page/3/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2024 <a href=https://roaraeonliou.github.io/>RLTEA BLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>