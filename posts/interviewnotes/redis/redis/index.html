<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Redis | RLTEA BLOG</title>
<meta name=keywords content="笔记,Redis,NoSQL,数据库"><meta name=description content="Redis
黑马程序员Redis入门到实战教程
1 基本概念
1.1 Redis（::Re::mote ::Di::ctionary ::S::erver）

键值型存储，value支持多种不同数据结构。
单线程，每个命令具备原子性。（6.0之后的多线程仅是在网络处理部分，核心命令执行还是单线程）
低延迟，速度快（基于内存、IO多路复用、良好的编码）。
支持数据持久化。
支持主从集群和分片集群。
支持多语言客户端。

1.2 SQL和NoSQL

SQL（Structured Query Language）：结构化的、关联的、SQL查询（语法固定）、事务（ACID）
NoSQL（Not only SQL）：非结构的、非关联的、非SQL的（语法不固定，不统一）、不一定满足事务全部要求（BASE）

键值对：Redis
文档：MongoDB
图：Neo4j
列：HBase



1.3 Redis通用命令
// 1. 列出所有符合条件的key : KEYS [pattern]
KEYS *
KEYS a*
// 2. 删除所有指定的key : DEL key [key ...]
// 3. 判断key是否存在 : EXISTS key [key ...]
// 4. 给一个key设置有效期，过期自动删除 : EXPIRE key seconds
// 5. 查看命令具体用法 : help [command]
// 6. 查看一个key的有效期 : TTL key
2 底层数据结构
Redis是一个key-value数据库，key一般是String类型，不过value的类型有很多："><meta name=author content="RLTEA"><link rel=canonical href=https://roaraeonliou.github.io/posts/interviewnotes/redis/redis/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.258803b0f0cc9a4a109c6fe78a9d39f2e0437217d71c5c9848255af9250f2b1b.css integrity="sha256-JYgDsPDMmkoQnG/nip058uBDchfXHFyYSCVa+SUPKxs=" rel="preload stylesheet" as=style><link rel=icon href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://roaraeonliou.github.io/posts/interviewnotes/redis/redis/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Redis"><meta property="og:description" content="Redis
黑马程序员Redis入门到实战教程
1 基本概念
1.1 Redis（::Re::mote ::Di::ctionary ::S::erver）

键值型存储，value支持多种不同数据结构。
单线程，每个命令具备原子性。（6.0之后的多线程仅是在网络处理部分，核心命令执行还是单线程）
低延迟，速度快（基于内存、IO多路复用、良好的编码）。
支持数据持久化。
支持主从集群和分片集群。
支持多语言客户端。

1.2 SQL和NoSQL

SQL（Structured Query Language）：结构化的、关联的、SQL查询（语法固定）、事务（ACID）
NoSQL（Not only SQL）：非结构的、非关联的、非SQL的（语法不固定，不统一）、不一定满足事务全部要求（BASE）

键值对：Redis
文档：MongoDB
图：Neo4j
列：HBase



1.3 Redis通用命令
// 1. 列出所有符合条件的key : KEYS [pattern]
KEYS *
KEYS a*
// 2. 删除所有指定的key : DEL key [key ...]
// 3. 判断key是否存在 : EXISTS key [key ...]
// 4. 给一个key设置有效期，过期自动删除 : EXPIRE key seconds
// 5. 查看命令具体用法 : help [command]
// 6. 查看一个key的有效期 : TTL key
2 底层数据结构
Redis是一个key-value数据库，key一般是String类型，不过value的类型有很多："><meta property="og:type" content="article"><meta property="og:url" content="https://roaraeonliou.github.io/posts/interviewnotes/redis/redis/"><meta property="og:image" content="https://roaraeonliou.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-26T00:00:00+00:00"><meta property="article:modified_time" content="2024-09-26T00:00:00+00:00"><meta property="og:site_name" content="RLTEA BLOG"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://roaraeonliou.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Redis"><meta name=twitter:description content="Redis
黑马程序员Redis入门到实战教程
1 基本概念
1.1 Redis（::Re::mote ::Di::ctionary ::S::erver）

键值型存储，value支持多种不同数据结构。
单线程，每个命令具备原子性。（6.0之后的多线程仅是在网络处理部分，核心命令执行还是单线程）
低延迟，速度快（基于内存、IO多路复用、良好的编码）。
支持数据持久化。
支持主从集群和分片集群。
支持多语言客户端。

1.2 SQL和NoSQL

SQL（Structured Query Language）：结构化的、关联的、SQL查询（语法固定）、事务（ACID）
NoSQL（Not only SQL）：非结构的、非关联的、非SQL的（语法不固定，不统一）、不一定满足事务全部要求（BASE）

键值对：Redis
文档：MongoDB
图：Neo4j
列：HBase



1.3 Redis通用命令
// 1. 列出所有符合条件的key : KEYS [pattern]
KEYS *
KEYS a*
// 2. 删除所有指定的key : DEL key [key ...]
// 3. 判断key是否存在 : EXISTS key [key ...]
// 4. 给一个key设置有效期，过期自动删除 : EXPIRE key seconds
// 5. 查看命令具体用法 : help [command]
// 6. 查看一个key的有效期 : TTL key
2 底层数据结构
Redis是一个key-value数据库，key一般是String类型，不过value的类型有很多："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://roaraeonliou.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Redis","item":"https://roaraeonliou.github.io/posts/interviewnotes/redis/redis/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Redis","name":"Redis","description":"Redis 黑马程序员Redis入门到实战教程\n1 基本概念 1.1 Redis（::Re::mote ::Di::ctionary ::S::erver） 键值型存储，value支持多种不同数据结构。 单线程，每个命令具备原子性。（6.0之后的多线程仅是在网络处理部分，核心命令执行还是单线程） 低延迟，速度快（基于内存、IO多路复用、良好的编码）。 支持数据持久化。 支持主从集群和分片集群。 支持多语言客户端。 1.2 SQL和NoSQL SQL（Structured Query Language）：结构化的、关联的、SQL查询（语法固定）、事务（ACID） NoSQL（Not only SQL）：非结构的、非关联的、非SQL的（语法不固定，不统一）、不一定满足事务全部要求（BASE） 键值对：Redis 文档：MongoDB 图：Neo4j 列：HBase 1.3 Redis通用命令 // 1. 列出所有符合条件的key : KEYS [pattern] KEYS * KEYS a* // 2. 删除所有指定的key : DEL key [key ...] // 3. 判断key是否存在 : EXISTS key [key ...] // 4. 给一个key设置有效期，过期自动删除 : EXPIRE key seconds // 5. 查看命令具体用法 : help [command] // 6. 查看一个key的有效期 : TTL key 2 底层数据结构 Redis是一个key-value数据库，key一般是String类型，不过value的类型有很多：\n","keywords":["笔记","Redis","NoSQL","数据库"],"articleBody":"Redis 黑马程序员Redis入门到实战教程\n1 基本概念 1.1 Redis（::Re::mote ::Di::ctionary ::S::erver） 键值型存储，value支持多种不同数据结构。 单线程，每个命令具备原子性。（6.0之后的多线程仅是在网络处理部分，核心命令执行还是单线程） 低延迟，速度快（基于内存、IO多路复用、良好的编码）。 支持数据持久化。 支持主从集群和分片集群。 支持多语言客户端。 1.2 SQL和NoSQL SQL（Structured Query Language）：结构化的、关联的、SQL查询（语法固定）、事务（ACID） NoSQL（Not only SQL）：非结构的、非关联的、非SQL的（语法不固定，不统一）、不一定满足事务全部要求（BASE） 键值对：Redis 文档：MongoDB 图：Neo4j 列：HBase 1.3 Redis通用命令 // 1. 列出所有符合条件的key : KEYS [pattern] KEYS * KEYS a* // 2. 删除所有指定的key : DEL key [key ...] // 3. 判断key是否存在 : EXISTS key [key ...] // 4. 给一个key设置有效期，过期自动删除 : EXPIRE key seconds // 5. 查看命令具体用法 : help [command] // 6. 查看一个key的有效期 : TTL key 2 底层数据结构 Redis是一个key-value数据库，key一般是String类型，不过value的类型有很多：\nString Hash List Set SortedSet（Zset） Geo BitMap HyperLog 2.1 动态字符串SDS Redis中保存的key是字符串，value往往是字符串或者字符串的集合。可见字符串是redis中最常用的一种数据结构。但是redis没有直接使用C语言中的字符串，因为C语言字符串存在很多问题：\n获取字符串长度需要通过运算； 非二进制安全； 不可修改。 Redis构建了一种新的字符串结构，称为简单动态字符串（Simple Dynamic String），简称SDS。\n当执行SET key value 时，会在底层创建两个SDS，其中一个包含key，另一个包含value。\nstruct __attribute__ ((__packed__)) sdshdr8{ /* unit8_t 无符号8位整型 */ /* 除了sdshdr8之外，redis还定义了5（弃用），16，32，64，支持不同长度的字节 */ unit8_t len; /* buf已保存的字符串字节数，不包含结束标识 */ /* 最多保存254字节，因为最后一个需要是\\0，为了兼容C语言 */ unit8_t alloc; /* buf已申请的总的字节数，不包含结束标识 */ unsigned char flags; /* 不同SDS的头类型，用来控制SDS的头大小 */ /* SDS_TYPE_5 -\u003e 0 SDS_TYPE_8 -\u003e 1 SDS_TYPE_16 -\u003e 2 SDS_TYPE_32 -\u003e 3 SDS_TYPE_64 -\u003e 4 */ char buf[]; /* 字符数组 */ }; SDS之所以叫动态字符串，是因为其具有动态扩容的功能\n当我们需要给SDS追加一段字符串时，首先会申请新内存空间：\n如果新字符串小于1M，则新空间为扩展后的字符串长度的2倍+1； 如果新字符串大于1M，则新空间为扩展后字符串长度+1M+1。称为内存预分配。 优点：\n获取字符串长度的时间复杂度为O（1） 支持动态扩容 减少内存分配次数 二进制安全 2.2 IntSet 元素唯一，有序 具备类型升级机制，可以节省内存空间 底层采用二分查找方式查询 IntSet是Redis中set集合的一种实现方式，基于整数数组实现，并具备长度可变，有序等特征。\ntypedef struct intset{ unit32_t encoding; /* 编码方式，支持存放16位，32位，64位整数 */ unit32_t length; /* 元素个数 */ int8_t contents[]; /* 整数数组，保存集合数据，仅仅是指针，具体元素类型由encoding指定 */ }intset; 其中encoding包含三种模式，表示存储的整数大小不同。\n#define INSET_ENC_INT16 (sizeof(int16_t)) /* 2字节整数，范围类似java中的short */ #define INSET_ENC_INT32 (sizeof(int32_t)) /* 4字节整数，范围类似java中的int */ #define INSET_ENC_INT64 (sizeof(int64_t)) /* 8字节整数，范围类似java中的long */ 为了方便查找，Redis中将IntSet中所有整数按照升序一次保存在contents数组中。\nencoding：4字节（unit32_t）。 length：4字节（unit32_t）。 contents：2字节（INESET_ENC_INT16）*3 = 6字节。 IntSet升级\n假设有一个intset，元素为{5, 10, 20}，采用INTSET_ENC_INT16，则每个整数占2字节。\n当我们向其中添加一个数字50000时，这个数字超过了int16_t的范围，intset会自动升级编码方式到合适的大小。\n升级编码为INTSET_ENC_INT32，每个整数占4字节，按照新的编码方式及元素个数扩容数组。 倒序一次将数组中元素拷贝到扩容后的正确位置。 将带添加元素放入数组末尾。（只可能比所有元素大或者小，否则不会超出编码表示范围） 最后将intset的encoding属性改为INTSET_ENCINT32，将length属性改为4。 当我们插入的元素在编码表示范围内时，首先进行扩容，然后采用二分查找获取插入下标，然后倒序移动元素腾出位置，插入元素。\n2.3 Dict Dict由三部分组成，分别是哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）。\ntypedef struct dict{ dictType *type; // dict类型，内置不同hash函数 void *privdata; // 私有数据，在做特殊hash运算时使用 dictht ht[2]; // 一个dict包含两个哈希表，其中一个是当前数据，另一个为空，rehash时使用 long rehashidx; // rehash的进度，-1表示未运行。 int16_t pauserehash; // rehash是否暂停，1表示暂停，0表示继续。 }dict; typedef struct dictht{ // entry数组 // 数组中保存的是指向entry的指针 dictEntry **table; // 哈希表的大小，永远是2的幂次，为了保证与运算可以代替求余。 usigned long size; // 哈希表大小的掩码，总等于size-1 usigned long sizemask; // entry个数 usigned long used; }dictht; typedef struct dictEntry{ void *key; //键 union{ //联合体，可以是其中的一个，但不能同时成立 void *val; unit64_t u64; int64_t s64; double d; }v; //值 // 下一个Entry的指针 struct dictEntry *next; }dictEntry; 当我们向Dict添加键值对时，Redis首先根据Key计算出hash值（h），然后利用h\u0026sizemask计算元素应该存储到数组中哪个索引位置。\n链地址法解决hash冲突，头插法：\nDict扩容\nhashtable是通过数组组合单向链表实现的，当集合中元素较多时，必然会导致哈希冲突增多，链表过长，则查询效率大大降低。\nDict在每次新增键值对时，会检查负载因子（LoadFactor = used/size），满足以下两种情况时，会发生哈希表扩容。\n哈希表的LoadFactor≥1，并且服务器没有执行BGSAVE或者BGWRITEAOF等后台进程。 哈希表的LoadFactor\u003e5。 扩容会保证size为2的n次方。 Dict的收缩\nDict在每次删除元素时，会对负载因子做检查，当LoadFactor\u003c0.1时，会做哈希表收缩。\n收缩时也会保证size为2的n次方。\nDict的rehash\n不管是扩容还是收缩，必定会创建新的哈希表，导致哈希表的size和sizemask变化，而key的查询于sizemask有关。因此必须对hash表中的每一个key重新计算索引，插入新的hash表，这个过程称为rehash。\n计算新hash表的realeSize，值取决于是要扩容还是收缩 按照i虚拟的realeSize申请内存空间，创建dictht，并赋值给dict.ht[1]。 设置dict.rehashidx=0，表示开始rehash 将dict.ht[0]中的每一个dictEntry都rehash到dict.ht[1]。 每次执行增删改查时，检查dict.rehashidx是否大于-1，如果是则将dict.ht[0].table[rehashidx]的entry链表rehash到dict.ht[1]，并将rehashidx++。指导dict.ht[0]所有数据都rehash到dict.ht[1]。【渐进式rehash】 将dict.ht[1]赋值给dict.ht[0]，给dict.ht[1]初始化为空哈希表，释放原来的dict.ht[0]的内存。 将rehashidx赋值为-1，代表rehash结束。 在rehash过程中，新增操作，则直接写入ht[1]，查询、修改、删除则会在dict.ht[0]和dict.ht[1]一次查找并执行。这样可以确保ht[0]数据只减不增，直到空为止。 2.4 ZipList 一种特殊的\"双端链表\"，由一系列特殊编码的连续内存块组成。可以在任意一端进行压入、弹出操作，并且该操作的时间复杂度为O（1）。\n列表之间节点不是通过指针连接，而是记录上一节点和本节点的长度来寻址，占用内存较低。\n如果列表数据过多，导致链表过长，可能会影响查询性能。\n增或删较大数据时可能会发生连锁更新问题。\n属性 类型 长度 用途 zlbytes unit32_t 4字节 记录整个压缩列表占用的内存字节数 zltail unit32_t 4字节 记录压缩列表尾节点距离压缩列表的起始地址有多少字节，通过这个偏移量可以确定表尾节点的地址。 zllen unit16_t 2字节 记录了压缩列表包含的节点数量。最大为UINT16_MAX（65534），如果超过这个最大值，此处会记录为65535，但节点的真是数量需要遍历整个压缩列表才能计算得出。 entry 列表节点 不定 压缩列表包含的各个节点，节点的长度由节点保存的内容决定。 zlend unit8_t 1字节 特殊值0XFF（十进制255），用于标记压缩列表的末端。 ZipListEntry ZipList中的Entry并不像普通链表那样记录前后节点的指针，因为记录两个指针要占用16字节，浪费内存，而是采用了下面的结构。\nprevious_entry_length：前一节点长度，占1个或者5个字节 前一节点长度小于254，采用1字节保存长度 前一节点长度大于254，采用5个字节保存这个长度，第一个字节为0xfe，后面四个字节才是真实的长度。 encoding：编码属性，记录content的数据类型（字符串还是整数）以及长度，占用1个、2个或者5个字节。 content：负责保存节点的数据，可以是字符串或整数。 ZipList中所有存储长度的数值均采用小端字节序，即低位字节在前，高位字节在后。\nEncoding编码分为字符串和整数两种：\n00、01、10开头，证明是字符串。 编码 编码长度 字符串大小 00pppppp 01pppppp qqqqqqqq 1000000000 qqqqqqqq 11开头表示整数 编码 编码长度 整数类型 11000000 1 int16_t(2 bytes) 11010000 1 int32_t(4 bytes) 11100000 1 int64_t(8 bytes) 11110000 1 24位有符号整数(3 bytes) 11111110 1 8位有符号整数(1 byte) 1111XXXX 1 直接在XXXX位置保存数值，范围从0001-1101，减1后结果为实际值。 ZipList连锁更新问题 ZipList的每个Entry都包含previous_entry_length记录前一节点长度，占1个或者5个字节\n前一节点长度小于254，采用1字节保存长度 前一节点长度大于254，采用5个字节保存这个长度，第一个字节为0xfe，后面四个字节才是真实的长度。 假设有N个连续的、长度为250-253字节之间的entry，因此entry的previous_entry_length属性用1个字节即可表示。此时，插入一个范围超过254字节的entry，导致其后面所有的entry的previous_entry_length全部都需要改变为5字节。Zip在这种情况下产生的多次空间操作称之为连锁更新。新增、删除都可能导致连锁更新的发生。\nRedis作者并没有解决，这种情况发生概率很低，但是不代表不会发生。\n2.5 QuickList 问题：ZipList虽然节省内存空间，但申请内存必须是连续的，如果内存占用较多，申请内存效率很低。怎么办？\n限制ZipList长度和Entry大小。 问题：但是我们要存储大量数据，超过了ZipList最佳上限怎么办？\n创建多个ZipList来分片存储。 问题：数据拆分后比较分散，不方便管理和查找，这多个ZipList如何建立联系？\nRedis3.2版本后引入了QuickList，它是一个双端链表，只不过每个节点都是一个ZipList。 为了避免QuickList中每个ZipList中entry过多，Redis提供了一个配置项：list-max-ziplist-size： 正数：ZipList允许的Entry个数的最大值。 负数：ZipList最大内存的大小： -1：不超过4kb。 -2：不超过8kb。 -3：不超过16kb。 -4：不超过32kb。 -5：不超过64kb。 默认值为-2。 除了控制ZipList大小外，QuickList还可以对节点的ZipList做压缩，通过配置list-compress-depth来控制。因为链表一般都是从首尾访问较多，所以首尾不压缩。这个参数是控制首尾不压缩的节点个数： 0： 特殊值，不压缩。 1：表示首尾各一个不压缩，中间节点压缩。 2：表示首尾各两个不压缩，中间节点压缩。 以此类推。 typedef struct quicklist{ quicklistNode *head; // 头节点指针 quicklistNode *tail; // 尾节点指针 unsigned long count; // 所有ZipList的entry数量 unsigned long len; // ziplist总数量 int fill : QL_FILL_BITS; // ziplist的entry上限，默认值-2 unsigned int compress : QL_COMP_BITS; // 首尾不压缩的节点数量 unsigned int bookmark_count : QL_BM_BITS; // 内存重新分配时的书签数量及数组，一般用不到 quicklistBookmark bookmarks[]; }quicklist; typedef struct quicklistNode{ struct quicklistNode *prev; //前一个节点指针 struct quicklistNode *next; //后一个节点指针 unsigned char *zl; //当前节点ZipList指针 unsigned int sz; //当前ZipList的字节大小 unsigned int count : 16; //当前ZipList的Entry个数 unsigned int encoding : 2; // 编码方式：1.ZipList；2.lzf压缩模式 unsigned int container : 2; //数据容器类型（预留）：1.其他；2.ZipList unsigned int recompress : 1; //是否被解压缩：1.已经被解压缩，将来要重新压缩 unsigned int attempted_compress : 1; //测试使用 unsigned int extra : 10; //预留字段 }quicklistNode; 2.6 SkipList SkipList首先是链表，但是与传统链表有几点差异：\n元素按照升序排列存储。 节点可能包含多个指针，指针跨度不同。 typedef struct zskiplist{ struct zskiplistNode *header, *tail; // 头尾节点指针 usigned long length; //节点数量 int level; //最大索引层级，默认是1 }zskiplist; typedef struct zskiplistNode{ sds ele; //节点存储的值 double score; //节点分数，排序、查找用 struct zskiplistNode *backward; //前一个节点的指针 struct zskiplistLevel{ struct zskiplistNode *forward; //下一个节点的指针 unsigned long span; //索引跨度 } level[]; // 多级索引数组 }zskiplistNode; 本质是一个双向链表，每个节点都包含score值和ele值 节点按照score值排序，score值一样按照ele字典排序 每个节点都可以包含多层指针，层数是1-32之间的随机数 不同层指针到下一个节点的跨度不同，层级越高，跨度越大 增删改查效率基本与红黑树一致，实现却更简单 2.7 RedisObject typedef struct redisObject{ unsigned type : 4; // 对应string、hash、list、set、zset，占4个bit位 unsigned encoding : 4; // 底层编码方式，共有11种，占4个bit位 unsigned lru : LRU_BITS; // LRU_BTS为24，表示该对象最后一次被访问的时间 int refcount; //引用计数器，计数器为0则说明对象无人使用，可以被回收，4字节 void *ptr; //指向存放实际数据的空间，一般是8字节 }robj; //头部占用16字节 encoding编码方式\n编号 编码方式 说明 0 OBJ_ENCODING_RAW raw编码动态字符串 1 OBJ_ENCODING_INT long类型的整数的字符串 2 OBJ_ENCODING_HT hash表（字典dict） 3 OBJ_ENCODING_ZIPMAP 已废弃 4 OBJ_ENCODING_LINKEDLIST 双端链表 5 OBJ_ENCODING_ZIPLIST 压缩列表 6 OBJ_ENCODING_INTSET 整数集合 7 OBJ_ENCODING_SKIPLIST 跳表 8 OBJ_ENCODING_EMBSTR embstr的动态字符串 9 OBJ_ENCODING_QUICKLIST 快速列表 10 OBJ_ENCODING_STREAM Stream流 2.8 五种数据结构 五种数据结构对应的编码方式\n数据类型 编码方式 OBJ_STRING int, embstr, raw OBJ_LIST LinkedList和ZipList(3.2之前)，QuickList(3.2之后) OBJ_SET intset、HT OBJ_ZSET ZipList、HT、SkipList OBJ_HASH ZipList、HT 2.8.1 String 基本编码方式是RAW，基于简单动态字符串（SDS）实现，存储上限为512MB。 如果存储的SDS长度小于44字节，则会采用EMBSTR编码，此时object head与SDS是一段连续空间，申请内存时只需要调用一次内存分配函数，效率更高。（不超64字节，分配内存基本单位？） 如果存储的字符串是整数值的时候，并且在LONG_MAX范围内，则会采用INT编码：直接将数据保存在RedisObject的ptr指针位置（刚好8字节），不再需要SDS了。 2.8.2 List 在3.2版本之前，Redis采用ZipList和LinkedList来实现，当元素数量小于512且元素大小小于64字节时，采用ZipList编码，超过则采用LinkedList。 在3.2版本之后，Redis同一采用QuickList来实现List。 2.8.3 Set Set不保证有序性，保证元素唯一，可以求交集、并集、差集，要求查询效率高。\n为了查询效率和唯一性，set采用HT编码（Dict）。Dict中的key用来存储元素，value统一为null。 当存储的所有数据都是整数时，并且元素数量不超过set-max-intset-entries时，Set会采用IntSet编码，以节省内存。 2.8.4 Zset 每一个元素都需要指定一个score值和member值：\n可以根据score值排序 member必须唯一 可以根据member查询分数 因此底层数据结构必须满足键值存储、键必须唯一、可排序。\ntypedef struct zset{ dict *dict; //dict指针 zskiplist *zsl; // SkipList指针 }zset; 当元素不多时，HT和SkipList的优势并不明显，而且更消耗内存。因此zset还会采用ZipList结构来节省内存，不过需要同时满足两个条件：\n元素数量小于zset_max_ziplist_entries，默认128； 每个元素都小于zset_max_ziplist_value字节，默认值64。 ZipList本身没有排序功能，而且没有键值对概念，因此需要由zset通过编码实现：\nZipList是连续内存，因此score和element是紧挨在一起的两个entry，element在前，score在后。 score越小越接近队首，score越大越接近队尾，按照score值升序排列。 2.8.5 Hash 键必须唯一，根据键获取值。\n底层与Zset基本一致，只不过把排序有关的SkipList去掉即可。\nHash结构默认采用ZipList编码，用以节省内存。ZipList中相邻的两个entry分别保存filed和value。 当数据量较大时，Hash结构会转为HT编码，也就是Dict，触发条件需要满足： ZipList中元素的数量超过了hash-max-ziplist-entries（默认512）； ZipList中的任意entry大小超过了hash-max-ziplist-value（默认64字节）； 3 分布式锁 满足在分布式系统或集群模式下多进程可见并互斥的锁。\nMySQL Redis Zookeeper 互斥 利用mysql本身的互斥锁机制 利用setnx互斥命令 利用节点的唯一性和有序性实现互斥 高可用 好 好 好 高性能 一般 好 一般 安全性 断开连接，自动释放锁 利用锁超时时间，到期释放 临时节点，断开连接自动释放 3.1 基于Redis实现 实现分布式锁需要实现两个基本方法：\n获取锁 互斥：确保只能有一个线程获取锁 SETNX lock thread1 、EXPIRE lock 10 。 两条命令需要时原子性的，所以 SET lock thread NX EX 10 。 非阻塞式：尝试一次，成功返回true，失败返回false 释放锁 手动释放：DEL key 超时释放：获取锁时添加一个超时时间。 存在的问题\n由于阻塞，锁提前释放，线程苏醒后释放别人的锁。\n解决方案：获取锁标识，并半段是否一致，避免误删其他线程的锁。\n还存在的问题\n判断锁标识和释放锁是两个动作，两个动作之间出现阻塞。\n解决方案：保证两个操作的原子性。\n使用Lua脚本，lua脚本在redis中是原子性的。\n3.2 基于Redisson实现 基于Redis实现存在的问题：\n不可重入，同一个线程无法多次获取同一把锁。 不可重试，获取锁只尝试一次就返回flase，没有重试机制。 超时释放，虽然可以避免死锁，但是业务耗时较长，也会导致锁释放，存在安全隐患。 主从一致性，如果Redis提供了主从集群，主从同步存在延迟，当主节点宕机时，如果从节点同步主节点的所数据，则会出现锁失效。 Redisson是一个在Redis的基础上实现的Java驻内存数据网格。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。\n4 持久化 4.1 RDB持久化 RDB全程Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。\n快照文件称为RDB文件。默认是保存在当前运行目录。\nsave命令：Redis主进程执行RDB，会阻塞所有命令。 bgsave命令：开启子进程执行RDB，避免主进程受到影响。bgsave开始时回fork主进程得到子进程，子进程共享主进程的内存数据。完成fork（复制页表）后读取内存数据并写入RDB。 fork采用的是copy-on-write技术：主进程读操作共享内存，主进程写操作，则会拷贝一份数据，执行写操作。 Redis停机时会自动执行一次RDB。\n### redis.conf #900秒内，如果至少有1个key被修改，则执行bgsave，如果是save \"\"，则表示禁用RDB save 900 1 #指定RDB文件名 dbfilename dump.rdb #文件保存的默认路径 dir ./ Redis的快照是全量快照，也就是说每次执行快照持久化，都是把内存中的所有数据记录到磁盘中。\n存在缺点：\nRDB执行间隔时间长，两次RDB之间写入数据有丢失的风险； fork子进程、压缩、写出RDB文件都比较耗时。 4.2 AOF持久化 AOF全称为Append Only File（追加文件）。Redis 每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里。这种保存写操作命令到日志的持久化方式，就是 Redis 里的 AOF 持久化功能，注意只会记录写操作命令，读操作命令是不会被记录的。\nAOF默认关闭。\n为什么先执行写命令，后记录AOF 好处：\n避免额外的检查开销 不阻塞当前写命令操作 风险：\n数据有丢失风险 可能会给【下一个】写命令带来阻塞 三种写回策略 always：每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘； everysec：每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘； no：不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。 配置项 刷盘时机 优点 缺点 Always 同步刷盘 可靠性高，几乎不丢数据 性能影响大 everysec 每秒刷盘 性能适中 最多丢失1秒数据 no 操作系统控制 性能最好 可靠性较差，可能丢失大量数据 AOF重写机制 Redis 为了避免 AOF 文件越写越大，提供了 AOF 重写机制，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。\nAOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。\n为什么重写 AOF 的时候，不直接复用现有的 AOF 文件，而是先写到新的 AOF 文件再覆盖过去。\n因为如果 AOF 重写过程中失败了，现有的 AOF 文件就会造成污染，可能无法用于恢复使用。\nAOF后台重写 BGREWRITEAOF\n重写的过程是由后台子进程完成的，这样可以使得主进程可以继续正常处理命令。\n用 AOF 日志的方式来恢复数据其实是很慢的，因为 Redis 执行命令由单线程负责的，而 AOF 日志恢复数据的方式是顺序执行日志里的每一条命令，如果 AOF 日志很大，这个「重放」的过程就会很慢了。\n4.3 RDB和AOF对比 RDB AOF 持久化方式 定时对整个内存做快照 记录每一次执行的命令 数据完整性 不完整，两次备份之间会丢失 相对完整，取决于刷盘策略 文件大小 会有压缩，文件体积小 记录命令，文件体积很大 宕机恢复速度 快 慢 数据恢复优先级 低，因为数据完整性不如AOF 高，数据完整性更高 系统资源占用 高，大量CPU和内存消耗 低，主要是磁盘IO资源，但是AOF重写时会占用大量CPU和内存资源 使用场景 可容忍数分钟的数据丢失，追求更快的启动速度 对数据安全性要求较高的场景 5 分布式缓存 5.1 Redis主从 单节点Redis的并发能力有上限，要进一步提高Redis的并发能力，需要搭建主从集群，实现读写分离。\n在redis.conf文件中配置slaveof 。\n常见拓扑结构：\n一主一从 一主多从 树状主从 数据同步原理\n主从第一次同步是全量同步。\n如果slave重启后同步，则执行增量同步。\nrepl_baklog大小有上限，写满后会覆盖最早的数据。如果slave断开时间过久，导致数据被覆盖，则无法实现增量同步，只能再次进行全量同步。 优化主从集群\n在master中配置repl-diskless-sync yes启用无磁盘复制，避免全量同步时的磁盘IO。 Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO。 适当提高repl_baklog的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步。 限制一个master上的slave节点数量，如果slave太多，可以采用主-从-从链式结构，减少master压力。 5.2 哨兵 slave宕机恢复后，可以找master节点同步数据，那master节点宕机后怎么办？\nRedis提供了**哨兵（Sentinel）**机制来实现主从集群的自动故障恢复。\n监控：Sentinel会不断检查master和slave是否按预期工作。 自动故障恢复： 如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主。 通知：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新消息推送给Redis客户端。 Sentinel基于心跳机制检测服务状态，每隔1秒向集群的每个实例发送ping命令：\n主观下线：如果某个sentinel节点发现某个实例未在规定时间响应，则认为该实例主观下线。 客观下线：如果超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例客观下线。quorum值最好超过Sentinel实例数量的一半。 选举\n一旦发现master故障，sentinel需要在slave中选择一个作为新的master：\n首先判断slave节点与master节点断开时间长短，如果超过指定值（down-after-millseconds*10）则会排除该slave节点。 然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永远不参与选举。 如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高。 最后是判断slave节点的运行id大小，越小优先级越高。 故障转移过程\n选取slave为master sentinel向备选节点发送slaveof no one 使得该节点成为主节点 sentinel向其他所有slave发送slaveof 将故障节点标记为slave RedisTemplate的哨兵模式\n在posm中引入redis的starter依赖 在Application.yml中指定sentinel集群相关信息 配置主存读写分离 5.3 Redis分片集群 主从和哨兵可以解决高可用、高并发读的问题。但是无法解决海量数据存储和高并发写的问题。\n使用分片集群可以解决上述问题，其特点有：\n集群中有多个master，每个master保存不同数据。 每个master都可以有多个slave节点。 master之间通过ping检测彼此健康状态。（不需要哨兵） 客户端请求可以访问集群任意节点，最终都会被转发到正确节点。 Redis分区策略：\n哈希取余分区：简单，平均，不利于扩容或收缩。 一致性哈希算法分区：扩展性得到保证，但是数据会有倾斜问题。 哈希插槽分区：Redis集群内置16384（0-16383）个哈希槽，redis会根据节点数量大致均等的将哈希槽映射到不同节点。数据到来时，根据key使用CRC16算法算出结果后对16384取余，映射到哈希槽。槽用来扩大数据粒度，便于移动，哈希解决映射问题。 key中包含{}，并且{}中至少包含1个字符，redis根据{}中的部分计算插槽值。 key中不包含{}，整个key都被用来计算插槽值。 分片集群下的自动故障转移\nmaster实例与其他实例失去连接。 进入疑似宕机状态。 确认下线，自动提升一个slave为master。 分片集群下手动故障转移（用于无感知机器升级）\n利用cluster failover 命令手动使得集群中某个master宕机，切换到执行该命令的slave节点，实现无感知的数据迁移。\n手动Failover支持的三种模式：\n缺省：默认图中流程。 force：省略对offset的一致性校验。 takeover：直接执行第五步，忽略一致性、master状态和其他master意见。 RedisTemplate分片集群\n引入redis的starter依赖 配置分片集群地址 配置读写分离 5.4 缓存问题 缓存穿透：key对应数据在数据源不存在 解决方案： 缓存空对象，数据库没找到，在redis缓存null，有额外内存消耗。 布隆过滤器，可能会有误判。 缓存击穿：key对应数据在数据源存在，但是过期 解决方案： 互斥锁：无额外内存消耗，保证一致性，线程需要等待，可能死锁。 逻辑过期：线程无需等待，不保证一致性，有额外内存消耗。 缓存雪崩：大量缓存失效，服务器宕机、缓存集中失效 解决方案： 提高可用性 均匀过期+热点数据永不过期 熔断降级 添加多级缓存 5.5 缓存预热 预留接口手动预热 项目启动设置自动预热 定时任务刷新缓存 6 内存回收 typedef struct redisDb{ dict *dict; //存放所有key及value的地方，也称为keyspace dict *expires; //存放每一个key及其对应的TTL存活时间，只包含设置了TTL的key dict *blocking_keys; //Keys with clients waiting for data dict *ready_keys; //blocked keys that received a push dict *watched_keys; //watched keys for multi/exec cas int id; //database ID， 0-15 long long avg_ttl; //记录平均TTL时长 unsigned long expires_cursor; //expire检查时在dict中抽样索引的位置 list *defrag_later; //等待碎片整理的key列表 }redisDb; 6.1 Redis过期key处理 惰性删除：访问一个key时，检查该key的存活时间，如果已经过期才执行删除。 周期删除：通过定时任务，周期性抽样部分过期的key，然后执行删除。 Redis设置一个定时任务serverCron()，按照server.hz的频率来执行过期key清理，模式为SLOW。 执行频率受server.hz影响，默认为10，即每秒执行10次。 执行清理耗时不超过一次执行周期的25%。 逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期。 没达到时间上限25ms，并且过期key比例大于10%（5个？），再进行一次抽样，否则结束。 Redis的每个事件循环前会调用beforeSleep()函数，执行过期key清理，模式为FAST。 执行频率受beforeSleep()调用频率影响，但两次FAST模式间隔不低于2ms。 执行清理耗时不超过1ms。 逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期。 没达到时间上限1ms，并且过期key比例大于10%，在进行一次抽样，否则结束。 6.2 Redis内存淘汰策略 当Redis内存使用达到设置的阈值时，Redis主动挑选部分Key删除，以释放内存。\n八种淘汰策略：\nnoeviction：不淘汰任何key，内存满时不允许写入新数据，默认策略 volatile-ttl：对设置了TTL的key，比较剩余TTL可以，TTL越小越先被淘汰。 allkeys-random：对全体Key，随机进行淘汰。即在db→dict中随机挑选。 volatile-random：对设置了TTL的key，随即进行淘汰，即在db→expires中随机挑选。 allkeys-lru：对全体key基于LRU算法进行淘汰。 volatile-lru：对设置了TTL的key基于LRU算法进行淘汰。 allkeys-lfu：对全体key基于LFU算法进行淘汰。 volatile-lfu：对设置了TTL的key基于LFU算法进行淘汰。 LRU(Least Recently Used)，最少最近使用。当前时间减去最后一次访问时间，值越大，淘汰优先级越高。\nLFU(Least Frequently Used)，最少频率使用。访问频率低的淘汰优先级高。\n逻辑访问次数通过一定算法计算得出，并且会根据上一次访问时间衰减。\n","wordCount":"1108","inLanguage":"en","image":"https://roaraeonliou.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-09-26T00:00:00Z","dateModified":"2024-09-26T00:00:00Z","author":{"@type":"Person","name":"RLTEA"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://roaraeonliou.github.io/posts/interviewnotes/redis/redis/"},"publisher":{"@type":"Organization","name":"RLTEA BLOG","logo":{"@type":"ImageObject","url":"https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E"}}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["\\(","\\)"],["$","$"]]}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://roaraeonliou.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://roaraeonliou.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://roaraeonliou.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://roaraeonliou.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://roaraeonliou.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://roaraeonliou.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://roaraeonliou.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://roaraeonliou.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Redis</h1><div class=post-meta><span title='2024-09-26 00:00:00 +0000 UTC'>September 26, 2024</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1108 words&nbsp;·&nbsp;RLTEA&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/InterviewNotes/Redis/Redis.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#redis aria-label=Redis>Redis</a></li><li><a href=#1-%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5 aria-label="1 基本概念">1 基本概念</a><ul><li><a href=#11-redisremote-dictionary-server aria-label="1.1 Redis（::Re::mote ::Di::ctionary ::S::erver）">1.1 Redis（::Re::mote ::Di::ctionary ::S::erver）</a></li><li><a href=#12-sql%e5%92%8cnosql aria-label="1.2 SQL和NoSQL">1.2 SQL和NoSQL</a></li><li><a href=#13-redis%e9%80%9a%e7%94%a8%e5%91%bd%e4%bb%a4 aria-label="1.3 Redis通用命令">1.3 Redis通用命令</a></li></ul></li><li><a href=#2-%e5%ba%95%e5%b1%82%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label="2 底层数据结构">2 底层数据结构</a><ul><li><a href=#21-%e5%8a%a8%e6%80%81%e5%ad%97%e7%ac%a6%e4%b8%b2sds aria-label="2.1 动态字符串SDS">2.1 动态字符串SDS</a></li><li><a href=#22-intset aria-label="2.2 IntSet">2.2 IntSet</a></li><li><a href=#23-dict aria-label="2.3 Dict">2.3 Dict</a></li><li><a href=#24-ziplist aria-label="2.4 ZipList">2.4 ZipList</a><ul><li><a href=#ziplistentry aria-label=ZipListEntry>ZipListEntry</a></li><li><a href=#ziplist%e8%bf%9e%e9%94%81%e6%9b%b4%e6%96%b0%e9%97%ae%e9%a2%98 aria-label=ZipList连锁更新问题>ZipList连锁更新问题</a></li></ul></li><li><a href=#25-quicklist aria-label="2.5 QuickList">2.5 QuickList</a></li><li><a href=#26-skiplist aria-label="2.6 SkipList">2.6 SkipList</a></li><li><a href=#27-redisobject aria-label="2.7 RedisObject">2.7 RedisObject</a></li><li><a href=#28-%e4%ba%94%e7%a7%8d%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label="2.8 五种数据结构">2.8 五种数据结构</a><ul><li><a href=#281-string aria-label="2.8.1 String">2.8.1 String</a></li><li><a href=#282-list aria-label="2.8.2 List">2.8.2 List</a></li><li><a href=#283-set aria-label="2.8.3 Set">2.8.3 Set</a></li><li><a href=#284-zset aria-label="2.8.4 Zset">2.8.4 Zset</a></li><li><a href=#285-hash aria-label="2.8.5 Hash">2.8.5 Hash</a></li></ul></li></ul></li><li><a href=#3-%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81 aria-label="3 分布式锁">3 分布式锁</a><ul><li><a href=#31-%e5%9f%ba%e4%ba%8eredis%e5%ae%9e%e7%8e%b0 aria-label="3.1 基于Redis实现">3.1 基于Redis实现</a></li><li><a href=#32-%e5%9f%ba%e4%ba%8eredisson%e5%ae%9e%e7%8e%b0 aria-label="3.2 基于Redisson实现">3.2 基于Redisson实现</a></li></ul></li><li><a href=#4-%e6%8c%81%e4%b9%85%e5%8c%96 aria-label="4 持久化">4 持久化</a><ul><li><a href=#41-rdb%e6%8c%81%e4%b9%85%e5%8c%96 aria-label="4.1 RDB持久化">4.1 RDB持久化</a></li><li><a href=#42-aof%e6%8c%81%e4%b9%85%e5%8c%96 aria-label="4.2 AOF持久化">4.2 AOF持久化</a><ul><ul><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e5%85%88%e6%89%a7%e8%a1%8c%e5%86%99%e5%91%bd%e4%bb%a4%e5%90%8e%e8%ae%b0%e5%bd%95aof aria-label=为什么先执行写命令，后记录AOF>为什么先执行写命令，后记录AOF</a></li><li><a href=#%e4%b8%89%e7%a7%8d%e5%86%99%e5%9b%9e%e7%ad%96%e7%95%a5 aria-label=三种写回策略>三种写回策略</a></li><li><a href=#aof%e9%87%8d%e5%86%99%e6%9c%ba%e5%88%b6 aria-label=AOF重写机制>AOF重写机制</a></li><li><a href=#aof%e5%90%8e%e5%8f%b0%e9%87%8d%e5%86%99 aria-label=AOF后台重写>AOF后台重写</a></li></ul></ul></li><li><a href=#43-rdb%e5%92%8caof%e5%af%b9%e6%af%94 aria-label="4.3 RDB和AOF对比">4.3 RDB和AOF对比</a></li></ul></li><li><a href=#5-%e5%88%86%e5%b8%83%e5%bc%8f%e7%bc%93%e5%ad%98 aria-label="5 分布式缓存">5 分布式缓存</a><ul><li><a href=#51-redis%e4%b8%bb%e4%bb%8e aria-label="5.1 Redis主从">5.1 Redis主从</a></li><li><a href=#52-%e5%93%a8%e5%85%b5 aria-label="5.2 哨兵">5.2 哨兵</a></li><li><a href=#53-redis%e5%88%86%e7%89%87%e9%9b%86%e7%be%a4 aria-label="5.3 Redis分片集群">5.3 Redis分片集群</a></li><li><a href=#54-%e7%bc%93%e5%ad%98%e9%97%ae%e9%a2%98 aria-label="5.4 缓存问题">5.4 缓存问题</a></li><li><a href=#55-%e7%bc%93%e5%ad%98%e9%a2%84%e7%83%ad aria-label="5.5 缓存预热">5.5 缓存预热</a></li></ul></li><li><a href=#6-%e5%86%85%e5%ad%98%e5%9b%9e%e6%94%b6 aria-label="6 内存回收">6 内存回收</a><ul><li><a href=#61-redis%e8%bf%87%e6%9c%9fkey%e5%a4%84%e7%90%86 aria-label="6.1 Redis过期key处理">6.1 Redis过期key处理</a></li><li><a href=#62-redis%e5%86%85%e5%ad%98%e6%b7%98%e6%b1%b0%e7%ad%96%e7%95%a5 aria-label="6.2 Redis内存淘汰策略">6.2 Redis内存淘汰策略</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=redis>Redis<a hidden class=anchor aria-hidden=true href=#redis>#</a></h1><p><a href="https://www.bilibili.com/video/BV1cr4y1671t/?spm_id_from=444.64.search-card.all.click">黑马程序员Redis入门到实战教程</a></p><h1 id=1-基本概念>1 基本概念<a hidden class=anchor aria-hidden=true href=#1-基本概念>#</a></h1><h2 id=11-redisremote-dictionary-server>1.1 Redis（::Re::mote ::Di::ctionary ::S::erver）<a hidden class=anchor aria-hidden=true href=#11-redisremote-dictionary-server>#</a></h2><ul><li>键值型存储，value支持多种不同数据结构。</li><li>单线程，每个命令具备原子性。（6.0之后的多线程仅是在网络处理部分，核心命令执行还是单线程）</li><li>低延迟，速度快（基于内存、IO多路复用、良好的编码）。</li><li>支持数据持久化。</li><li>支持主从集群和分片集群。</li><li>支持多语言客户端。</li></ul><h2 id=12-sql和nosql>1.2 SQL和NoSQL<a hidden class=anchor aria-hidden=true href=#12-sql和nosql>#</a></h2><ul><li>SQL（Structured Query Language）：结构化的、关联的、SQL查询（语法固定）、事务（ACID）</li><li>NoSQL（Not only SQL）：非结构的、非关联的、非SQL的（语法不固定，不统一）、不一定满足事务全部要求（BASE）<ul><li>键值对：Redis</li><li>文档：MongoDB</li><li>图：Neo4j</li><li>列：HBase</li></ul></li></ul><h2 id=13-redis通用命令>1.3 Redis通用命令<a hidden class=anchor aria-hidden=true href=#13-redis通用命令>#</a></h2><pre tabindex=0><code class=language-other data-lang=other>// 1. 列出所有符合条件的key : KEYS [pattern]
KEYS *
KEYS a*
// 2. 删除所有指定的key : DEL key [key ...]
// 3. 判断key是否存在 : EXISTS key [key ...]
// 4. 给一个key设置有效期，过期自动删除 : EXPIRE key seconds
// 5. 查看命令具体用法 : help [command]
// 6. 查看一个key的有效期 : TTL key
</code></pre><h1 id=2-底层数据结构>2 底层数据结构<a hidden class=anchor aria-hidden=true href=#2-底层数据结构>#</a></h1><p>Redis是一个key-value数据库，key一般是String类型，不过value的类型有很多：</p><ul><li>String</li><li>Hash</li><li>List</li><li>Set</li><li>SortedSet（Zset）</li><li>Geo</li><li>BitMap</li><li>HyperLog</li></ul><h2 id=21-动态字符串sds>2.1 动态字符串SDS<a hidden class=anchor aria-hidden=true href=#21-动态字符串sds>#</a></h2><p>Redis中保存的key是字符串，value往往是字符串或者字符串的集合。可见字符串是redis中最常用的一种数据结构。但是redis没有直接使用C语言中的字符串，因为C语言字符串存在很多问题：</p><ul><li>获取字符串长度需要通过运算；</li><li>非二进制安全；</li><li>不可修改。</li></ul><p>Redis构建了一种新的字符串结构，称为简单动态字符串（Simple Dynamic String），简称SDS。</p><p>当执行<code>SET key value</code> 时，会在底层创建两个SDS，其中一个包含key，另一个包含value。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nf>__attribute__</span> <span class=p>((</span><span class=n>__packed__</span><span class=p>))</span> <span class=n>sdshdr8</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* unit8_t 无符号8位整型 */</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 除了sdshdr8之外，redis还定义了5（弃用），16，32，64，支持不同长度的字节 */</span>
</span></span><span class=line><span class=cl>    <span class=n>unit8_t</span> <span class=n>len</span><span class=p>;</span> <span class=cm>/* buf已保存的字符串字节数，不包含结束标识 */</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 最多保存254字节，因为最后一个需要是\0，为了兼容C语言 */</span>
</span></span><span class=line><span class=cl>    <span class=n>unit8_t</span> <span class=n>alloc</span><span class=p>;</span> <span class=cm>/* buf已申请的总的字节数，不包含结束标识 */</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>flags</span><span class=p>;</span> <span class=cm>/* 不同SDS的头类型，用来控制SDS的头大小 */</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>    SDS_TYPE_5  -&gt; 0
</span></span></span><span class=line><span class=cl><span class=cm>    SDS_TYPE_8  -&gt; 1
</span></span></span><span class=line><span class=cl><span class=cm>    SDS_TYPE_16 -&gt; 2
</span></span></span><span class=line><span class=cl><span class=cm>    SDS_TYPE_32 -&gt; 3
</span></span></span><span class=line><span class=cl><span class=cm>    SDS_TYPE_64 -&gt; 4
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>buf</span><span class=p>[];</span> <span class=cm>/* 字符数组 */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/17c48432c956be1f6c333ce1c84cbf71/cb070c5ac6492f46067decbac5cbfb66.png alt=image.png></p><p><strong>SDS之所以叫动态字符串，是因为其具有动态扩容的功能</strong></p><p>当我们需要给SDS追加一段字符串时，首先会申请新内存空间：</p><ul><li>如果新字符串小于1M，则新空间为扩展后的字符串长度的2倍+1；</li><li>如果新字符串大于1M，则新空间为扩展后字符串长度+1M+1。称为<strong>内存预分配</strong>。</li></ul><p><strong>优点：</strong></p><ul><li>获取字符串长度的时间复杂度为O（1）</li><li>支持动态扩容</li><li>减少内存分配次数</li><li>二进制安全</li></ul><h2 id=22-intset>2.2 IntSet<a hidden class=anchor aria-hidden=true href=#22-intset>#</a></h2><ul><li>元素唯一，有序</li><li>具备类型升级机制，可以节省内存空间</li><li>底层采用二分查找方式查询</li></ul><p>IntSet是Redis中set集合的一种实现方式，基于整数数组实现，并具备长度可变，有序等特征。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>intset</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>unit32_t</span> <span class=n>encoding</span><span class=p>;</span> <span class=cm>/* 编码方式，支持存放16位，32位，64位整数 */</span>
</span></span><span class=line><span class=cl>    <span class=n>unit32_t</span> <span class=n>length</span><span class=p>;</span> <span class=cm>/* 元素个数 */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int8_t</span> <span class=n>contents</span><span class=p>[];</span> <span class=cm>/* 整数数组，保存集合数据，仅仅是指针，具体元素类型由encoding指定 */</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=n>intset</span><span class=p>;</span>
</span></span></code></pre></div><p>其中encoding包含三种模式，表示存储的整数大小不同。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define INSET_ENC_INT16 (sizeof(int16_t)) </span><span class=cm>/* 2字节整数，范围类似java中的short */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define INSET_ENC_INT32 (sizeof(int32_t)) </span><span class=cm>/* 4字节整数，范围类似java中的int */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define INSET_ENC_INT64 (sizeof(int64_t)) </span><span class=cm>/* 8字节整数，范围类似java中的long */</span><span class=cp>
</span></span></span></code></pre></div><p>为了方便查找，Redis中将IntSet中所有整数按照升序一次保存在contents数组中。</p><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/17c48432c956be1f6c333ce1c84cbf71/d2cf4d6279cf3539c1f6fa1c2fb1d369.png alt=image.png></p><ul><li>encoding：4字节（unit32_t）。</li><li>length：4字节（unit32_t）。</li><li>contents：2字节（INESET_ENC_INT16）*3 = 6字节。</li></ul><p><strong>IntSet升级</strong></p><p>假设有一个intset，元素为{5, 10, 20}，采用INTSET_ENC_INT16，则每个整数占2字节。</p><blockquote><p>当我们向其中添加一个数字50000时，这个数字超过了int16_t的范围，intset会自动升级编码方式到合适的大小。</p></blockquote><ol><li>升级编码为INTSET_ENC_INT32，每个整数占4字节，按照新的编码方式及元素个数扩容数组。</li><li>倒序一次将数组中元素拷贝到扩容后的正确位置。</li><li>将带添加元素放入数组末尾。<strong>（只可能比所有元素大或者小，否则不会超出编码表示范围）</strong></li><li>最后将intset的encoding属性改为INTSET_ENCINT32，将length属性改为4。</li></ol><blockquote><p>当我们插入的元素在编码表示范围内时，首先进行扩容，然后采用二分查找获取插入下标，然后倒序移动元素腾出位置，插入元素。</p></blockquote><h2 id=23-dict>2.3 Dict<a hidden class=anchor aria-hidden=true href=#23-dict>#</a></h2><p>Dict由三部分组成，分别是哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）。</p><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/17c48432c956be1f6c333ce1c84cbf71/ca6af46a28c9ef6b0c3120584f20bc43.png alt=image.png></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>dict</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>dictType</span> <span class=o>*</span><span class=n>type</span><span class=p>;</span> <span class=c1>// dict类型，内置不同hash函数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=o>*</span><span class=n>privdata</span><span class=p>;</span> <span class=c1>// 私有数据，在做特殊hash运算时使用
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>dictht</span> <span class=n>ht</span><span class=p>[</span><span class=mi>2</span><span class=p>];</span>   <span class=c1>// 一个dict包含两个哈希表，其中一个是当前数据，另一个为空，rehash时使用
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>long</span> <span class=n>rehashidx</span><span class=p>;</span> <span class=c1>// rehash的进度，-1表示未运行。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int16_t</span> <span class=n>pauserehash</span><span class=p>;</span> <span class=c1>// rehash是否暂停，1表示暂停，0表示继续。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=n>dict</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>dictht</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// entry数组
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 数组中保存的是指向entry的指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>dictEntry</span> <span class=o>**</span><span class=n>table</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 哈希表的大小，永远是2的幂次，为了保证与运算可以代替求余。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>usigned</span> <span class=kt>long</span> <span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 哈希表大小的掩码，总等于size-1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>usigned</span> <span class=kt>long</span> <span class=n>sizemask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// entry个数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>usigned</span> <span class=kt>long</span> <span class=n>used</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=n>dictht</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>dictEntry</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>key</span><span class=p>;</span> <span class=c1>//键
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>union</span><span class=p>{</span> <span class=c1>//联合体，可以是其中的一个，但不能同时成立
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>void</span> <span class=o>*</span><span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>unit64_t</span> <span class=n>u64</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int64_t</span> <span class=n>s64</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>double</span> <span class=n>d</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span><span class=n>v</span><span class=p>;</span> <span class=c1>//值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// 下一个Entry的指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=nc>dictEntry</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=n>dictEntry</span><span class=p>;</span>
</span></span></code></pre></div><p>当我们向Dict添加键值对时，Redis首先根据Key计算出hash值（h），然后利用h&amp;sizemask计算元素应该存储到数组中哪个索引位置。</p><p><strong>链地址法解决hash冲突，头插法：</strong></p><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/17c48432c956be1f6c333ce1c84cbf71/8ed47b524480314b6fd98d5085ad09b9.png alt=image.png></p><p><strong>Dict扩容</strong></p><p>hashtable是通过数组组合单向链表实现的，当集合中元素较多时，必然会导致哈希冲突增多，链表过长，则查询效率大大降低。</p><p>Dict在每次新增键值对时，会检查负载因子（LoadFactor = used/size），满足以下两种情况时，会发生<strong>哈希表扩容</strong>。</p><ul><li>哈希表的LoadFactor≥1，并且服务器没有执行BGSAVE或者BGWRITEAOF等后台进程。</li><li>哈希表的LoadFactor>5。</li><li>扩容会保证size为2的n次方。</li></ul><p><strong>Dict的收缩</strong></p><p>Dict在每次删除元素时，会对负载因子做检查，当LoadFactor&lt;0.1时，会做哈希表收缩。</p><p>收缩时也会保证size为2的n次方。</p><p><strong>Dict的rehash</strong></p><p>不管是扩容还是收缩，必定会创建新的哈希表，导致哈希表的size和sizemask变化，而key的查询于sizemask有关。因此必须对hash表中的每一个key重新计算索引，插入新的hash表，这个过程称为rehash。</p><ul><li>计算新hash表的realeSize，值取决于是要扩容还是收缩</li><li>按照i虚拟的realeSize申请内存空间，创建dictht，并赋值给dict.ht[1]。</li><li>设置dict.rehashidx=0，表示开始rehash</li><li><del>将dict.ht[0]中的每一个dictEntry都rehash到dict.ht[1]。</del> 每次执行增删改查时，检查dict.rehashidx是否大于-1，如果是则将dict.ht[0].table[rehashidx]的entry链表rehash到dict.ht[1]，并将rehashidx++。指导dict.ht[0]所有数据都rehash到dict.ht[1]。【<strong>渐进式rehash</strong>】</li><li>将dict.ht[1]赋值给dict.ht[0]，给dict.ht[1]初始化为空哈希表，释放原来的dict.ht[0]的内存。</li><li>将rehashidx赋值为-1，代表rehash结束。</li><li>在rehash过程中，新增操作，则直接写入ht[1]，查询、修改、删除则会在dict.ht[0]和dict.ht[1]一次查找并执行。这样可以确保ht[0]数据只减不增，直到空为止。</li></ul><h2 id=24-ziplist>2.4 ZipList<a hidden class=anchor aria-hidden=true href=#24-ziplist>#</a></h2><p>一种特殊的"双端链表"，由一系列特殊编码的连续内存块组成。可以在任意一端进行压入、弹出操作，并且该操作的时间复杂度为O（1）。</p><p>列表之间节点不是通过指针连接，而是记录上一节点和本节点的长度来寻址，占用内存较低。</p><p>如果列表数据过多，导致链表过长，可能会影响查询性能。</p><p>增或删较大数据时可能会发生连锁更新问题。</p><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/17c48432c956be1f6c333ce1c84cbf71/2790a3c9f21a35ae6f40b6adf6fed50b.png alt=image.png></p><table><thead><tr><th style=text-align:left>属性</th><th style=text-align:left>类型</th><th style=text-align:left>长度</th><th style=text-align:left>用途</th></tr></thead><tbody><tr><td style=text-align:left>zlbytes</td><td style=text-align:left>unit32_t</td><td style=text-align:left>4字节</td><td style=text-align:left>记录整个压缩列表占用的内存字节数</td></tr><tr><td style=text-align:left>zltail</td><td style=text-align:left>unit32_t</td><td style=text-align:left>4字节</td><td style=text-align:left>记录压缩列表尾节点距离压缩列表的起始地址有多少字节，通过这个偏移量可以确定表尾节点的地址。</td></tr><tr><td style=text-align:left>zllen</td><td style=text-align:left>unit16_t</td><td style=text-align:left>2字节</td><td style=text-align:left>记录了压缩列表包含的节点数量。最大为UINT16_MAX（65534），如果超过这个最大值，此处会记录为65535，但节点的真是数量需要遍历整个压缩列表才能计算得出。</td></tr><tr><td style=text-align:left>entry</td><td style=text-align:left>列表节点</td><td style=text-align:left>不定</td><td style=text-align:left>压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</td></tr><tr><td style=text-align:left>zlend</td><td style=text-align:left>unit8_t</td><td style=text-align:left>1字节</td><td style=text-align:left>特殊值0XFF（十进制255），用于标记压缩列表的末端。</td></tr></tbody></table><h3 id=ziplistentry>ZipListEntry<a hidden class=anchor aria-hidden=true href=#ziplistentry>#</a></h3><p>ZipList中的Entry并不像普通链表那样记录前后节点的指针，因为记录两个指针要占用16字节，浪费内存，而是采用了下面的结构。</p><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/17c48432c956be1f6c333ce1c84cbf71/306faf109c2b0fb2897be1042055d0ec.png alt=image.png></p><ul><li>previous_entry_length：前一节点长度，占1个或者5个字节<ul><li>前一节点长度小于254，采用1字节保存长度</li><li>前一节点长度大于254，采用5个字节保存这个长度，第一个字节为0xfe，后面四个字节才是真实的长度。</li></ul></li><li>encoding：编码属性，记录content的数据类型（字符串还是整数）以及长度，占用1个、2个或者5个字节。</li><li>content：负责保存节点的数据，可以是字符串或整数。</li></ul><p>ZipList中所有存储长度的数值均采用<strong>小端字节序</strong>，即低位字节在前，高位字节在后。</p><p>Encoding编码分为字符串和整数两种：</p><ul><li>00、01、10开头，证明是字符串。</li></ul><table><thead><tr><th style=text-align:left>编码</th><th style=text-align:left>编码长度</th><th style=text-align:left>字符串大小</th></tr></thead><tbody><tr><td style=text-align:left></td><td style=text-align:left>00pppppp</td><td style=text-align:left></td></tr><tr><td style=text-align:left></td><td style=text-align:left>01pppppp</td><td style=text-align:left>qqqqqqqq</td></tr><tr><td style=text-align:left></td><td style=text-align:left>1000000000</td><td style=text-align:left>qqqqqqqq</td></tr></tbody></table><ul><li>11开头表示整数</li></ul><table><thead><tr><th style=text-align:left>编码</th><th style=text-align:left>编码长度</th><th style=text-align:left>整数类型</th></tr></thead><tbody><tr><td style=text-align:left>11000000</td><td style=text-align:left>1</td><td style=text-align:left>int16_t(2 bytes)</td></tr><tr><td style=text-align:left>11010000</td><td style=text-align:left>1</td><td style=text-align:left>int32_t(4 bytes)</td></tr><tr><td style=text-align:left>11100000</td><td style=text-align:left>1</td><td style=text-align:left>int64_t(8 bytes)</td></tr><tr><td style=text-align:left>11110000</td><td style=text-align:left>1</td><td style=text-align:left>24位有符号整数(3 bytes)</td></tr><tr><td style=text-align:left>11111110</td><td style=text-align:left>1</td><td style=text-align:left>8位有符号整数(1 byte)</td></tr><tr><td style=text-align:left>1111XXXX</td><td style=text-align:left>1</td><td style=text-align:left>直接在XXXX位置保存数值，范围从0001-1101，减1后结果为实际值。</td></tr></tbody></table><h3 id=ziplist连锁更新问题>ZipList连锁更新问题<a hidden class=anchor aria-hidden=true href=#ziplist连锁更新问题>#</a></h3><p>ZipList的每个Entry都包含previous_entry_length记录前一节点长度，占1个或者5个字节</p><ul><li>前一节点长度小于254，采用1字节保存长度</li><li>前一节点长度大于254，采用5个字节保存这个长度，第一个字节为0xfe，后面四个字节才是真实的长度。</li></ul><p>假设有N个连续的、长度为250-253字节之间的entry，因此entry的previous_entry_length属性用1个字节即可表示。此时，插入一个范围超过254字节的entry，导致其后面所有的entry的previous_entry_length全部都需要改变为5字节。Zip在这种情况下产生的多次空间操作称之为连锁更新。新增、删除都可能导致连锁更新的发生。</p><p>Redis作者并没有解决，这种情况发生概率很低，但是不代表不会发生。</p><h2 id=25-quicklist>2.5 QuickList<a hidden class=anchor aria-hidden=true href=#25-quicklist>#</a></h2><p>问题：ZipList虽然节省内存空间，但申请内存必须是连续的，如果内存占用较多，申请内存效率很低。怎么办？</p><ul><li>限制ZipList长度和Entry大小。</li></ul><p>问题：但是我们要存储大量数据，超过了ZipList最佳上限怎么办？</p><ul><li>创建多个ZipList来分片存储。</li></ul><p>问题：数据拆分后比较分散，不方便管理和查找，这多个ZipList如何建立联系？</p><ul><li>Redis3.2版本后引入了QuickList，它是一个双端链表，只不过每个节点都是一个ZipList。</li></ul><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/17c48432c956be1f6c333ce1c84cbf71/bc6e572040d461f0dca0b1ef73dc373e.png alt=image.png></p><ol><li>为了避免QuickList中每个ZipList中entry过多，Redis提供了一个配置项：list-max-ziplist-size：<ul><li>正数：ZipList允许的Entry个数的最大值。</li><li>负数：ZipList最大内存的大小：<ul><li>-1：不超过4kb。</li><li>-2：不超过8kb。</li><li>-3：不超过16kb。</li><li>-4：不超过32kb。</li><li>-5：不超过64kb。</li><li>默认值为-2。</li></ul></li></ul></li><li>除了控制ZipList大小外，QuickList还可以对节点的ZipList做压缩，通过配置list-compress-depth来控制。因为链表一般都是从首尾访问较多，所以首尾不压缩。这个参数是控制首尾不压缩的节点个数：<ul><li>0： 特殊值，不压缩。</li><li>1：表示首尾各一个不压缩，中间节点压缩。</li><li>2：表示首尾各两个不压缩，中间节点压缩。</li><li>以此类推。</li></ul></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>quicklist</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>quicklistNode</span> <span class=o>*</span><span class=n>head</span><span class=p>;</span> <span class=c1>// 头节点指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>quicklistNode</span> <span class=o>*</span><span class=n>tail</span><span class=p>;</span> <span class=c1>// 尾节点指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>count</span><span class=p>;</span> <span class=c1>// 所有ZipList的entry数量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>len</span><span class=p>;</span>  <span class=c1>// ziplist总数量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=nl>fill</span> <span class=p>:</span> <span class=n>QL_FILL_BITS</span><span class=p>;</span> <span class=c1>// ziplist的entry上限，默认值-2
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nl>compress</span> <span class=p>:</span> <span class=n>QL_COMP_BITS</span><span class=p>;</span> <span class=c1>// 首尾不压缩的节点数量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nl>bookmark_count</span> <span class=p>:</span> <span class=n>QL_BM_BITS</span><span class=p>;</span> <span class=c1>// 内存重新分配时的书签数量及数组，一般用不到
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>quicklistBookmark</span> <span class=n>bookmarks</span><span class=p>[];</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=n>quicklist</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>quicklistNode</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>quicklistNode</span> <span class=o>*</span><span class=n>prev</span><span class=p>;</span> <span class=c1>//前一个节点指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=nc>quicklistNode</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span> <span class=c1>//后一个节点指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>char</span> <span class=o>*</span><span class=n>zl</span><span class=p>;</span> <span class=c1>//当前节点ZipList指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>sz</span><span class=p>;</span> <span class=c1>//当前ZipList的字节大小
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nl>count</span> <span class=p>:</span> <span class=mi>16</span><span class=p>;</span> <span class=c1>//当前ZipList的Entry个数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nl>encoding</span> <span class=p>:</span> <span class=mi>2</span><span class=p>;</span> <span class=c1>// 编码方式：1.ZipList；2.lzf压缩模式
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nl>container</span> <span class=p>:</span> <span class=mi>2</span><span class=p>;</span> <span class=c1>//数据容器类型（预留）：1.其他；2.ZipList
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nl>recompress</span> <span class=p>:</span> <span class=mi>1</span><span class=p>;</span> <span class=c1>//是否被解压缩：1.已经被解压缩，将来要重新压缩
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nl>attempted_compress</span> <span class=p>:</span> <span class=mi>1</span><span class=p>;</span> <span class=c1>//测试使用
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nl>extra</span> <span class=p>:</span> <span class=mi>10</span><span class=p>;</span> <span class=c1>//预留字段
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=n>quicklistNode</span><span class=p>;</span>
</span></span></code></pre></div><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/17c48432c956be1f6c333ce1c84cbf71/6f4a0d9c359a1c89749dafabe344b69f.png alt=image.png></p><h2 id=26-skiplist>2.6 SkipList<a hidden class=anchor aria-hidden=true href=#26-skiplist>#</a></h2><p>SkipList首先是链表，但是与传统链表有几点差异：</p><ul><li>元素按照升序排列存储。</li><li>节点可能包含多个指针，指针跨度不同。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>zskiplist</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>zskiplistNode</span> <span class=o>*</span><span class=n>header</span><span class=p>,</span> <span class=o>*</span><span class=n>tail</span><span class=p>;</span> <span class=c1>// 头尾节点指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>usigned</span> <span class=kt>long</span> <span class=n>length</span><span class=p>;</span> <span class=c1>//节点数量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>level</span><span class=p>;</span> <span class=c1>//最大索引层级，默认是1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=n>zskiplist</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>zskiplistNode</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>sds</span> <span class=n>ele</span><span class=p>;</span> <span class=c1>//节点存储的值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>double</span> <span class=n>score</span><span class=p>;</span> <span class=c1>//节点分数，排序、查找用
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=nc>zskiplistNode</span> <span class=o>*</span><span class=n>backward</span><span class=p>;</span> <span class=c1>//前一个节点的指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=nc>zskiplistLevel</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=nc>zskiplistNode</span> <span class=o>*</span><span class=n>forward</span><span class=p>;</span> <span class=c1>//下一个节点的指针
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>span</span><span class=p>;</span> <span class=c1>//索引跨度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span> <span class=n>level</span><span class=p>[];</span> <span class=c1>// 多级索引数组
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=n>zskiplistNode</span><span class=p>;</span>
</span></span></code></pre></div><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/17c48432c956be1f6c333ce1c84cbf71/e33238314ddb0a59bcb4983a06c2a533.png alt=image.png></p><ul><li>本质是一个双向链表，每个节点都包含score值和ele值</li><li>节点按照score值排序，score值一样按照ele字典排序</li><li>每个节点都可以包含多层指针，层数是1-32之间的随机数</li><li>不同层指针到下一个节点的跨度不同，层级越高，跨度越大</li><li>增删改查效率基本与红黑树一致，实现却更简单</li></ul><h2 id=27-redisobject>2.7 RedisObject<a hidden class=anchor aria-hidden=true href=#27-redisobject>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>redisObject</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=nl>type</span> <span class=p>:</span> <span class=mi>4</span><span class=p>;</span> <span class=c1>// 对应string、hash、list、set、zset，占4个bit位
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=nl>encoding</span> <span class=p>:</span> <span class=mi>4</span><span class=p>;</span> <span class=c1>// 底层编码方式，共有11种，占4个bit位
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=nl>lru</span> <span class=p>:</span> <span class=n>LRU_BITS</span><span class=p>;</span> <span class=c1>// LRU_BTS为24，表示该对象最后一次被访问的时间
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>refcount</span><span class=p>;</span> <span class=c1>//引用计数器，计数器为0则说明对象无人使用，可以被回收，4字节
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=o>*</span><span class=n>ptr</span><span class=p>;</span> <span class=c1>//指向存放实际数据的空间，一般是8字节
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=n>robj</span><span class=p>;</span> <span class=c1>//头部占用16字节
</span></span></span></code></pre></div><p><strong>encoding编码方式</strong></p><table><thead><tr><th style=text-align:left>编号</th><th style=text-align:left>编码方式</th><th style=text-align:left>说明</th></tr></thead><tbody><tr><td style=text-align:left>0</td><td style=text-align:left>OBJ_ENCODING_RAW</td><td style=text-align:left>raw编码动态字符串</td></tr><tr><td style=text-align:left>1</td><td style=text-align:left>OBJ_ENCODING_INT</td><td style=text-align:left>long类型的整数的字符串</td></tr><tr><td style=text-align:left>2</td><td style=text-align:left>OBJ_ENCODING_HT</td><td style=text-align:left>hash表（字典dict）</td></tr><tr><td style=text-align:left>3</td><td style=text-align:left>OBJ_ENCODING_ZIPMAP</td><td style=text-align:left>已废弃</td></tr><tr><td style=text-align:left>4</td><td style=text-align:left>OBJ_ENCODING_LINKEDLIST</td><td style=text-align:left>双端链表</td></tr><tr><td style=text-align:left>5</td><td style=text-align:left>OBJ_ENCODING_ZIPLIST</td><td style=text-align:left>压缩列表</td></tr><tr><td style=text-align:left>6</td><td style=text-align:left>OBJ_ENCODING_INTSET</td><td style=text-align:left>整数集合</td></tr><tr><td style=text-align:left>7</td><td style=text-align:left>OBJ_ENCODING_SKIPLIST</td><td style=text-align:left>跳表</td></tr><tr><td style=text-align:left>8</td><td style=text-align:left>OBJ_ENCODING_EMBSTR</td><td style=text-align:left>embstr的动态字符串</td></tr><tr><td style=text-align:left>9</td><td style=text-align:left>OBJ_ENCODING_QUICKLIST</td><td style=text-align:left>快速列表</td></tr><tr><td style=text-align:left>10</td><td style=text-align:left>OBJ_ENCODING_STREAM</td><td style=text-align:left>Stream流</td></tr></tbody></table><h2 id=28-五种数据结构>2.8 五种数据结构<a hidden class=anchor aria-hidden=true href=#28-五种数据结构>#</a></h2><p><strong>五种数据结构对应的编码方式</strong></p><table><thead><tr><th style=text-align:left>数据类型</th><th style=text-align:left>编码方式</th></tr></thead><tbody><tr><td style=text-align:left>OBJ_STRING</td><td style=text-align:left>int, embstr, raw</td></tr><tr><td style=text-align:left>OBJ_LIST</td><td style=text-align:left>LinkedList和ZipList(3.2之前)，QuickList(3.2之后)</td></tr><tr><td style=text-align:left>OBJ_SET</td><td style=text-align:left>intset、HT</td></tr><tr><td style=text-align:left>OBJ_ZSET</td><td style=text-align:left>ZipList、HT、SkipList</td></tr><tr><td style=text-align:left>OBJ_HASH</td><td style=text-align:left>ZipList、HT</td></tr></tbody></table><h3 id=281-string>2.8.1 String<a hidden class=anchor aria-hidden=true href=#281-string>#</a></h3><ul><li>基本编码方式是RAW，基于简单动态字符串（SDS）实现，存储上限为512MB。</li></ul><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/17c48432c956be1f6c333ce1c84cbf71/68898b591a4a9ab2570dc1fba6bbdbbc.png alt=image.png></p><ul><li>如果存储的SDS长度小于44字节，则会采用EMBSTR编码，此时object head与SDS是一段连续空间，申请内存时只需要调用一次内存分配函数，效率更高。（<strong>不超64字节，分配内存基本单位？</strong>）</li></ul><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/17c48432c956be1f6c333ce1c84cbf71/e556ef234f184b81809af01c6ba7b621.png alt=image.png></p><ul><li>如果存储的字符串是整数值的时候，并且在LONG_MAX范围内，则会采用INT编码：直接将数据保存在RedisObject的ptr指针位置（刚好8字节），不再需要SDS了。</li></ul><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/17c48432c956be1f6c333ce1c84cbf71/43795d9cbe2d971353094bb0a374928b.png alt=image.png></p><h3 id=282-list>2.8.2 List<a hidden class=anchor aria-hidden=true href=#282-list>#</a></h3><ul><li>在3.2版本之前，Redis采用ZipList和LinkedList来实现，当元素数量小于512且元素大小小于64字节时，采用ZipList编码，超过则采用LinkedList。</li><li>在3.2版本之后，Redis同一采用QuickList来实现List。</li></ul><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/17c48432c956be1f6c333ce1c84cbf71/e8c3a5caafeae9f15fefe5db9e271dd0.png alt=image.png></p><h3 id=283-set>2.8.3 Set<a hidden class=anchor aria-hidden=true href=#283-set>#</a></h3><p>Set不保证有序性，保证元素唯一，可以求交集、并集、差集，要求查询效率高。</p><ul><li>为了查询效率和唯一性，set采用HT编码（Dict）。Dict中的key用来存储元素，value统一为null。</li></ul><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/17c48432c956be1f6c333ce1c84cbf71/b966a43e6a410b546b468e33bbdbf0e0.png alt=image.png></p><ul><li>当存储的所有数据都是整数时，并且元素数量不超过set-max-intset-entries时，Set会采用IntSet编码，以节省内存。</li></ul><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/17c48432c956be1f6c333ce1c84cbf71/2bf63faa402bd5e45c28338b990be6db.png alt=image.png></p><h3 id=284-zset>2.8.4 Zset<a hidden class=anchor aria-hidden=true href=#284-zset>#</a></h3><p>每一个元素都需要指定一个score值和member值：</p><ul><li>可以根据score值排序</li><li>member必须唯一</li><li>可以根据member查询分数</li></ul><p>因此底层数据结构必须满足键值存储、键必须唯一、可排序。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>zset</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>dict</span> <span class=o>*</span><span class=n>dict</span><span class=p>;</span> <span class=c1>//dict指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>zskiplist</span> <span class=o>*</span><span class=n>zsl</span><span class=p>;</span> <span class=c1>// SkipList指针
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=n>zset</span><span class=p>;</span>
</span></span></code></pre></div><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/17c48432c956be1f6c333ce1c84cbf71/e66b5ccda9956f169d98974b7b604301.png alt=image.png></p><p>当元素不多时，HT和SkipList的优势并不明显，而且更消耗内存。因此zset还会采用ZipList结构来节省内存，不过需要同时满足两个条件：</p><ul><li>元素数量小于zset_max_ziplist_entries，默认128；</li><li>每个元素都小于zset_max_ziplist_value字节，默认值64。</li></ul><p>ZipList本身没有排序功能，而且没有键值对概念，因此需要由zset通过编码实现：</p><ul><li>ZipList是连续内存，因此score和element是紧挨在一起的两个entry，element在前，score在后。</li><li>score越小越接近队首，score越大越接近队尾，按照score值升序排列。</li></ul><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/17c48432c956be1f6c333ce1c84cbf71/b16ef494ef383ef29f6663dbbae1c7b3.png alt=image.png></p><h3 id=285-hash>2.8.5 Hash<a hidden class=anchor aria-hidden=true href=#285-hash>#</a></h3><p>键必须唯一，根据键获取值。</p><p>底层与Zset基本一致，只不过把排序有关的SkipList去掉即可。</p><ul><li>Hash结构默认采用ZipList编码，用以节省内存。ZipList中相邻的两个entry分别保存filed和value。</li></ul><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/17c48432c956be1f6c333ce1c84cbf71/a36806a973f95855483fdd22b9c55a36.png alt=image.png></p><ul><li>当数据量较大时，Hash结构会转为HT编码，也就是Dict，触发条件需要满足：<ul><li>ZipList中元素的数量超过了hash-max-ziplist-entries（默认512）；</li><li>ZipList中的任意entry大小超过了hash-max-ziplist-value（默认64字节）；</li></ul></li></ul><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/17c48432c956be1f6c333ce1c84cbf71/4d0f51d29cc49c861690503bca11e6f9.png alt=image.png></p><h1 id=3-分布式锁>3 分布式锁<a hidden class=anchor aria-hidden=true href=#3-分布式锁>#</a></h1><p>满足在分布式系统或集群模式下多进程可见并互斥的锁。</p><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/17c48432c956be1f6c333ce1c84cbf71/21400b0dbf8e6280b597320fc376e747.png alt=image.png></p><table><thead><tr><th style=text-align:left></th><th style=text-align:left>MySQL</th><th style=text-align:left>Redis</th><th style=text-align:left>Zookeeper</th></tr></thead><tbody><tr><td style=text-align:left>互斥</td><td style=text-align:left>利用mysql本身的互斥锁机制</td><td style=text-align:left>利用setnx互斥命令</td><td style=text-align:left>利用节点的唯一性和有序性实现互斥</td></tr><tr><td style=text-align:left>高可用</td><td style=text-align:left>好</td><td style=text-align:left>好</td><td style=text-align:left>好</td></tr><tr><td style=text-align:left>高性能</td><td style=text-align:left>一般</td><td style=text-align:left>好</td><td style=text-align:left>一般</td></tr><tr><td style=text-align:left>安全性</td><td style=text-align:left>断开连接，自动释放锁</td><td style=text-align:left>利用锁超时时间，到期释放</td><td style=text-align:left>临时节点，断开连接自动释放</td></tr></tbody></table><h2 id=31-基于redis实现>3.1 基于Redis实现<a hidden class=anchor aria-hidden=true href=#31-基于redis实现>#</a></h2><p>实现分布式锁需要实现两个基本方法：</p><ul><li>获取锁<ul><li>互斥：确保只能有一个线程获取锁 <code>SETNX lock thread1</code> 、<code>EXPIRE lock 10</code> 。<ul><li>两条命令需要时原子性的，所以 <code>SET lock thread NX EX 10</code> 。</li></ul></li><li>非阻塞式：尝试一次，成功返回true，失败返回false</li></ul></li><li>释放锁<ul><li>手动释放：<code>DEL key</code></li><li>超时释放：获取锁时添加一个超时时间。</li></ul></li></ul><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/17c48432c956be1f6c333ce1c84cbf71/e7edd110ff2bd97bc70b0e514d1863ce.png alt=image.png></p><p><strong>存在的问题</strong></p><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/17c48432c956be1f6c333ce1c84cbf71/a49e8179cc45d47c1e4294ca1a720424.png alt=image.png></p><p>由于阻塞，锁提前释放，线程苏醒后释放别人的锁。</p><p>解决方案：获取锁标识，并半段是否一致，避免误删其他线程的锁。</p><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/17c48432c956be1f6c333ce1c84cbf71/df533922d9e1c9758d650948011020c8.png alt=image.png></p><p><strong>还存在的问题</strong></p><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/17c48432c956be1f6c333ce1c84cbf71/06ef02a9b44dbb1095ae0713d2193c96.png alt=image.png></p><p>判断锁标识和释放锁是两个动作，两个动作之间出现阻塞。</p><p>解决方案：保证两个操作的原子性。</p><p>使用Lua脚本，lua脚本在redis中是原子性的。</p><h2 id=32-基于redisson实现>3.2 基于Redisson实现<a hidden class=anchor aria-hidden=true href=#32-基于redisson实现>#</a></h2><p>基于Redis实现存在的问题：</p><ul><li>不可重入，同一个线程无法多次获取同一把锁。</li><li>不可重试，获取锁只尝试一次就返回flase，没有重试机制。</li><li>超时释放，虽然可以避免死锁，但是业务耗时较长，也会导致锁释放，存在安全隐患。</li><li>主从一致性，如果Redis提供了主从集群，主从同步存在延迟，当主节点宕机时，如果从节点同步主节点的所数据，则会出现锁失效。</li></ul><p><strong>Redisson是一个在Redis的基础上实现的Java驻内存数据网格。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</strong></p><h1 id=4-持久化>4 持久化<a hidden class=anchor aria-hidden=true href=#4-持久化>#</a></h1><h2 id=41-rdb持久化>4.1 RDB持久化<a hidden class=anchor aria-hidden=true href=#41-rdb持久化>#</a></h2><p>RDB全程Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。</p><p>快照文件称为RDB文件。默认是保存在当前运行目录。</p><ul><li>save命令：Redis主进程执行RDB，会阻塞所有命令。</li><li>bgsave命令：开启子进程执行RDB，避免主进程受到影响。bgsave开始时回fork主进程得到子进程，子进程共享主进程的内存数据。完成fork（复制页表）后读取内存数据并写入RDB。<ul><li>fork采用的是copy-on-write技术：主进程读操作共享内存，主进程写操作，则会拷贝一份数据，执行写操作。</li></ul></li></ul><p>Redis停机时会自动执行一次RDB。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>### redis.conf 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>#900秒内，如果至少有1个key被修改，则执行bgsave，如果是save &#34;&#34;，则表示禁用RDB 
</span></span><span class=line><span class=cl>save 900 1 
</span></span><span class=line><span class=cl>#指定RDB文件名
</span></span><span class=line><span class=cl>dbfilename dump.rdb
</span></span><span class=line><span class=cl>#文件保存的默认路径
</span></span><span class=line><span class=cl>dir ./
</span></span></code></pre></div><p>Redis的快照是<strong>全量快照</strong>，也就是说每次执行快照持久化，都是把内存中的所有数据记录到磁盘中。</p><p><strong>存在缺点：</strong></p><ul><li>RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险；</li><li>fork子进程、压缩、写出RDB文件都比较耗时。</li></ul><h2 id=42-aof持久化>4.2 AOF持久化<a hidden class=anchor aria-hidden=true href=#42-aof持久化>#</a></h2><p>AOF全称为Append Only File（追加文件）。Redis 每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里。这种保存写操作命令到日志的持久化方式，就是 Redis 里的 <strong>AOF</strong> 持久化功能，<strong>注意只会记录写操作命令，读操作命令是不会被记录的</strong>。</p><p>AOF默认关闭。</p><h4 id=为什么先执行写命令后记录aof>为什么先执行写命令，后记录AOF<a hidden class=anchor aria-hidden=true href=#为什么先执行写命令后记录aof>#</a></h4><p>好处：</p><ul><li>避免额外的检查开销</li><li>不阻塞当前写命令操作</li></ul><p>风险：</p><ul><li>数据有丢失风险</li><li>可能会给【下一个】写命令带来阻塞</li></ul><h4 id=三种写回策略>三种写回策略<a hidden class=anchor aria-hidden=true href=#三种写回策略>#</a></h4><ul><li>always：每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；</li><li>everysec：每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；</li><li>no：不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。</li></ul><table><thead><tr><th style=text-align:left>配置项</th><th style=text-align:left>刷盘时机</th><th style=text-align:left>优点</th><th style=text-align:left>缺点</th></tr></thead><tbody><tr><td style=text-align:left>Always</td><td style=text-align:left>同步刷盘</td><td style=text-align:left>可靠性高，几乎不丢数据</td><td style=text-align:left>性能影响大</td></tr><tr><td style=text-align:left>everysec</td><td style=text-align:left>每秒刷盘</td><td style=text-align:left>性能适中</td><td style=text-align:left>最多丢失1秒数据</td></tr><tr><td style=text-align:left>no</td><td style=text-align:left>操作系统控制</td><td style=text-align:left>性能最好</td><td style=text-align:left>可靠性较差，可能丢失大量数据</td></tr></tbody></table><h4 id=aof重写机制>AOF重写机制<a hidden class=anchor aria-hidden=true href=#aof重写机制>#</a></h4><p>Redis 为了避免 AOF 文件越写越大，提供了 <strong>AOF 重写机制</strong>，当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。</p><p>AOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。</p><p><strong>为什么重写 AOF 的时候，不直接复用现有的 AOF 文件，而是先写到新的 AOF 文件再覆盖过去。</strong></p><p>因为<strong>如果 AOF 重写过程中失败了，现有的 AOF 文件就会造成污染</strong>，可能无法用于恢复使用。</p><h4 id=aof后台重写>AOF后台重写<a hidden class=anchor aria-hidden=true href=#aof后台重写>#</a></h4><p><code>BGREWRITEAOF</code></p><p>重写的过程是由后台子进程完成的，这样可以使得主进程可以继续正常处理命令。</p><p>用 AOF 日志的方式来恢复数据其实是很慢的，因为 Redis 执行命令由单线程负责的，而 AOF 日志恢复数据的方式是顺序执行日志里的每一条命令，如果 AOF 日志很大，这个「重放」的过程就会很慢了。</p><h2 id=43-rdb和aof对比>4.3 RDB和AOF对比<a hidden class=anchor aria-hidden=true href=#43-rdb和aof对比>#</a></h2><table><thead><tr><th style=text-align:left></th><th style=text-align:left>RDB</th><th style=text-align:left>AOF</th></tr></thead><tbody><tr><td style=text-align:left>持久化方式</td><td style=text-align:left>定时对整个内存做快照</td><td style=text-align:left>记录每一次执行的命令</td></tr><tr><td style=text-align:left>数据完整性</td><td style=text-align:left>不完整，两次备份之间会丢失</td><td style=text-align:left>相对完整，取决于刷盘策略</td></tr><tr><td style=text-align:left>文件大小</td><td style=text-align:left>会有压缩，文件体积小</td><td style=text-align:left>记录命令，文件体积很大</td></tr><tr><td style=text-align:left>宕机恢复速度</td><td style=text-align:left>快</td><td style=text-align:left>慢</td></tr><tr><td style=text-align:left>数据恢复优先级</td><td style=text-align:left>低，因为数据完整性不如AOF</td><td style=text-align:left>高，数据完整性更高</td></tr><tr><td style=text-align:left>系统资源占用</td><td style=text-align:left>高，大量CPU和内存消耗</td><td style=text-align:left>低，主要是磁盘IO资源，但是AOF重写时会占用大量CPU和内存资源</td></tr><tr><td style=text-align:left>使用场景</td><td style=text-align:left>可容忍数分钟的数据丢失，追求更快的启动速度</td><td style=text-align:left>对数据安全性要求较高的场景</td></tr></tbody></table><h1 id=5-分布式缓存>5 分布式缓存<a hidden class=anchor aria-hidden=true href=#5-分布式缓存>#</a></h1><h2 id=51-redis主从>5.1 Redis主从<a hidden class=anchor aria-hidden=true href=#51-redis主从>#</a></h2><p>单节点Redis的并发能力有上限，要进一步提高Redis的并发能力，需要搭建主从集群，实现读写分离。</p><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/17c48432c956be1f6c333ce1c84cbf71/e9f5849c88ec05098986c450cc25d76b.png alt=image.png></p><p>在<code>redis.conf</code>文件中配置<code>slaveof &lt;masterIP> &lt;masterPort></code> 。</p><p>常见拓扑结构：</p><ul><li>一主一从</li><li>一主多从</li><li>树状主从</li></ul><p><strong>数据同步原理</strong></p><p>主从第一次同步是<strong>全量同步</strong>。</p><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/17c48432c956be1f6c333ce1c84cbf71/e27773759dffd441cd2c1761207e9acd.png alt=image.png></p><p>如果slave重启后同步，则执行<strong>增量同步</strong>。</p><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/17c48432c956be1f6c333ce1c84cbf71/68b533adf935a8ac4c46ceaac69f0f6c.png alt=image.png></p><ul><li>repl_baklog大小有上限，写满后会覆盖最早的数据。如果slave断开时间过久，导致数据被覆盖，则无法实现增量同步，只能再次进行全量同步。</li></ul><p><strong>优化主从集群</strong></p><ul><li>在master中配置repl-diskless-sync yes启用无磁盘复制，避免全量同步时的磁盘IO。</li><li>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO。</li><li>适当提高repl_baklog的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步。</li><li>限制一个master上的slave节点数量，如果slave太多，可以采用主-从-从链式结构，减少master压力。</li></ul><h2 id=52-哨兵>5.2 哨兵<a hidden class=anchor aria-hidden=true href=#52-哨兵>#</a></h2><p>slave宕机恢复后，可以找master节点同步数据，那master节点宕机后怎么办？</p><p>Redis提供了**哨兵（Sentinel）**机制来实现主从集群的自动故障恢复。</p><ul><li>监控：Sentinel会不断检查master和slave是否按预期工作。</li><li>自动故障恢复： 如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主。</li><li>通知：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新消息推送给Redis客户端。</li></ul><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/17c48432c956be1f6c333ce1c84cbf71/715258dfe989bd761327beefa928c872.png alt=image.png></p><p>Sentinel基于心跳机制检测服务状态，每隔1秒向集群的每个实例发送ping命令：</p><ul><li>主观下线：如果某个sentinel节点发现某个实例未在规定时间响应，则认为该实例<strong>主观下线</strong>。</li><li>客观下线：如果超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例<strong>客观下线</strong>。quorum值最好超过Sentinel实例数量的一半。</li></ul><p><strong>选举</strong></p><p>一旦发现master故障，sentinel需要在slave中选择一个作为新的master：</p><ul><li>首先判断slave节点与master节点断开时间长短，如果超过指定值（down-after-millseconds*10）则会排除该slave节点。</li><li>然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永远不参与选举。</li><li>如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高。</li><li>最后是判断slave节点的运行id大小，越小优先级越高。</li></ul><p><strong>故障转移过程</strong></p><ol><li>选取slave为master</li><li>sentinel向备选节点发送<code>slaveof no one</code> 使得该节点成为主节点</li><li>sentinel向其他所有slave发送<code>slaveof &lt;newMasterIP> &lt;newMasterPort></code></li><li>将故障节点标记为slave</li></ol><p><strong>RedisTemplate的哨兵模式</strong></p><ol><li>在posm中引入redis的starter依赖</li><li>在Application.yml中指定sentinel集群相关信息</li><li>配置主存读写分离</li></ol><h2 id=53-redis分片集群>5.3 Redis分片集群<a hidden class=anchor aria-hidden=true href=#53-redis分片集群>#</a></h2><p>主从和哨兵可以解决高可用、高并发读的问题。但是无法解决海量数据存储和高并发写的问题。</p><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/17c48432c956be1f6c333ce1c84cbf71/5fabe57981ffb38e37f1ef8bf5bb1896.png alt=image.png></p><p>使用分片集群可以解决上述问题，其特点有：</p><ul><li>集群中有多个master，每个master保存不同数据。</li><li>每个master都可以有多个slave节点。</li><li>master之间通过ping检测彼此健康状态。（不需要哨兵）</li><li>客户端请求可以访问集群任意节点，最终都会被转发到正确节点。</li></ul><p><strong>Redis分区策略：</strong></p><ul><li>哈希取余分区：简单，平均，不利于扩容或收缩。</li><li>一致性哈希算法分区：扩展性得到保证，但是数据会有倾斜问题。</li><li>哈希插槽分区：Redis集群内置16384（0-16383）个哈希槽，redis会根据节点数量大致均等的将哈希槽映射到不同节点。数据到来时，根据key使用<strong>CRC16</strong>算法算出结果后对16384取余，映射到哈希槽。槽用来扩大数据粒度，便于移动，哈希解决映射问题。<ul><li>key中包含{}，并且{}中至少包含1个字符，redis根据{}中的部分计算插槽值。</li><li>key中不包含{}，整个key都被用来计算插槽值。</li></ul></li></ul><p><strong>分片集群下的自动故障转移</strong></p><ol><li>master实例与其他实例失去连接。</li><li>进入疑似宕机状态。</li><li>确认下线，自动提升一个slave为master。</li></ol><p><strong>分片集群下手动故障转移（用于无感知机器升级）</strong></p><p>利用<code>cluster failover</code> 命令手动使得集群中某个master宕机，切换到执行该命令的slave节点，实现无感知的数据迁移。</p><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/17c48432c956be1f6c333ce1c84cbf71/a16d6384628049738d4e57276081b2ba.png alt=image.png></p><p>手动Failover支持的三种模式：</p><ul><li>缺省：默认图中流程。</li><li>force：省略对offset的一致性校验。</li><li>takeover：直接执行第五步，忽略一致性、master状态和其他master意见。</li></ul><p><strong>RedisTemplate分片集群</strong></p><ol><li>引入redis的starter依赖</li><li>配置分片集群地址</li><li>配置读写分离</li></ol><h2 id=54-缓存问题>5.4 缓存问题<a hidden class=anchor aria-hidden=true href=#54-缓存问题>#</a></h2><ul><li>缓存穿透：key对应数据在数据源不存在<ul><li>解决方案：<ul><li>缓存空对象，数据库没找到，在redis缓存null，有额外内存消耗。</li><li>布隆过滤器，可能会有误判。</li></ul></li></ul></li><li>缓存击穿：key对应数据在数据源存在，但是过期<ul><li>解决方案：<ul><li>互斥锁：无额外内存消耗，保证一致性，线程需要等待，可能死锁。</li><li>逻辑过期：线程无需等待，不保证一致性，有额外内存消耗。</li></ul></li></ul></li><li>缓存雪崩：大量缓存失效，服务器宕机、缓存集中失效<ul><li>解决方案：<ul><li>提高可用性</li><li>均匀过期+热点数据永不过期</li><li>熔断降级</li><li>添加多级缓存</li></ul></li></ul></li></ul><h2 id=55-缓存预热>5.5 缓存预热<a hidden class=anchor aria-hidden=true href=#55-缓存预热>#</a></h2><ul><li>预留接口手动预热</li><li>项目启动设置自动预热</li><li>定时任务刷新缓存</li></ul><h1 id=6-内存回收>6 内存回收<a hidden class=anchor aria-hidden=true href=#6-内存回收>#</a></h1><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>redisDb</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>dict</span> <span class=o>*</span><span class=n>dict</span><span class=p>;</span> <span class=c1>//存放所有key及value的地方，也称为keyspace
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>dict</span> <span class=o>*</span><span class=n>expires</span><span class=p>;</span> <span class=c1>//存放每一个key及其对应的TTL存活时间，只包含设置了TTL的key
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>dict</span> <span class=o>*</span><span class=n>blocking_keys</span><span class=p>;</span> <span class=c1>//Keys with clients waiting for data
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>dict</span> <span class=o>*</span><span class=n>ready_keys</span><span class=p>;</span> <span class=c1>//blocked keys that received a push
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>dict</span> <span class=o>*</span><span class=n>watched_keys</span><span class=p>;</span> <span class=c1>//watched keys for multi/exec cas
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>id</span><span class=p>;</span> <span class=c1>//database ID， 0-15
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>long</span> <span class=kt>long</span> <span class=n>avg_ttl</span><span class=p>;</span> <span class=c1>//记录平均TTL时长
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>expires_cursor</span><span class=p>;</span> <span class=c1>//expire检查时在dict中抽样索引的位置
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>list</span> <span class=o>*</span><span class=n>defrag_later</span><span class=p>;</span> <span class=c1>//等待碎片整理的key列表
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=n>redisDb</span><span class=p>;</span>
</span></span></code></pre></div><h2 id=61-redis过期key处理>6.1 Redis过期key处理<a hidden class=anchor aria-hidden=true href=#61-redis过期key处理>#</a></h2><ul><li>惰性删除：访问一个key时，检查该key的存活时间，如果已经过期才执行删除。</li><li>周期删除：通过定时任务，周期性抽样部分过期的key，然后执行删除。<ul><li>Redis设置一个定时任务serverCron()，按照server.hz的频率来执行过期key清理，模式为SLOW。<ul><li>执行频率受server.hz影响，默认为10，即每秒执行10次。</li><li>执行清理耗时不超过一次执行周期的25%。</li><li>逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期。</li><li>没达到时间上限25ms，并且过期key比例大于10%（<strong>5个？</strong>），再进行一次抽样，否则结束。</li></ul></li><li>Redis的每个事件循环前会调用beforeSleep()函数，执行过期key清理，模式为FAST。<ul><li>执行频率受beforeSleep()调用频率影响，但两次FAST模式间隔不低于2ms。</li><li>执行清理耗时不超过1ms。</li><li>逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期。</li><li>没达到时间上限1ms，并且过期key比例大于10%，在进行一次抽样，否则结束。</li></ul></li></ul></li></ul><h2 id=62-redis内存淘汰策略>6.2 Redis内存淘汰策略<a hidden class=anchor aria-hidden=true href=#62-redis内存淘汰策略>#</a></h2><p>当Redis内存使用达到设置的阈值时，Redis主动挑选<strong>部分Key</strong>删除，以释放内存。</p><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/17c48432c956be1f6c333ce1c84cbf71/c84d5d0b9ddeead2d6e4478dd8992ff0.png alt=image.png></p><p><strong>八种淘汰策略：</strong></p><ul><li>noeviction：不淘汰任何key，内存满时不允许写入新数据，<strong>默认策略</strong></li><li>volatile-ttl：对设置了TTL的key，比较剩余TTL可以，TTL越小越先被淘汰。</li><li>allkeys-random：对全体Key，随机进行淘汰。即在db→dict中随机挑选。</li><li>volatile-random：对设置了TTL的key，随即进行淘汰，即在db→expires中随机挑选。</li><li>allkeys-lru：对全体key基于LRU算法进行淘汰。</li><li>volatile-lru：对设置了TTL的key基于LRU算法进行淘汰。</li><li>allkeys-lfu：对全体key基于LFU算法进行淘汰。</li><li>volatile-lfu：对设置了TTL的key基于LFU算法进行淘汰。</li></ul><p>LRU(Least Recently Used)，最少最近使用。当前时间减去最后一次访问时间，值越大，淘汰优先级越高。</p><p>LFU(Least Frequently Used)，最少频率使用。访问频率低的淘汰优先级高。</p><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/17c48432c956be1f6c333ce1c84cbf71/659e74671f666ddcc6a816319b2b4d10.png alt=image.png></p><p>逻辑访问次数通过一定算法计算得出，并且会根据上一次访问时间衰减。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://roaraeonliou.github.io/tags/%E7%AC%94%E8%AE%B0/>笔记</a></li><li><a href=https://roaraeonliou.github.io/tags/redis/>Redis</a></li><li><a href=https://roaraeonliou.github.io/tags/nosql/>NoSQL</a></li><li><a href=https://roaraeonliou.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a></li></ul><nav class=paginav><a class=prev href=https://roaraeonliou.github.io/posts/interviewnotes/database/nosql/nosql/><span class=title>« Prev</span><br><span>NoSQL</span>
</a><a class=next href=https://roaraeonliou.github.io/posts/interviewnotes/redis/redis%E8%A1%A5%E5%85%85/><span class=title>Next »</span><br><span>Redis补充</span></a></nav></footer><div id=comments><script src=https://giscus.app/client.js data-repo=RoaraeonLiou/roaraeonliou.github.io data-repo-id=R_kgDOMIxQ4w data-category=Announcements data-category-id=DIC_kwDOMIxQ484CgZUR data-mapping=title data-strict=1 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2024 <a href=https://roaraeonliou.github.io/>RLTEA BLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>