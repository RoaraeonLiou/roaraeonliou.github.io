<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>消息队列RabbitMQ | RLTEA BLOG</title>
<meta name=keywords content><meta name=description content="消息队列RabbitMQ
消息队列是一种消息中间件，不负责处理消息，仅负责消息的接受存储和转发.
RabbitMQ特点：

**消息传递模式：**支持多种消息传递模式，包括发布订阅、点对点和工作队列等。
**消息路由和交换机：**RabbitMQ引入了交换机（Exchange）概念，用于将消息路由到一个或者多个队列。允许根据消息内容、标签或者路由键进行灵活的消息路由。
**消息确认机制：**RabbitMQ支持消息确认机制，保证消息不会被重复消费。
**可扩展性：**RabbitMQ可以通过添加更多的节点和集群来增加吞吐量和可用性。
支持多种编程语言。
**消息持久性：**Rabbit允许消息和队列进行持久化设置，确保消息在RabbitMQ重启后不会丢失。
**灵活的插件系统：**RabbitMQ具有丰富的插件系统，可以拓展多种功能。
具有易于管理的Web界面。

为什么要使用消息队列

流量削峰：队列缓存请求
应用解耦
异步处理

1 AMQP
AMQP（Advanced Message Queuing Protocol）不是一个具体的消息中间件产品，而是一个协议规范，一种为面向消息的中间件设计的应用层协议。AMQP提供了一种统一的消息服务，是的不同程序之间可以通过消息队列进行通信。SpringBoot框架默认就提供了对AMQP协议的支持。
AMQP 本质上是一个开放的标准，他不光可以被 RabbitMQ 实现，也可以被其他产品实现。通过这种标准的协议，实际上是可以在不同的消息中间件系统之间进行灵活的消息传递。只不过，目前具体实现这种标准的产品目前并不多，RabbitMQ 则是最有影响力的一个产品。因此，RabbitMQ 成了 AMQP 协议事实上的代表。SpringBoot 框架默认提供的 AMQP 协议支持底层也是基于 RabbitMQ 产品实现的。
AMQP 协议的三层：

Module Layer:协议最高层，主要定义了一些客户端调用的命令，客户端可以用这些命令实现自己的业务逻辑。
Session Layer:中间层，主要负责客户端命令发送给服务器，再将服务端应答返回客户端，提供可靠性同步机制和错误处理。
TransportLayer:最底层，主要传输二进制数据流，提供帧的处理、信道复用、错误检测和数据表示等。

AMQP 模型的三大组件：

交换器 (Exchange)：消息代理服务器中用于把消息路由到队列的组件。
队列 (Queue)：用来存储消息的数据结构，位于硬盘或内存中。
绑定 (Binding)：一套规则，告知交换器消息应该将消息投递给哪个队列。

2 RabbitMQ各组件及其功能



**Broker：**RabbitMQ服务器，接受客户端连接，实现AMQP实体服务
**Virtual Host：**虚拟主机，实现逻辑隔离，用于隔离不同环境或不同应用的消息流。每个虚拟主机都有自己的Exchange和Queue。
**Connection：**连接，管理和维护RabbitMQ服务器的TCP链接，生产者和消费者通过这个连接与Broker建立物理网络连接（RabbitMQ消息基于TCP进行传输）。
**Channel：**信道，是在Connection中创建的轻量级通道，客户端可以建立多个信道，可以减小建立TCP Connection的开销，信道数量没有限制。
**Exchange：**交换机，负责接受来自生产者的消息，并将其路由到一个或多个队列。有direct、topic、fanout、headers四种模式。
**Queue：**队列是消息的存储位置，每个队列都有唯一的名称。
**Binding：**绑定，是Exchange和Queue之间的关联规则，定义了消息如何从交换机路由到特定队列。

此外生产者和消费者也是消息队列中的核心组件，生产者负责发送消息到Exchange或者Queue，消费者负责从Queue中订阅和处理消息。

生产者：生产者是消息的发送方，负责产生并发送消息到 RabbitMQ。生产者通常将消息发送到交换机（Exchange）。
消费者：消费者是消息的接收方，负责从队列中获取消息并进行处理。消费者通过订阅队列来接收消息。
消息：消息是生产者和消费者之间传递的数据单元。消息通常包含消息体和可选的属性，如路由键等。

3 RabbitMQ中交换机类型

Direct Exchange：根据消息的路由键（Routing Key）将消息发送到与之完全匹配的队列。


"><meta name=author content="RLTEA"><link rel=canonical href=https://roaraeonliou.github.io/posts/interviewnotes/messagequeue/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97rabbitmq/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.258803b0f0cc9a4a109c6fe78a9d39f2e0437217d71c5c9848255af9250f2b1b.css integrity="sha256-JYgDsPDMmkoQnG/nip058uBDchfXHFyYSCVa+SUPKxs=" rel="preload stylesheet" as=style><link rel=icon href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://roaraeonliou.github.io/posts/interviewnotes/messagequeue/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97rabbitmq/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="消息队列RabbitMQ"><meta property="og:description" content="消息队列RabbitMQ
消息队列是一种消息中间件，不负责处理消息，仅负责消息的接受存储和转发.
RabbitMQ特点：

**消息传递模式：**支持多种消息传递模式，包括发布订阅、点对点和工作队列等。
**消息路由和交换机：**RabbitMQ引入了交换机（Exchange）概念，用于将消息路由到一个或者多个队列。允许根据消息内容、标签或者路由键进行灵活的消息路由。
**消息确认机制：**RabbitMQ支持消息确认机制，保证消息不会被重复消费。
**可扩展性：**RabbitMQ可以通过添加更多的节点和集群来增加吞吐量和可用性。
支持多种编程语言。
**消息持久性：**Rabbit允许消息和队列进行持久化设置，确保消息在RabbitMQ重启后不会丢失。
**灵活的插件系统：**RabbitMQ具有丰富的插件系统，可以拓展多种功能。
具有易于管理的Web界面。

为什么要使用消息队列

流量削峰：队列缓存请求
应用解耦
异步处理

1 AMQP
AMQP（Advanced Message Queuing Protocol）不是一个具体的消息中间件产品，而是一个协议规范，一种为面向消息的中间件设计的应用层协议。AMQP提供了一种统一的消息服务，是的不同程序之间可以通过消息队列进行通信。SpringBoot框架默认就提供了对AMQP协议的支持。
AMQP 本质上是一个开放的标准，他不光可以被 RabbitMQ 实现，也可以被其他产品实现。通过这种标准的协议，实际上是可以在不同的消息中间件系统之间进行灵活的消息传递。只不过，目前具体实现这种标准的产品目前并不多，RabbitMQ 则是最有影响力的一个产品。因此，RabbitMQ 成了 AMQP 协议事实上的代表。SpringBoot 框架默认提供的 AMQP 协议支持底层也是基于 RabbitMQ 产品实现的。
AMQP 协议的三层：

Module Layer:协议最高层，主要定义了一些客户端调用的命令，客户端可以用这些命令实现自己的业务逻辑。
Session Layer:中间层，主要负责客户端命令发送给服务器，再将服务端应答返回客户端，提供可靠性同步机制和错误处理。
TransportLayer:最底层，主要传输二进制数据流，提供帧的处理、信道复用、错误检测和数据表示等。

AMQP 模型的三大组件：

交换器 (Exchange)：消息代理服务器中用于把消息路由到队列的组件。
队列 (Queue)：用来存储消息的数据结构，位于硬盘或内存中。
绑定 (Binding)：一套规则，告知交换器消息应该将消息投递给哪个队列。

2 RabbitMQ各组件及其功能



**Broker：**RabbitMQ服务器，接受客户端连接，实现AMQP实体服务
**Virtual Host：**虚拟主机，实现逻辑隔离，用于隔离不同环境或不同应用的消息流。每个虚拟主机都有自己的Exchange和Queue。
**Connection：**连接，管理和维护RabbitMQ服务器的TCP链接，生产者和消费者通过这个连接与Broker建立物理网络连接（RabbitMQ消息基于TCP进行传输）。
**Channel：**信道，是在Connection中创建的轻量级通道，客户端可以建立多个信道，可以减小建立TCP Connection的开销，信道数量没有限制。
**Exchange：**交换机，负责接受来自生产者的消息，并将其路由到一个或多个队列。有direct、topic、fanout、headers四种模式。
**Queue：**队列是消息的存储位置，每个队列都有唯一的名称。
**Binding：**绑定，是Exchange和Queue之间的关联规则，定义了消息如何从交换机路由到特定队列。

此外生产者和消费者也是消息队列中的核心组件，生产者负责发送消息到Exchange或者Queue，消费者负责从Queue中订阅和处理消息。

生产者：生产者是消息的发送方，负责产生并发送消息到 RabbitMQ。生产者通常将消息发送到交换机（Exchange）。
消费者：消费者是消息的接收方，负责从队列中获取消息并进行处理。消费者通过订阅队列来接收消息。
消息：消息是生产者和消费者之间传递的数据单元。消息通常包含消息体和可选的属性，如路由键等。

3 RabbitMQ中交换机类型

Direct Exchange：根据消息的路由键（Routing Key）将消息发送到与之完全匹配的队列。


"><meta property="og:type" content="article"><meta property="og:url" content="https://roaraeonliou.github.io/posts/interviewnotes/messagequeue/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97rabbitmq/"><meta property="og:image" content="https://roaraeonliou.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-26T00:00:00+00:00"><meta property="article:modified_time" content="2024-09-26T00:00:00+00:00"><meta property="og:site_name" content="RLTEA BLOG"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://roaraeonliou.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="消息队列RabbitMQ"><meta name=twitter:description content="消息队列RabbitMQ
消息队列是一种消息中间件，不负责处理消息，仅负责消息的接受存储和转发.
RabbitMQ特点：

**消息传递模式：**支持多种消息传递模式，包括发布订阅、点对点和工作队列等。
**消息路由和交换机：**RabbitMQ引入了交换机（Exchange）概念，用于将消息路由到一个或者多个队列。允许根据消息内容、标签或者路由键进行灵活的消息路由。
**消息确认机制：**RabbitMQ支持消息确认机制，保证消息不会被重复消费。
**可扩展性：**RabbitMQ可以通过添加更多的节点和集群来增加吞吐量和可用性。
支持多种编程语言。
**消息持久性：**Rabbit允许消息和队列进行持久化设置，确保消息在RabbitMQ重启后不会丢失。
**灵活的插件系统：**RabbitMQ具有丰富的插件系统，可以拓展多种功能。
具有易于管理的Web界面。

为什么要使用消息队列

流量削峰：队列缓存请求
应用解耦
异步处理

1 AMQP
AMQP（Advanced Message Queuing Protocol）不是一个具体的消息中间件产品，而是一个协议规范，一种为面向消息的中间件设计的应用层协议。AMQP提供了一种统一的消息服务，是的不同程序之间可以通过消息队列进行通信。SpringBoot框架默认就提供了对AMQP协议的支持。
AMQP 本质上是一个开放的标准，他不光可以被 RabbitMQ 实现，也可以被其他产品实现。通过这种标准的协议，实际上是可以在不同的消息中间件系统之间进行灵活的消息传递。只不过，目前具体实现这种标准的产品目前并不多，RabbitMQ 则是最有影响力的一个产品。因此，RabbitMQ 成了 AMQP 协议事实上的代表。SpringBoot 框架默认提供的 AMQP 协议支持底层也是基于 RabbitMQ 产品实现的。
AMQP 协议的三层：

Module Layer:协议最高层，主要定义了一些客户端调用的命令，客户端可以用这些命令实现自己的业务逻辑。
Session Layer:中间层，主要负责客户端命令发送给服务器，再将服务端应答返回客户端，提供可靠性同步机制和错误处理。
TransportLayer:最底层，主要传输二进制数据流，提供帧的处理、信道复用、错误检测和数据表示等。

AMQP 模型的三大组件：

交换器 (Exchange)：消息代理服务器中用于把消息路由到队列的组件。
队列 (Queue)：用来存储消息的数据结构，位于硬盘或内存中。
绑定 (Binding)：一套规则，告知交换器消息应该将消息投递给哪个队列。

2 RabbitMQ各组件及其功能



**Broker：**RabbitMQ服务器，接受客户端连接，实现AMQP实体服务
**Virtual Host：**虚拟主机，实现逻辑隔离，用于隔离不同环境或不同应用的消息流。每个虚拟主机都有自己的Exchange和Queue。
**Connection：**连接，管理和维护RabbitMQ服务器的TCP链接，生产者和消费者通过这个连接与Broker建立物理网络连接（RabbitMQ消息基于TCP进行传输）。
**Channel：**信道，是在Connection中创建的轻量级通道，客户端可以建立多个信道，可以减小建立TCP Connection的开销，信道数量没有限制。
**Exchange：**交换机，负责接受来自生产者的消息，并将其路由到一个或多个队列。有direct、topic、fanout、headers四种模式。
**Queue：**队列是消息的存储位置，每个队列都有唯一的名称。
**Binding：**绑定，是Exchange和Queue之间的关联规则，定义了消息如何从交换机路由到特定队列。

此外生产者和消费者也是消息队列中的核心组件，生产者负责发送消息到Exchange或者Queue，消费者负责从Queue中订阅和处理消息。

生产者：生产者是消息的发送方，负责产生并发送消息到 RabbitMQ。生产者通常将消息发送到交换机（Exchange）。
消费者：消费者是消息的接收方，负责从队列中获取消息并进行处理。消费者通过订阅队列来接收消息。
消息：消息是生产者和消费者之间传递的数据单元。消息通常包含消息体和可选的属性，如路由键等。

3 RabbitMQ中交换机类型

Direct Exchange：根据消息的路由键（Routing Key）将消息发送到与之完全匹配的队列。


"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://roaraeonliou.github.io/posts/"},{"@type":"ListItem","position":2,"name":"消息队列RabbitMQ","item":"https://roaraeonliou.github.io/posts/interviewnotes/messagequeue/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97rabbitmq/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"消息队列RabbitMQ","name":"消息队列RabbitMQ","description":"消息队列RabbitMQ 消息队列是一种消息中间件，不负责处理消息，仅负责消息的接受存储和转发.\nRabbitMQ特点：\n**消息传递模式：**支持多种消息传递模式，包括发布订阅、点对点和工作队列等。 **消息路由和交换机：**RabbitMQ引入了交换机（Exchange）概念，用于将消息路由到一个或者多个队列。允许根据消息内容、标签或者路由键进行灵活的消息路由。 **消息确认机制：**RabbitMQ支持消息确认机制，保证消息不会被重复消费。 **可扩展性：**RabbitMQ可以通过添加更多的节点和集群来增加吞吐量和可用性。 支持多种编程语言。 **消息持久性：**Rabbit允许消息和队列进行持久化设置，确保消息在RabbitMQ重启后不会丢失。 **灵活的插件系统：**RabbitMQ具有丰富的插件系统，可以拓展多种功能。 具有易于管理的Web界面。 为什么要使用消息队列\n流量削峰：队列缓存请求 应用解耦 异步处理 1 AMQP AMQP（Advanced Message Queuing Protocol）不是一个具体的消息中间件产品，而是一个协议规范，一种为面向消息的中间件设计的应用层协议。AMQP提供了一种统一的消息服务，是的不同程序之间可以通过消息队列进行通信。SpringBoot框架默认就提供了对AMQP协议的支持。\nAMQP 本质上是一个开放的标准，他不光可以被 RabbitMQ 实现，也可以被其他产品实现。通过这种标准的协议，实际上是可以在不同的消息中间件系统之间进行灵活的消息传递。只不过，目前具体实现这种标准的产品目前并不多，RabbitMQ 则是最有影响力的一个产品。因此，RabbitMQ 成了 AMQP 协议事实上的代表。SpringBoot 框架默认提供的 AMQP 协议支持底层也是基于 RabbitMQ 产品实现的。\nAMQP 协议的三层：\nModule Layer:协议最高层，主要定义了一些客户端调用的命令，客户端可以用这些命令实现自己的业务逻辑。 Session Layer:中间层，主要负责客户端命令发送给服务器，再将服务端应答返回客户端，提供可靠性同步机制和错误处理。 TransportLayer:最底层，主要传输二进制数据流，提供帧的处理、信道复用、错误检测和数据表示等。 AMQP 模型的三大组件：\n交换器 (Exchange)：消息代理服务器中用于把消息路由到队列的组件。 队列 (Queue)：用来存储消息的数据结构，位于硬盘或内存中。 绑定 (Binding)：一套规则，告知交换器消息应该将消息投递给哪个队列。 2 RabbitMQ各组件及其功能 **Broker：**RabbitMQ服务器，接受客户端连接，实现AMQP实体服务 **Virtual Host：**虚拟主机，实现逻辑隔离，用于隔离不同环境或不同应用的消息流。每个虚拟主机都有自己的Exchange和Queue。 **Connection：**连接，管理和维护RabbitMQ服务器的TCP链接，生产者和消费者通过这个连接与Broker建立物理网络连接（RabbitMQ消息基于TCP进行传输）。 **Channel：**信道，是在Connection中创建的轻量级通道，客户端可以建立多个信道，可以减小建立TCP Connection的开销，信道数量没有限制。 **Exchange：**交换机，负责接受来自生产者的消息，并将其路由到一个或多个队列。有direct、topic、fanout、headers四种模式。 **Queue：**队列是消息的存储位置，每个队列都有唯一的名称。 **Binding：**绑定，是Exchange和Queue之间的关联规则，定义了消息如何从交换机路由到特定队列。 此外生产者和消费者也是消息队列中的核心组件，生产者负责发送消息到Exchange或者Queue，消费者负责从Queue中订阅和处理消息。\n生产者：生产者是消息的发送方，负责产生并发送消息到 RabbitMQ。生产者通常将消息发送到交换机（Exchange）。 消费者：消费者是消息的接收方，负责从队列中获取消息并进行处理。消费者通过订阅队列来接收消息。 消息：消息是生产者和消费者之间传递的数据单元。消息通常包含消息体和可选的属性，如路由键等。 3 RabbitMQ中交换机类型 Direct Exchange：根据消息的路由键（Routing Key）将消息发送到与之完全匹配的队列。 ","keywords":[],"articleBody":"消息队列RabbitMQ 消息队列是一种消息中间件，不负责处理消息，仅负责消息的接受存储和转发.\nRabbitMQ特点：\n**消息传递模式：**支持多种消息传递模式，包括发布订阅、点对点和工作队列等。 **消息路由和交换机：**RabbitMQ引入了交换机（Exchange）概念，用于将消息路由到一个或者多个队列。允许根据消息内容、标签或者路由键进行灵活的消息路由。 **消息确认机制：**RabbitMQ支持消息确认机制，保证消息不会被重复消费。 **可扩展性：**RabbitMQ可以通过添加更多的节点和集群来增加吞吐量和可用性。 支持多种编程语言。 **消息持久性：**Rabbit允许消息和队列进行持久化设置，确保消息在RabbitMQ重启后不会丢失。 **灵活的插件系统：**RabbitMQ具有丰富的插件系统，可以拓展多种功能。 具有易于管理的Web界面。 为什么要使用消息队列\n流量削峰：队列缓存请求 应用解耦 异步处理 1 AMQP AMQP（Advanced Message Queuing Protocol）不是一个具体的消息中间件产品，而是一个协议规范，一种为面向消息的中间件设计的应用层协议。AMQP提供了一种统一的消息服务，是的不同程序之间可以通过消息队列进行通信。SpringBoot框架默认就提供了对AMQP协议的支持。\nAMQP 本质上是一个开放的标准，他不光可以被 RabbitMQ 实现，也可以被其他产品实现。通过这种标准的协议，实际上是可以在不同的消息中间件系统之间进行灵活的消息传递。只不过，目前具体实现这种标准的产品目前并不多，RabbitMQ 则是最有影响力的一个产品。因此，RabbitMQ 成了 AMQP 协议事实上的代表。SpringBoot 框架默认提供的 AMQP 协议支持底层也是基于 RabbitMQ 产品实现的。\nAMQP 协议的三层：\nModule Layer:协议最高层，主要定义了一些客户端调用的命令，客户端可以用这些命令实现自己的业务逻辑。 Session Layer:中间层，主要负责客户端命令发送给服务器，再将服务端应答返回客户端，提供可靠性同步机制和错误处理。 TransportLayer:最底层，主要传输二进制数据流，提供帧的处理、信道复用、错误检测和数据表示等。 AMQP 模型的三大组件：\n交换器 (Exchange)：消息代理服务器中用于把消息路由到队列的组件。 队列 (Queue)：用来存储消息的数据结构，位于硬盘或内存中。 绑定 (Binding)：一套规则，告知交换器消息应该将消息投递给哪个队列。 2 RabbitMQ各组件及其功能 **Broker：**RabbitMQ服务器，接受客户端连接，实现AMQP实体服务 **Virtual Host：**虚拟主机，实现逻辑隔离，用于隔离不同环境或不同应用的消息流。每个虚拟主机都有自己的Exchange和Queue。 **Connection：**连接，管理和维护RabbitMQ服务器的TCP链接，生产者和消费者通过这个连接与Broker建立物理网络连接（RabbitMQ消息基于TCP进行传输）。 **Channel：**信道，是在Connection中创建的轻量级通道，客户端可以建立多个信道，可以减小建立TCP Connection的开销，信道数量没有限制。 **Exchange：**交换机，负责接受来自生产者的消息，并将其路由到一个或多个队列。有direct、topic、fanout、headers四种模式。 **Queue：**队列是消息的存储位置，每个队列都有唯一的名称。 **Binding：**绑定，是Exchange和Queue之间的关联规则，定义了消息如何从交换机路由到特定队列。 此外生产者和消费者也是消息队列中的核心组件，生产者负责发送消息到Exchange或者Queue，消费者负责从Queue中订阅和处理消息。\n生产者：生产者是消息的发送方，负责产生并发送消息到 RabbitMQ。生产者通常将消息发送到交换机（Exchange）。 消费者：消费者是消息的接收方，负责从队列中获取消息并进行处理。消费者通过订阅队列来接收消息。 消息：消息是生产者和消费者之间传递的数据单元。消息通常包含消息体和可选的属性，如路由键等。 3 RabbitMQ中交换机类型 Direct Exchange：根据消息的路由键（Routing Key）将消息发送到与之完全匹配的队列。 Topic Exchange：根据消息的路由键与队列绑定时指定的路由键模式匹配程度，将消息进行路由到一个或多个队列。路由键可以使用通配符（*【匹配一个单词】，#【匹配零个或多个单词】）。 Headers Exchange：根据消息的表头信息决定消息的路由，而不是路由键，当消息的表头与绑定规则完全匹配时，才会被路由到该队列。 消费方指定的headers中需要有一个x-match键 all：所有键匹配才可以接受消息 any：只要有键值对匹配成功，就可以接受消息 Fanout Exchange：广播路由，用于发布/订阅模式。 Default Exchange：默认实现的交换机，不需要手动创建。当消息被发布到默认交换机时，路由键会被解释为队列的名称，实现点对点通信。 4 RabbitMQ工作原理 AMQP协议模型有三部分组成：生产者、消费者和服务端。\n执行流程：\n生产者连接到服务端，建立连接，开启信道 生产者声明交换器和队列，设置相关属性，并通过路由关键词将交换器和队列进行绑定 消费者建立连接，开启信道，监听消息 生产者发送消息 虚拟主机根据路由关键词选择路由，发送道不同的消息队列 消费者拿到消息进行消费 5 RabbitMQ工作模式 Simple模式：一对一。 Work Queue工作队列模式：生产者发送消息到Queue，多个消费者同时消费，消息会均匀分配给多个消费者。 发布订阅模式：生产者发送消息到Queue，所有的消费者都会消费同一个消息。 路由模式：在发布订阅模式上增加了路由键，根据路由键判断将消息转发到哪些Queue中。 主题模式：在路由模式基础上，添加了模糊匹配的功能。 6 消息持久化 RabbitMQ 允许消息的持久化，以确保即使在 RabbitMQ 服务器重新启动后，消息也不会丢失。RabbitMQ 可以通过以下方式实现消息的持久化：\n消息持久化：在 RabbitMQ 中，只需要在发送消息时，将delivery_mode属性设置为 2，就可以将消息标记为持久化。 队列持久化：在 RabbitMQ 中声明队列时，也可以将队列声明为持久化。RabbitMQ 中的队列分为三种不同类型经典队列，仲裁队列和流式队列。其中，经典队列需要将durable属性设置为true。而仲裁队列和流式队列默认必须持久化保存。 交换机持久化：与经典队列类似，RabbitMQ 也可以在声明交换机时，将交换机的 durable 属性设置为true，这样就可以将交换机标记为持久化。 RabbitMQ 的持久化机制会对其性能产生影响。因此，需要根据具体的业务场景和需求来权衡是否需要持久化以及需要哪种类型的持久化。\n7 如何保证RabbitMQ消息的顺序性 拆分多个queue，对同一数据的操作放在一个队列中 只是用一个队列和一个消费者 8 有哪些情况会发生消息丢失，如何保证不丢失 生产者发送丢失： 原因：网络问题，代码问题 解决：发布确认机制，生产者设置信道为confirm模式，broker收到消息会发送确认消息给生产者 或者开启AMQP事务处理，但是这个方式是同步的，会阻塞，不推荐 RabbitMQ存储丢失 原因：消息没有持久化，网络问题 解决：消息回退（设置mandatory参数，消息不可达时返回给生产者）、持久化 消费者丢失 原因：消费端宕机或消息处理异常 解决：手动ack确认 9 Rabbit如何保证消息被消费 消费端配置手动ACK确认机制 结合数据库进行状态标记 在新增场景，可以采用数据库唯一约束 在更新场景，可以考虑乐观锁+版本号 插入记录时 ，在业务代码中检查 利用一个去重表（可以基于Redis实现，并利用TTL设置过期时间），插入成功的进入消费流程，失败的查看是否被消费，被消费则返回成功，没有则进行延时消费。 10 Rabbit中如何进行事务处理 RabbitMQ 提供了事务处理机制，允许生产者在发送消息时将操作包装在一个事务中，以确保消息的可靠性传递。在 RabbitMQ 中，事务是通过通道（Channel）来实现的。可以通过以下步骤进行事务处理：\n开启事务：在生产者端，可以通过调用 Channel 的 tx_select 方法来开启一个事务。这将启动一个新的事务，并将所有后续的消息发布操作放在该事务内。 发送消息：接下来在事务中，可以正常发送消息。如果消息发送失败，事务会自动回滚。 提交事务：如果事务中所有消息发送成功后，需要提交事务。可以通过调用 Channel 的tx_commit方法提交事务。 处理异常：如果在事务过程中发生异常，可以使用 try/catch 快来捕获异常。然后在异常处理过程中，调用 Channel 的 tx_rollback 方法来回滚 RabbitMQ 相关的事务操作。 需要注意的是，RabbitMQ 的事务处理是基于存储过程的，它可以保证在事务中的操作要么全部成功，要么全部失败。但是，由于 RabbitMQ 是一个异步的消息队列系统，事务处理可能会对其性能产生影响。因此，需要根据具体的应用场景和需求来权衡是否需要使用事务以及如何使用事务。\n11 如何解决消息堆积问题 产生堆积的原因：\n消费者处理速度慢 队列容量小 网络故障 消费者故障 队列使用不当 消息太大 业务逻辑复杂且耗时 生产速度大于消费速度 解决方案：\n增加消费者数量，水平拓展 提高消费者处理效率，代码调优、增加资源 消息预取限制 增加队列容量 采用死信队列等容错机制 对大型消息进行分片 优化业务逻辑 12 死信队列 死信队列是 RabbitMQ 提供的一种特殊序列，处理那些无法被正常消费的消息。有三种情况会产生死信：\n消息被消费者明确拒绝。 消息达到预设的过期时间仍没有消费者消费。 消息由于队列已经达到最大长度限制而被丢弃。 在 RabbitMQ 中，实现死信队列只需要给正常队列增加三个核心参数即可：\ndead-letter-exchange：指定当前队列对应的死信队列 dead-letter-routing-key：指定消息转入死信队列时的路由键 message-ttl：消息在队列中的过期时间。 接下来，就可以往正常队列中发送消息。如果消息满足了某些条件，就会成为死信，并被重新发送到对应的死信队列中。而此时，RabbitMQ 会在消息的头部添加一些与死信相关的补充信息，例如时间、成为死信的原因、原队列等。应用程序可以按需处理这些补充的信息。\n最后，死信队列中的消息都是正常业务处理失败的消息，应用程序需要创建一个消费者来专门处理这些被遗漏的消息。例如记录日志、发送警报等。这样才能保证业务数据的完整性。\n13 延时队列 延迟队列指的是存储对应的延迟消息，消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。\nRabbitMQ 本身是没有延迟队列的，要实现延迟消息，一般有两种方式：\n通过 RabbitMQ 本身队列的特性来实现，需要使用 RabbitMQ 的死信交换机（Exchange）和消息的存活时间 TTL（Time To Live）。 在 RabbitMQ 3.5.7 及以上的版本提供了一个插件（rabbitmq-delayed-message-exchange）来实现延迟队列功能。同时，插件依赖 Erlang/OPT 18.0 及以上。 也就是说，AMQP 协议以及 RabbitMQ 本身没有直接支持延迟队列的功能，但是可以通过 TTL 和 DLX 模拟出延迟队列的功能。 14 优先级队列 RabbitMQ 自 V3.5.0 有优先级队列实现，优先级高的队列会先被消费。 可以通过x-max-priority参数来实现优先级队列。不过，当消费速度大于生产速度且 Broker 没有堆积的情况下，优先级显得没有意义。\n15 集群 RabbitMQ 支持两种主要类型的集群：普通集群（Classic Cluster）和镜像集群（Mirrored Cluster）。他们之间有一些重要的区别：\n普通集群： 这种模式使用Erlang语言天生具备的集群方式搭建。这种集群模式下，集群的各个节点之间只会有相同的元数据，即队列结构，而消息不会进行冗余，只存在一个节点中。消费时，如果消费的不是存有数据的节点， RabbitMQ会临时在节点之间进行数据传输，将消息从存有数据的节点传输到消费的节点。很显然，这种集群模式的消息可靠性不是很高。因为如果其中有个节点服务宕机了，那这个节点上的数据就无法消费了，需要等到这个节点服务恢复后才能消费，而这时，消费者端已经消费过的消息就有可能给不了服务端正确应答，服务起来后，就会再次消费这些消息，造成这部分消息重复消费。 另外，如果消息没有做持久化，重启就消息就会丢失。并且，这种集群模式也不支持高可用，即当某一个节点服务挂了后，需要手动重启服务，才能保证这一部分消息能正常消费。所以这种集群模式只适合一些对消息安全性不是很高的场景。而在使用这种模式时，消费者应该尽量的连接上每一个节点，减少消息在集群中的传输。 镜像集群：这种模式是在普通集群模式基础上的一种增强方案，这也就是RabbitMQ的官方HA高可用方案。需要在搭建了普通集群之后再补充搭建。其本质区别在于，这种模式会在镜像节点中间主动进行消息同步，而不是在客户端拉取消息时临时同步。并且在集群内部有一个算法会选举产生master和slave，当一个master挂了后，也会自动选出一个来。从而给整个集群提供高可用能力。这种模式的消息可靠性更高，因为每个节点上都存着全量的消息。而他的弊端也是明显的，集群内部的网络带宽会被这种同步通讯大量的消耗，进而降低整个集群的性能。这种模式下，队列数量最好不要过多 总的来说，普通集群适用于对性能要求高，但可以接受数据丢失的情况。而镜像集群则适用于对数据持久性和可用性有更高要求，并愿意付出一些性能代价的场景。\n","wordCount":"258","inLanguage":"en","image":"https://roaraeonliou.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-09-26T00:00:00Z","dateModified":"2024-09-26T00:00:00Z","author":{"@type":"Person","name":"RLTEA"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://roaraeonliou.github.io/posts/interviewnotes/messagequeue/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97rabbitmq/"},"publisher":{"@type":"Organization","name":"RLTEA BLOG","logo":{"@type":"ImageObject","url":"https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E"}}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["\\(","\\)"],["$","$"]]}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://roaraeonliou.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://roaraeonliou.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://roaraeonliou.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://roaraeonliou.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://roaraeonliou.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://roaraeonliou.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://roaraeonliou.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://roaraeonliou.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">消息队列RabbitMQ</h1><div class=post-meta><span title='2024-09-26 00:00:00 +0000 UTC'>September 26, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;258 words&nbsp;·&nbsp;RLTEA&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/InterviewNotes/MessageQueue/%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97RabbitMQ.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97rabbitmq aria-label=消息队列RabbitMQ>消息队列RabbitMQ</a></li><li><a href=#1-amqp aria-label="1 AMQP">1 AMQP</a></li><li><a href=#2-rabbitmq%e5%90%84%e7%bb%84%e4%bb%b6%e5%8f%8a%e5%85%b6%e5%8a%9f%e8%83%bd aria-label="2 RabbitMQ各组件及其功能">2 RabbitMQ各组件及其功能</a></li><li><a href=#3-rabbitmq%e4%b8%ad%e4%ba%a4%e6%8d%a2%e6%9c%ba%e7%b1%bb%e5%9e%8b aria-label="3 RabbitMQ中交换机类型">3 RabbitMQ中交换机类型</a></li><li><a href=#4-rabbitmq%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86 aria-label="4 RabbitMQ工作原理">4 RabbitMQ工作原理</a></li><li><a href=#5-rabbitmq%e5%b7%a5%e4%bd%9c%e6%a8%a1%e5%bc%8f aria-label="5 RabbitMQ工作模式">5 RabbitMQ工作模式</a></li><li><a href=#6-%e6%b6%88%e6%81%af%e6%8c%81%e4%b9%85%e5%8c%96 aria-label="6 消息持久化">6 消息持久化</a></li><li><a href=#7-%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81rabbitmq%e6%b6%88%e6%81%af%e7%9a%84%e9%a1%ba%e5%ba%8f%e6%80%a7 aria-label="7 如何保证RabbitMQ消息的顺序性">7 如何保证RabbitMQ消息的顺序性</a></li><li><a href=#8-%e6%9c%89%e5%93%aa%e4%ba%9b%e6%83%85%e5%86%b5%e4%bc%9a%e5%8f%91%e7%94%9f%e6%b6%88%e6%81%af%e4%b8%a2%e5%a4%b1%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e4%b8%8d%e4%b8%a2%e5%a4%b1 aria-label="8 有哪些情况会发生消息丢失，如何保证不丢失">8 有哪些情况会发生消息丢失，如何保证不丢失</a></li><li><a href=#9-rabbit%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e6%b6%88%e6%81%af%e8%a2%ab%e6%b6%88%e8%b4%b9 aria-label="9 Rabbit如何保证消息被消费">9 Rabbit如何保证消息被消费</a></li><li><a href=#10-rabbit%e4%b8%ad%e5%a6%82%e4%bd%95%e8%bf%9b%e8%a1%8c%e4%ba%8b%e5%8a%a1%e5%a4%84%e7%90%86 aria-label="10 Rabbit中如何进行事务处理">10 Rabbit中如何进行事务处理</a></li><li><a href=#11-%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3%e6%b6%88%e6%81%af%e5%a0%86%e7%a7%af%e9%97%ae%e9%a2%98 aria-label="11 如何解决消息堆积问题">11 如何解决消息堆积问题</a></li><li><a href=#12-%e6%ad%bb%e4%bf%a1%e9%98%9f%e5%88%97 aria-label="12 死信队列">12 死信队列</a></li><li><a href=#13-%e5%bb%b6%e6%97%b6%e9%98%9f%e5%88%97 aria-label="13 延时队列">13 延时队列</a><ul><ul><ul><li><a href=#%e4%b9%9f%e5%b0%b1%e6%98%af%e8%af%b4amqp-%e5%8d%8f%e8%ae%ae%e4%bb%a5%e5%8f%8a-rabbitmq-%e6%9c%ac%e8%ba%ab%e6%b2%a1%e6%9c%89%e7%9b%b4%e6%8e%a5%e6%94%af%e6%8c%81%e5%bb%b6%e8%bf%9f%e9%98%9f%e5%88%97%e7%9a%84%e5%8a%9f%e8%83%bd%e4%bd%86%e6%98%af%e5%8f%af%e4%bb%a5%e9%80%9a%e8%bf%87-ttl-%e5%92%8c-dlx-%e6%a8%a1%e6%8b%9f%e5%87%ba%e5%bb%b6%e8%bf%9f%e9%98%9f%e5%88%97%e7%9a%84%e5%8a%9f%e8%83%bd aria-label="也就是说，AMQP 协议以及 RabbitMQ 本身没有直接支持延迟队列的功能，但是可以通过 TTL 和 DLX 模拟出延迟队列的功能。">也就是说，AMQP 协议以及 RabbitMQ 本身没有直接支持延迟队列的功能，但是可以通过 TTL 和 DLX 模拟出延迟队列的功能。</a></li></ul></ul></ul></li><li><a href=#14-%e4%bc%98%e5%85%88%e7%ba%a7%e9%98%9f%e5%88%97 aria-label="14 优先级队列">14 优先级队列</a><ul><ul><ul><li><a href=#rabbitmq-%e8%87%aa-v350-%e6%9c%89%e4%bc%98%e5%85%88%e7%ba%a7%e9%98%9f%e5%88%97%e5%ae%9e%e7%8e%b0%e4%bc%98%e5%85%88%e7%ba%a7%e9%ab%98%e7%9a%84%e9%98%9f%e5%88%97%e4%bc%9a%e5%85%88%e8%a2%ab%e6%b6%88%e8%b4%b9 aria-label="RabbitMQ 自 V3.5.0 有优先级队列实现，优先级高的队列会先被消费。">RabbitMQ 自 V3.5.0 有优先级队列实现，优先级高的队列会先被消费。</a></li></ul></ul></ul></li><li><a href=#15-%e9%9b%86%e7%be%a4 aria-label="15 集群">15 集群</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=消息队列rabbitmq>消息队列RabbitMQ<a hidden class=anchor aria-hidden=true href=#消息队列rabbitmq>#</a></h1><p>消息队列是一种消息中间件，不负责处理消息，仅负责消息的接受存储和转发.</p><p><strong>RabbitMQ特点：</strong></p><ol><li>**消息传递模式：**支持多种消息传递模式，包括发布订阅、点对点和工作队列等。</li><li>**消息路由和交换机：**RabbitMQ引入了交换机（Exchange）概念，用于将消息路由到一个或者多个队列。允许根据消息内容、标签或者路由键进行灵活的消息路由。</li><li>**消息确认机制：**RabbitMQ支持消息确认机制，保证消息不会被重复消费。</li><li>**可扩展性：**RabbitMQ可以通过添加更多的节点和集群来增加吞吐量和可用性。</li><li><strong>支持多种编程语言。</strong></li><li>**消息持久性：**Rabbit允许消息和队列进行持久化设置，确保消息在RabbitMQ重启后不会丢失。</li><li>**灵活的插件系统：**RabbitMQ具有丰富的插件系统，可以拓展多种功能。</li><li><strong>具有易于管理的Web界面。</strong></li></ol><p><strong>为什么要使用消息队列</strong></p><ol><li>流量削峰：队列缓存请求</li><li>应用解耦</li><li>异步处理</li></ol><h1 id=1-amqp>1 AMQP<a hidden class=anchor aria-hidden=true href=#1-amqp>#</a></h1><p>AMQP（Advanced Message Queuing Protocol）不是一个具体的消息中间件产品，而是一个协议规范，一种为面向消息的中间件设计的应用层协议。AMQP提供了一种统一的消息服务，是的不同程序之间可以通过消息队列进行通信。SpringBoot框架默认就提供了对AMQP协议的支持。</p><p>AMQP 本质上是一个开放的标准，他不光可以被 RabbitMQ 实现，也可以被其他产品实现。通过这种标准的协议，实际上是可以在不同的消息中间件系统之间进行灵活的消息传递。只不过，目前具体实现这种标准的产品目前并不多，RabbitMQ 则是最有影响力的一个产品。因此，RabbitMQ 成了 AMQP 协议事实上的代表。SpringBoot 框架默认提供的 AMQP 协议支持底层也是基于 RabbitMQ 产品实现的。</p><p><strong>AMQP 协议的三层</strong>：</p><ul><li><strong>Module Layer</strong>:协议最高层，主要定义了一些客户端调用的命令，客户端可以用这些命令实现自己的业务逻辑。</li><li><strong>Session Layer</strong>:中间层，主要负责客户端命令发送给服务器，再将服务端应答返回客户端，提供可靠性同步机制和错误处理。</li><li><strong>TransportLayer</strong>:最底层，主要传输二进制数据流，提供帧的处理、信道复用、错误检测和数据表示等。</li></ul><p><strong>AMQP 模型的三大组件</strong>：</p><ul><li><strong>交换器 (Exchange)</strong>：消息代理服务器中用于把消息路由到队列的组件。</li><li><strong>队列 (Queue)</strong>：用来存储消息的数据结构，位于硬盘或内存中。</li><li><strong>绑定 (Binding)</strong>：一套规则，告知交换器消息应该将消息投递给哪个队列。</li></ul><h1 id=2-rabbitmq各组件及其功能>2 RabbitMQ各组件及其功能<a hidden class=anchor aria-hidden=true href=#2-rabbitmq各组件及其功能>#</a></h1><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/ba56f7e9446b0c1fbcd3cb484cdeb034/d73d41db6f0cbb3ada3c83c874e2e118.png alt=image.png></p><ul><li>**Broker：**RabbitMQ服务器，接受客户端连接，实现AMQP实体服务</li><li>**Virtual Host：**虚拟主机，实现逻辑隔离，用于隔离不同环境或不同应用的消息流。每个虚拟主机都有自己的Exchange和Queue。</li><li>**Connection：**连接，管理和维护RabbitMQ服务器的TCP链接，生产者和消费者通过这个连接与Broker建立物理网络连接（<strong>RabbitMQ消息基于TCP进行传输</strong>）。</li><li>**Channel：**信道，是在Connection中创建的轻量级通道，<strong>客户端可以建立多个信道，可以减小建立TCP Connection的开销，信道数量没有限制</strong>。</li><li>**Exchange：**交换机，负责接受来自生产者的消息，并将其路由到一个或多个队列。有direct、topic、fanout、headers四种模式。</li><li>**Queue：**队列是消息的存储位置，每个队列都有唯一的名称。</li><li>**Binding：**绑定，是Exchange和Queue之间的关联规则，定义了消息如何从交换机路由到特定队列。</li></ul><p>此外生产者和消费者也是消息队列中的核心组件，生产者负责发送消息到Exchange或者Queue，消费者负责从Queue中订阅和处理消息。</p><ul><li>生产者：生产者是消息的发送方，负责产生并发送消息到 RabbitMQ。生产者通常将消息发送到交换机（Exchange）。</li><li>消费者：消费者是消息的接收方，负责从队列中获取消息并进行处理。消费者通过订阅队列来接收消息。</li><li>消息：消息是生产者和消费者之间传递的数据单元。消息通常包含消息体和可选的属性，如路由键等。</li></ul><h1 id=3-rabbitmq中交换机类型>3 RabbitMQ中交换机类型<a hidden class=anchor aria-hidden=true href=#3-rabbitmq中交换机类型>#</a></h1><ul><li><strong>Direct Exchange</strong>：根据消息的路由键（Routing Key）将消息发送到与之完全匹配的队列。</li></ul><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/ba56f7e9446b0c1fbcd3cb484cdeb034/0e1a89def6ace6972683467974c45afe.png alt=image.png></p><ul><li><strong>Topic Exchange</strong>：根据消息的路由键与队列绑定时指定的路由键模式匹配程度，将消息进行路由到一个或多个队列。路由键可以使用通配符（*【匹配一个单词】，#【匹配零个或多个单词】）。</li></ul><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/ba56f7e9446b0c1fbcd3cb484cdeb034/1af3849dacd2096f12dc769580431548.png alt=image.png></p><ul><li><strong>Headers Exchange</strong>：根据消息的表头信息决定消息的路由，而不是路由键，当消息的表头与绑定规则完全匹配时，才会被路由到该队列。<ul><li>消费方指定的headers中需要有一个x-match键<ul><li>all：所有键匹配才可以接受消息</li><li>any：只要有键值对匹配成功，就可以接受消息</li></ul></li></ul></li></ul><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/ba56f7e9446b0c1fbcd3cb484cdeb034/9fb2cef5f23a21e40addae1a3b20ba62.png alt=image.png></p><ul><li><strong>Fanout Exchange</strong>：广播路由，用于发布/订阅模式。</li></ul><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/ba56f7e9446b0c1fbcd3cb484cdeb034/e2aefb6ff95e94aaaeef23c5f3574a36.png alt=image.png></p><ul><li><strong>Default Exchange</strong>：默认实现的交换机，不需要手动创建。当消息被发布到默认交换机时，路由键会被解释为队列的名称，实现点对点通信。</li></ul><h1 id=4-rabbitmq工作原理>4 RabbitMQ工作原理<a hidden class=anchor aria-hidden=true href=#4-rabbitmq工作原理>#</a></h1><p>AMQP协议模型有三部分组成：生产者、消费者和服务端。</p><p>执行流程：</p><ol><li>生产者连接到服务端，建立连接，开启信道</li><li>生产者声明交换器和队列，设置相关属性，并通过路由关键词将交换器和队列进行绑定</li><li>消费者建立连接，开启信道，监听消息</li><li>生产者发送消息</li><li>虚拟主机根据路由关键词选择路由，发送道不同的消息队列</li><li>消费者拿到消息进行消费</li></ol><h1 id=5-rabbitmq工作模式>5 RabbitMQ工作模式<a hidden class=anchor aria-hidden=true href=#5-rabbitmq工作模式>#</a></h1><ol><li>Simple模式：一对一。</li><li>Work Queue工作队列模式：生产者发送消息到Queue，多个消费者同时消费，消息会均匀分配给多个消费者。</li><li>发布订阅模式：生产者发送消息到Queue，所有的消费者都会消费同一个消息。</li><li>路由模式：在发布订阅模式上增加了路由键，根据路由键判断将消息转发到哪些Queue中。</li><li>主题模式：在路由模式基础上，添加了模糊匹配的功能。</li></ol><h1 id=6-消息持久化>6 消息持久化<a hidden class=anchor aria-hidden=true href=#6-消息持久化>#</a></h1><p>RabbitMQ 允许消息的持久化，以确保即使在 RabbitMQ 服务器重新启动后，消息也不会丢失。RabbitMQ 可以通过以下方式实现消息的持久化：</p><ol><li>消息持久化：在 RabbitMQ 中，只需要在发送消息时，将delivery_mode属性设置为 2，就可以将消息标记为持久化。</li><li>队列持久化：在 RabbitMQ 中声明队列时，也可以将队列声明为持久化。RabbitMQ 中的队列分为三种不同类型经典队列，仲裁队列和流式队列。其中，经典队列需要将durable属性设置为true。而仲裁队列和流式队列默认必须持久化保存。</li><li>交换机持久化：与经典队列类似，RabbitMQ 也可以在声明交换机时，将交换机的 durable 属性设置为true，这样就可以将交换机标记为持久化。</li></ol><p>RabbitMQ 的持久化机制会对其性能产生影响。因此，需要根据具体的业务场景和需求来权衡是否需要持久化以及需要哪种类型的持久化。</p><h1 id=7-如何保证rabbitmq消息的顺序性>7 如何保证RabbitMQ消息的顺序性<a hidden class=anchor aria-hidden=true href=#7-如何保证rabbitmq消息的顺序性>#</a></h1><ul><li>拆分多个queue，对同一数据的操作放在一个队列中</li><li>只是用一个队列和一个消费者</li></ul><h1 id=8-有哪些情况会发生消息丢失如何保证不丢失>8 有哪些情况会发生消息丢失，如何保证不丢失<a hidden class=anchor aria-hidden=true href=#8-有哪些情况会发生消息丢失如何保证不丢失>#</a></h1><ol><li>生产者发送丢失：<ul><li>原因：网络问题，代码问题</li><li>解决：发布确认机制，生产者设置信道为confirm模式，broker收到消息会发送确认消息给生产者</li><li>或者开启AMQP事务处理，但是这个方式是同步的，会阻塞，不推荐</li></ul></li><li>RabbitMQ存储丢失<ul><li>原因：消息没有持久化，网络问题</li><li>解决：消息回退（设置mandatory参数，消息不可达时返回给生产者）、持久化</li></ul></li><li>消费者丢失<ul><li>原因：消费端宕机或消息处理异常</li><li>解决：手动ack确认</li></ul></li></ol><h1 id=9-rabbit如何保证消息被消费>9 Rabbit如何保证消息被消费<a hidden class=anchor aria-hidden=true href=#9-rabbit如何保证消息被消费>#</a></h1><ul><li>消费端配置手动ACK确认机制</li><li>结合数据库进行状态标记</li><li>在新增场景，可以采用数据库唯一约束</li><li>在更新场景，可以考虑乐观锁+版本号</li><li>插入记录时 ，在业务代码中检查</li><li>利用一个去重表（可以基于Redis实现，并利用TTL设置过期时间），插入成功的进入消费流程，失败的查看是否被消费，被消费则返回成功，没有则进行延时消费。</li></ul><h1 id=10-rabbit中如何进行事务处理>10 Rabbit中如何进行事务处理<a hidden class=anchor aria-hidden=true href=#10-rabbit中如何进行事务处理>#</a></h1><p>RabbitMQ 提供了事务处理机制，允许生产者在发送消息时将操作包装在一个事务中，以确保消息的可靠性传递。在 RabbitMQ 中，事务是通过通道（Channel）来实现的。可以通过以下步骤进行事务处理：</p><ol><li><strong>开启事务</strong>：在生产者端，可以通过调用 Channel 的 tx_select 方法来开启一个事务。这将启动一个新的事务，并将所有后续的消息发布操作放在该事务内。</li><li><strong>发送消息</strong>：接下来在事务中，可以正常发送消息。如果消息发送失败，事务会自动回滚。</li><li><strong>提交事务</strong>：如果事务中所有消息发送成功后，需要提交事务。可以通过调用 Channel 的tx_commit方法提交事务。</li><li><strong>处理异常</strong>：如果在事务过程中发生异常，可以使用 try/catch 快来捕获异常。然后在异常处理过程中，调用 Channel 的 tx_rollback 方法来回滚 RabbitMQ 相关的事务操作。</li></ol><p>需要注意的是，RabbitMQ 的事务处理是基于存储过程的，它可以保证在事务中的操作要么全部成功，要么全部失败。但是，由于 RabbitMQ 是一个异步的消息队列系统，事务处理可能会对其性能产生影响。因此，需要根据具体的应用场景和需求来权衡是否需要使用事务以及如何使用事务。</p><h1 id=11-如何解决消息堆积问题>11 如何解决消息堆积问题<a hidden class=anchor aria-hidden=true href=#11-如何解决消息堆积问题>#</a></h1><p>产生堆积的原因：</p><ol><li>消费者处理速度慢</li><li>队列容量小</li><li>网络故障</li><li>消费者故障</li><li>队列使用不当</li><li>消息太大</li><li>业务逻辑复杂且耗时</li><li>生产速度大于消费速度</li></ol><p>解决方案：</p><ol><li>增加消费者数量，水平拓展</li><li>提高消费者处理效率，代码调优、增加资源</li><li>消息预取限制</li><li>增加队列容量</li><li>采用死信队列等容错机制</li><li>对大型消息进行分片</li><li>优化业务逻辑</li></ol><h1 id=12-死信队列>12 死信队列<a hidden class=anchor aria-hidden=true href=#12-死信队列>#</a></h1><p>死信队列是 RabbitMQ 提供的一种特殊序列，处理那些无法被正常消费的消息。有三种情况会产生死信：</p><ul><li>消息被消费者明确拒绝。</li><li>消息达到预设的过期时间仍没有消费者消费。</li><li>消息由于队列已经达到最大长度限制而被丢弃。</li></ul><p>在 RabbitMQ 中，实现死信队列只需要给正常队列增加三个核心参数即可：</p><ol><li>dead-letter-exchange：指定当前队列对应的死信队列</li><li>dead-letter-routing-key：指定消息转入死信队列时的路由键</li><li>message-ttl：消息在队列中的过期时间。</li></ol><p>接下来，就可以往正常队列中发送消息。如果消息满足了某些条件，就会成为死信，并被重新发送到对应的死信队列中。而此时，RabbitMQ 会在消息的头部添加一些与死信相关的补充信息，例如时间、成为死信的原因、原队列等。应用程序可以按需处理这些补充的信息。</p><p>最后，死信队列中的消息都是正常业务处理失败的消息，应用程序需要创建一个消费者来专门处理这些被遗漏的消息。例如记录日志、发送警报等。这样才能保证业务数据的完整性。</p><h1 id=13-延时队列>13 延时队列<a hidden class=anchor aria-hidden=true href=#13-延时队列>#</a></h1><p>延迟队列指的是存储对应的延迟消息，消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。</p><p>RabbitMQ 本身是没有延迟队列的，要实现延迟消息，一般有两种方式：</p><ol><li>通过 RabbitMQ 本身队列的特性来实现，需要使用 RabbitMQ 的死信交换机（Exchange）和消息的存活时间 TTL（Time To Live）。</li><li>在 RabbitMQ 3.5.7 及以上的版本提供了一个插件（rabbitmq-delayed-message-exchange）来实现延迟队列功能。同时，插件依赖 Erlang/OPT 18.0 及以上。</li></ol><h4 id=也就是说amqp-协议以及-rabbitmq-本身没有直接支持延迟队列的功能但是可以通过-ttl-和-dlx-模拟出延迟队列的功能>也就是说，AMQP 协议以及 RabbitMQ 本身没有直接支持延迟队列的功能，但是可以通过 TTL 和 DLX 模拟出延迟队列的功能。<a hidden class=anchor aria-hidden=true href=#也就是说amqp-协议以及-rabbitmq-本身没有直接支持延迟队列的功能但是可以通过-ttl-和-dlx-模拟出延迟队列的功能>#</a></h4><h1 id=14-优先级队列>14 优先级队列<a hidden class=anchor aria-hidden=true href=#14-优先级队列>#</a></h1><h4 id=rabbitmq-自-v350-有优先级队列实现优先级高的队列会先被消费>RabbitMQ 自 V3.5.0 有优先级队列实现，优先级高的队列会先被消费。<a hidden class=anchor aria-hidden=true href=#rabbitmq-自-v350-有优先级队列实现优先级高的队列会先被消费>#</a></h4><p>可以通过<code>x-max-priority</code>参数来实现优先级队列。不过，当消费速度大于生产速度且 Broker 没有堆积的情况下，优先级显得没有意义。</p><h1 id=15-集群>15 集群<a hidden class=anchor aria-hidden=true href=#15-集群>#</a></h1><p>RabbitMQ 支持两种主要类型的集群：普通集群（Classic Cluster）和镜像集群（Mirrored Cluster）。他们之间有一些重要的区别：</p><ul><li><strong>普通集群</strong>： 这种模式使用Erlang语言天生具备的集群方式搭建。这种集群模式下，集群的各个节点之间只会有相同的元数据，即队列结构，而消息不会进行冗余，只存在一个节点中。消费时，如果消费的不是存有数据的节点， RabbitMQ会临时在节点之间进行数据传输，将消息从存有数据的节点传输到消费的节点。很显然，这种集群模式的消息可靠性不是很高。因为如果其中有个节点服务宕机了，那这个节点上的数据就无法消费了，需要等到这个节点服务恢复后才能消费，而这时，消费者端已经消费过的消息就有可能给不了服务端正确应答，服务起来后，就会再次消费这些消息，造成这部分消息重复消费。 另外，如果消息没有做持久化，重启就消息就会丢失。并且，这种集群模式也不支持高可用，即当某一个节点服务挂了后，需要手动重启服务，才能保证这一部分消息能正常消费。所以这种集群模式只适合一些对消息安全性不是很高的场景。而在使用这种模式时，消费者应该尽量的连接上每一个节点，减少消息在集群中的传输。</li><li><strong>镜像集群</strong>：这种模式是在普通集群模式基础上的一种增强方案，这也就是RabbitMQ的官方HA高可用方案。需要在搭建了普通集群之后再补充搭建。其本质区别在于，这种模式会在镜像节点中间主动进行消息同步，而不是在客户端拉取消息时临时同步。并且在集群内部有一个算法会选举产生master和slave，当一个master挂了后，也会自动选出一个来。从而给整个集群提供高可用能力。这种模式的消息可靠性更高，因为每个节点上都存着全量的消息。而他的弊端也是明显的，集群内部的网络带宽会被这种同步通讯大量的消耗，进而降低整个集群的性能。这种模式下，队列数量最好不要过多</li></ul><p>总的来说，普通集群适用于对性能要求高，但可以接受数据丢失的情况。而镜像集群则适用于对数据持久性和可用性有更高要求，并愿意付出一些性能代价的场景。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://roaraeonliou.github.io/posts/interviewnotes/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/><span class=title>« Prev</span><br><span>数据结构</span>
</a><a class=next href=https://roaraeonliou.github.io/posts/interviewnotes/designmode/%E7%BB%93%E6%9E%84%E6%80%A7%E6%A8%A1%E5%BC%8F/><span class=title>Next »</span><br><span>结构性模式</span></a></nav></footer><div id=comments><script src=https://giscus.app/client.js data-repo=RoaraeonLiou/roaraeonliou.github.io data-repo-id=R_kgDOMIxQ4w data-category=Announcements data-category-id=DIC_kwDOMIxQ484CgZUR data-mapping=title data-strict=1 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2024 <a href=https://roaraeonliou.github.io/>RLTEA BLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>