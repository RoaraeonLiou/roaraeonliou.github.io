<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>计算机网络 | RLTEA BLOG</title>
<meta name=keywords content="笔记,计算机网络"><meta name=description content="计算机网络
1 分层模型
OSI七层模型：



口诀：物联网书会使用
优点：概念结构清楚，理论完整
缺点：复杂不实用、某些功能在多个层中重复出现。

TCP/IP四层模型：


为什么要分层？

使得各层之间独立。
提高灵活性和可替换性（高内聚低耦合）。
大问题化小，复杂问题分解。

2 常见网络协议
应用层：

HTTP
SMTP
POP3/IMAP
FTP
Telnet
SSH
RTP
DNS

传输层：

TCP
UDP

网络层：

IP
ARP
ICMP
NAT
OSFP
RIP
BGP

3 HTTP


3.1 从输入URL到页面展示发生了什么？
过程：

用户输入URL。
浏览器查找域名IP地址（通过DNS：浏览器缓存、路由器缓存、DNS缓存）。
浏览器根据IP地址和端口号，向目标服务器发起TCP连接请求。
浏览器与服务器建立TCP连接，并发送HTTP请求报文。
服务器收到报文进行处理请求，并返回HTTP响应报文给浏览器。
浏览器收到HTTP响应报文后，解析响应体中的内容，并进行网页渲染，同时根据HTML中其他资源URL再次发起HTTP请求，直到网页完全加载显示。
浏览器在不需要和服务器通信时，可主动关闭TCP连接，或者等待服务器关闭请求。

使用到的协议：DNS、TCP、IP、OPSF、ARP、HTTP
3.2 HTTP和HTTPS的区别

URL前缀不同（http和https）
端口号不同（80和443）
安全性，HTTPS大于HTTP
资源消耗：HTTP优于HTTPS
SEO搜索引擎优化：优先显示HTTPS网页

::HTTPS中的S如何实现？::
3.3 HTTP/1.0和HTTP/1.1区别

1.1实现了长连接
1.1加入了大量状态码
1.1有更多的缓存控制机制
1.1支持断点续传

3.4 HTTP/1.1和HTTP/2.0区别

2.0实现了多路复用
2.0使用二进制帧传输（1.1使用文本格式报文）
2.0支持对头部压缩（1.1仅 支持对body压缩）
2.0支持服务器推送，可以减少客户端请求次数。

3.5 HTTP/2.0和HTTP/3.0区别

传输协议：3.0基于QUIC（UDP升级版），提供与TLS/SSL相当的安全性
连接建立：2.0需要经过TCP三次握手外加一个TLS安全握手，需约3个RTT；而3.0由于QUIC的特性，仅需要0个或1个RTT。
队头阻塞：2.0复用一个TCP连接，一旦包丢失，会阻塞所有HTTP请求。3.0一个连接有多个不同的数据流，互不影响。
错误恢复：3.0具有更快的恢复和重传机制，2.0需要依赖于TCP的错误恢复机制。
安全加密：2.0使用TLS协议进行加密，3.0基于QUIC协议，内置加密和身份验证机制，可以提供更强的安全性。

3.6 HTTP是不保存状态的协议，那么如何保存用户状态？
Session机制：通过服务端记录用户状态，时间限制到后销毁Session"><meta name=author content="RLTEA"><link rel=canonical href=https://roaraeonliou.github.io/posts/interviewnotes/networks/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.258803b0f0cc9a4a109c6fe78a9d39f2e0437217d71c5c9848255af9250f2b1b.css integrity="sha256-JYgDsPDMmkoQnG/nip058uBDchfXHFyYSCVa+SUPKxs=" rel="preload stylesheet" as=style><link rel=icon href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://roaraeonliou.github.io/posts/interviewnotes/networks/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="计算机网络"><meta property="og:description" content="计算机网络
1 分层模型
OSI七层模型：



口诀：物联网书会使用
优点：概念结构清楚，理论完整
缺点：复杂不实用、某些功能在多个层中重复出现。

TCP/IP四层模型：


为什么要分层？

使得各层之间独立。
提高灵活性和可替换性（高内聚低耦合）。
大问题化小，复杂问题分解。

2 常见网络协议
应用层：

HTTP
SMTP
POP3/IMAP
FTP
Telnet
SSH
RTP
DNS

传输层：

TCP
UDP

网络层：

IP
ARP
ICMP
NAT
OSFP
RIP
BGP

3 HTTP


3.1 从输入URL到页面展示发生了什么？
过程：

用户输入URL。
浏览器查找域名IP地址（通过DNS：浏览器缓存、路由器缓存、DNS缓存）。
浏览器根据IP地址和端口号，向目标服务器发起TCP连接请求。
浏览器与服务器建立TCP连接，并发送HTTP请求报文。
服务器收到报文进行处理请求，并返回HTTP响应报文给浏览器。
浏览器收到HTTP响应报文后，解析响应体中的内容，并进行网页渲染，同时根据HTML中其他资源URL再次发起HTTP请求，直到网页完全加载显示。
浏览器在不需要和服务器通信时，可主动关闭TCP连接，或者等待服务器关闭请求。

使用到的协议：DNS、TCP、IP、OPSF、ARP、HTTP
3.2 HTTP和HTTPS的区别

URL前缀不同（http和https）
端口号不同（80和443）
安全性，HTTPS大于HTTP
资源消耗：HTTP优于HTTPS
SEO搜索引擎优化：优先显示HTTPS网页

::HTTPS中的S如何实现？::
3.3 HTTP/1.0和HTTP/1.1区别

1.1实现了长连接
1.1加入了大量状态码
1.1有更多的缓存控制机制
1.1支持断点续传

3.4 HTTP/1.1和HTTP/2.0区别

2.0实现了多路复用
2.0使用二进制帧传输（1.1使用文本格式报文）
2.0支持对头部压缩（1.1仅 支持对body压缩）
2.0支持服务器推送，可以减少客户端请求次数。

3.5 HTTP/2.0和HTTP/3.0区别

传输协议：3.0基于QUIC（UDP升级版），提供与TLS/SSL相当的安全性
连接建立：2.0需要经过TCP三次握手外加一个TLS安全握手，需约3个RTT；而3.0由于QUIC的特性，仅需要0个或1个RTT。
队头阻塞：2.0复用一个TCP连接，一旦包丢失，会阻塞所有HTTP请求。3.0一个连接有多个不同的数据流，互不影响。
错误恢复：3.0具有更快的恢复和重传机制，2.0需要依赖于TCP的错误恢复机制。
安全加密：2.0使用TLS协议进行加密，3.0基于QUIC协议，内置加密和身份验证机制，可以提供更强的安全性。

3.6 HTTP是不保存状态的协议，那么如何保存用户状态？
Session机制：通过服务端记录用户状态，时间限制到后销毁Session"><meta property="og:type" content="article"><meta property="og:url" content="https://roaraeonliou.github.io/posts/interviewnotes/networks/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><meta property="og:image" content="https://roaraeonliou.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-26T00:00:00+00:00"><meta property="article:modified_time" content="2024-09-26T00:00:00+00:00"><meta property="og:site_name" content="RLTEA BLOG"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://roaraeonliou.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="计算机网络"><meta name=twitter:description content="计算机网络
1 分层模型
OSI七层模型：



口诀：物联网书会使用
优点：概念结构清楚，理论完整
缺点：复杂不实用、某些功能在多个层中重复出现。

TCP/IP四层模型：


为什么要分层？

使得各层之间独立。
提高灵活性和可替换性（高内聚低耦合）。
大问题化小，复杂问题分解。

2 常见网络协议
应用层：

HTTP
SMTP
POP3/IMAP
FTP
Telnet
SSH
RTP
DNS

传输层：

TCP
UDP

网络层：

IP
ARP
ICMP
NAT
OSFP
RIP
BGP

3 HTTP


3.1 从输入URL到页面展示发生了什么？
过程：

用户输入URL。
浏览器查找域名IP地址（通过DNS：浏览器缓存、路由器缓存、DNS缓存）。
浏览器根据IP地址和端口号，向目标服务器发起TCP连接请求。
浏览器与服务器建立TCP连接，并发送HTTP请求报文。
服务器收到报文进行处理请求，并返回HTTP响应报文给浏览器。
浏览器收到HTTP响应报文后，解析响应体中的内容，并进行网页渲染，同时根据HTML中其他资源URL再次发起HTTP请求，直到网页完全加载显示。
浏览器在不需要和服务器通信时，可主动关闭TCP连接，或者等待服务器关闭请求。

使用到的协议：DNS、TCP、IP、OPSF、ARP、HTTP
3.2 HTTP和HTTPS的区别

URL前缀不同（http和https）
端口号不同（80和443）
安全性，HTTPS大于HTTP
资源消耗：HTTP优于HTTPS
SEO搜索引擎优化：优先显示HTTPS网页

::HTTPS中的S如何实现？::
3.3 HTTP/1.0和HTTP/1.1区别

1.1实现了长连接
1.1加入了大量状态码
1.1有更多的缓存控制机制
1.1支持断点续传

3.4 HTTP/1.1和HTTP/2.0区别

2.0实现了多路复用
2.0使用二进制帧传输（1.1使用文本格式报文）
2.0支持对头部压缩（1.1仅 支持对body压缩）
2.0支持服务器推送，可以减少客户端请求次数。

3.5 HTTP/2.0和HTTP/3.0区别

传输协议：3.0基于QUIC（UDP升级版），提供与TLS/SSL相当的安全性
连接建立：2.0需要经过TCP三次握手外加一个TLS安全握手，需约3个RTT；而3.0由于QUIC的特性，仅需要0个或1个RTT。
队头阻塞：2.0复用一个TCP连接，一旦包丢失，会阻塞所有HTTP请求。3.0一个连接有多个不同的数据流，互不影响。
错误恢复：3.0具有更快的恢复和重传机制，2.0需要依赖于TCP的错误恢复机制。
安全加密：2.0使用TLS协议进行加密，3.0基于QUIC协议，内置加密和身份验证机制，可以提供更强的安全性。

3.6 HTTP是不保存状态的协议，那么如何保存用户状态？
Session机制：通过服务端记录用户状态，时间限制到后销毁Session"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://roaraeonliou.github.io/posts/"},{"@type":"ListItem","position":2,"name":"计算机网络","item":"https://roaraeonliou.github.io/posts/interviewnotes/networks/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"计算机网络","name":"计算机网络","description":"计算机网络 1 分层模型 OSI七层模型：\n口诀：物联网书会使用 优点：概念结构清楚，理论完整 缺点：复杂不实用、某些功能在多个层中重复出现。 TCP/IP四层模型：\n为什么要分层？\n使得各层之间独立。 提高灵活性和可替换性（高内聚低耦合）。 大问题化小，复杂问题分解。 2 常见网络协议 应用层：\nHTTP SMTP POP3/IMAP FTP Telnet SSH RTP DNS 传输层：\nTCP UDP 网络层：\nIP ARP ICMP NAT OSFP RIP BGP 3 HTTP 3.1 从输入URL到页面展示发生了什么？ 过程：\n用户输入URL。 浏览器查找域名IP地址（通过DNS：浏览器缓存、路由器缓存、DNS缓存）。 浏览器根据IP地址和端口号，向目标服务器发起TCP连接请求。 浏览器与服务器建立TCP连接，并发送HTTP请求报文。 服务器收到报文进行处理请求，并返回HTTP响应报文给浏览器。 浏览器收到HTTP响应报文后，解析响应体中的内容，并进行网页渲染，同时根据HTML中其他资源URL再次发起HTTP请求，直到网页完全加载显示。 浏览器在不需要和服务器通信时，可主动关闭TCP连接，或者等待服务器关闭请求。 使用到的协议：DNS、TCP、IP、OPSF、ARP、HTTP\n3.2 HTTP和HTTPS的区别 URL前缀不同（http和https） 端口号不同（80和443） 安全性，HTTPS大于HTTP 资源消耗：HTTP优于HTTPS SEO搜索引擎优化：优先显示HTTPS网页 ::HTTPS中的S如何实现？::\n3.3 HTTP/1.0和HTTP/1.1区别 1.1实现了长连接 1.1加入了大量状态码 1.1有更多的缓存控制机制 1.1支持断点续传 3.4 HTTP/1.1和HTTP/2.0区别 2.0实现了多路复用 2.0使用二进制帧传输（1.1使用文本格式报文） 2.0支持对头部压缩（1.1仅 支持对body压缩） 2.0支持服务器推送，可以减少客户端请求次数。 3.5 HTTP/2.0和HTTP/3.0区别 传输协议：3.0基于QUIC（UDP升级版），提供与TLS/SSL相当的安全性 连接建立：2.0需要经过TCP三次握手外加一个TLS安全握手，需约3个RTT；而3.0由于QUIC的特性，仅需要0个或1个RTT。 队头阻塞：2.0复用一个TCP连接，一旦包丢失，会阻塞所有HTTP请求。3.0一个连接有多个不同的数据流，互不影响。 错误恢复：3.0具有更快的恢复和重传机制，2.0需要依赖于TCP的错误恢复机制。 安全加密：2.0使用TLS协议进行加密，3.0基于QUIC协议，内置加密和身份验证机制，可以提供更强的安全性。 3.6 HTTP是不保存状态的协议，那么如何保存用户状态？ Session机制：通过服务端记录用户状态，时间限制到后销毁Session\n","keywords":["笔记","计算机网络"],"articleBody":"计算机网络 1 分层模型 OSI七层模型：\n口诀：物联网书会使用 优点：概念结构清楚，理论完整 缺点：复杂不实用、某些功能在多个层中重复出现。 TCP/IP四层模型：\n为什么要分层？\n使得各层之间独立。 提高灵活性和可替换性（高内聚低耦合）。 大问题化小，复杂问题分解。 2 常见网络协议 应用层：\nHTTP SMTP POP3/IMAP FTP Telnet SSH RTP DNS 传输层：\nTCP UDP 网络层：\nIP ARP ICMP NAT OSFP RIP BGP 3 HTTP 3.1 从输入URL到页面展示发生了什么？ 过程：\n用户输入URL。 浏览器查找域名IP地址（通过DNS：浏览器缓存、路由器缓存、DNS缓存）。 浏览器根据IP地址和端口号，向目标服务器发起TCP连接请求。 浏览器与服务器建立TCP连接，并发送HTTP请求报文。 服务器收到报文进行处理请求，并返回HTTP响应报文给浏览器。 浏览器收到HTTP响应报文后，解析响应体中的内容，并进行网页渲染，同时根据HTML中其他资源URL再次发起HTTP请求，直到网页完全加载显示。 浏览器在不需要和服务器通信时，可主动关闭TCP连接，或者等待服务器关闭请求。 使用到的协议：DNS、TCP、IP、OPSF、ARP、HTTP\n3.2 HTTP和HTTPS的区别 URL前缀不同（http和https） 端口号不同（80和443） 安全性，HTTPS大于HTTP 资源消耗：HTTP优于HTTPS SEO搜索引擎优化：优先显示HTTPS网页 ::HTTPS中的S如何实现？::\n3.3 HTTP/1.0和HTTP/1.1区别 1.1实现了长连接 1.1加入了大量状态码 1.1有更多的缓存控制机制 1.1支持断点续传 3.4 HTTP/1.1和HTTP/2.0区别 2.0实现了多路复用 2.0使用二进制帧传输（1.1使用文本格式报文） 2.0支持对头部压缩（1.1仅 支持对body压缩） 2.0支持服务器推送，可以减少客户端请求次数。 3.5 HTTP/2.0和HTTP/3.0区别 传输协议：3.0基于QUIC（UDP升级版），提供与TLS/SSL相当的安全性 连接建立：2.0需要经过TCP三次握手外加一个TLS安全握手，需约3个RTT；而3.0由于QUIC的特性，仅需要0个或1个RTT。 队头阻塞：2.0复用一个TCP连接，一旦包丢失，会阻塞所有HTTP请求。3.0一个连接有多个不同的数据流，互不影响。 错误恢复：3.0具有更快的恢复和重传机制，2.0需要依赖于TCP的错误恢复机制。 安全加密：2.0使用TLS协议进行加密，3.0基于QUIC协议，内置加密和身份验证机制，可以提供更强的安全性。 3.6 HTTP是不保存状态的协议，那么如何保存用户状态？ Session机制：通过服务端记录用户状态，时间限制到后销毁Session\nCookie中加入Session ID跟踪。\nSession 的主要作用就是通过服务端记录用户的状态。 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。\nCookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。相对来说 Session 安全性更高。如果使用 Cookie 的一些敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。\n3.7 GET和POST区别 语义：GET用于查询和获取、POST用于创建和修改 幂等：GET是幂等的，POST不是幂等的 格式：GET将参数放在URL中，POST将参数放在请求体中 缓存：GET适合缓存，POST不适合缓存，由于幂等的原因 安全性：都不安全，但是GET更不安全 4 WebSocket WebSocket是一种基于TCP连接的全双工通信协议。应用层协议，用于弥补HTTP在持久通信能力上的补足，仅需一次握手就可以创建持久性连接，并进行双向数据传输。\n工作过程\n客户端向服务端发送一个HTTP请求，包含Upgrade:websocket和Sec-webSocket-Key等字段； 服务器收到请求，如果服务器支持，则回复101状态码，表示升级到WebSocket协议 连接建立，双向传输，数据以帧的形式传输，每条消息可能会被划分为多个帧。 客户端或服务器主动发送关闭帧，接收方回复关闭帧关闭TCP连接。 Socket建立后，通过心跳机制保持连接稳定性和活跃性。\nWebSocket和Http的区别\n通信：websocket是双向实时的，而http只能由客户端主动发起。 前缀：websocket使用ww://或wws:// 扩展：websocket支持扩展 网络开销：websocket数据格式轻量，开销更小。 Websocket与SSE区别\nSSE基于HTTP协议，不需要特殊协议或服务器即可实现工作；WebSocket需要单独的服务器处理协议 SSE单向通信，只能由服务端向客户端。WebSocket全双工。 SSE实现简单，开发成本低；WebSocket传输数据需要做二次解析。 SSE默认支持断线重连，WebSocket需要自己实现。 SSE只能传送文本消息，二进制数据需要编码后传送，WebSocket默认支持传送二进制数据。 如何选择：对于游戏、即时通信以及需要双向近乎实时更新的场景，拥有双向通道更具吸引力。站内信、未读消息数、状态更新、股票行情、监控数量等场景，SEE 不管是从实现的难易和成本上都更加有优势。此外，SSE 具有 WebSocket 在设计上缺乏的多种功能，例如：自动重新连接、事件 ID 和发送任意事件的能力。 5 TCP \u0026 UDP TCP UDP 是否面向连接 是 否 是否可靠 是 否 是否有状态 是 否 传输效率 较慢 较快 传输形式 字节流 数据报文段 首部开销 20~60bytes 8bytes 支持广播/多播 否 是 5.1 TCP三次握手 过程： 客户端发送SYN(SEQ=X)标志的数据包到服务器，然后客户端进入SYN_SEND状态等待确认； 服务端发送带有SYN+ACK(SEQ=Y, ACK=X+1)标志的数据包到用户端，然后进入SYN_RECV状态； 客户端发送带有ACK(ACK=y+1)标志的数据包给服务端，然后客户端和服务端进入ESTABLISHED状态。 为什么要三次握手： 第一次握手：S确认接受正常、对方发送正常； 第二次握手：C确认发送、接受正常，对方发送、接收正常； 第三次握手：S确认对方接受正常，自己发送正常。 两次握手服务端无法确认自己消息是否被接受，四次效率较低。\n第二次握手传回了ACK为什么还要传回SYN？ ACK表示服务端确认收到客户端消息，SYN是为了建立并确认从服务端到客户端的通信。\n为什么两次握手不可以？\n避免历史连接： 假设客户端发起连接，但是该请求因为网络阻塞，没有到达服务器，此时客户端尝试重写发起，但是随后历史请求到达服务器，服务器建立连接并发送数据，客户端发现这个数据并不是此时需要的，于是RST终止连接，过了一段时间后，新的请求才到达服务器，建立起真正需要的连接。这种情况下，两次握手由于没有中间的服务器状态，无法过滤历史连接，会造成资源浪费。 **同步双方序列号：**TCP的可靠传输是基于序列号的，而双方相互确认序列号，都需要向对方发送序列号并得到确认，进一步可以优化为3次握手，而两次握手只能确认一方的序列号被对方接受。 **避免资源浪费：**与第一种情况类似（第一种情况时旧的请求先到，这种情况是旧的请求后到，导致建立无用的空连接）。 为什么不使用四次握手？\n双方建立起一个可靠的TCP连接，需要相互确认序列号，而服务器确认客户端序列号时，可以同时把自己的序列号也送出，可以减少开销。\n为什么每次建立TCP连接时，初始化的序列号都要求不一样？\n为了防止在网络中阻塞的历史报文被新的连接接受，导致数据错乱。\n为了防止黑客伪造相同序列号的TCP报文被对方接受。\n5.2 TCP四次挥手 过程： C发送FIN(SEQ=X)标志的数据包到服务端，用来关闭客户端到服务端的数据传送。客户端进入FIN-WAIT-1状态 S收到FIN(SEQ=X)标志数据包，发送ACK(ACK=X+1)标志的数据包到客户端，服务端进入CLOSE-WAIT状态，客户端进入FIN-WAIT-2状态。 服务端发送一个FIN(SEQ=Y)标志的数据包到客户端，请求关闭连接，然后服务器进入LAST-ACK状态。 客户端发送ACK(ACK=Y+1)标志的数据包给服务端，然后客户端进入TIME-WAIT状态，服务端收到后，进入CLOSE状态。此时客户端等待2MSL后依然没有收到回复，就证明服务端正常关闭，客户端关闭连接。 为什么要四次挥手： TCP全双工，任何一方发出结束通知后，会进入半关闭状态，当另一方没有数据传输时，发出关闭通知，释放连接。\n为什么不能把服务器发送的ACK和FIN结合起来，变成三次挥手？ 全双工，服务器可能还有数据要传送给客户端。\n第二次挥手时服务器的ACK没有送达客户端怎么办？ 客户端会重新发送FIN请求。\n为什么第四次挥手客户端需要等待2*MSL（报文最长寿命）后才进入CLOSE状态？ 第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。\n5.3 可靠传输 RTT：数据发送时刻到接收到确认的时刻的差值，也就是包往返时间。\nRTO：Retransmission Timeout 超时重传时间，应该略大于报文往返 RTT 的值。\n5.3.1 重传机制 基于序列号与确认应答。\n超时重传：发送数据报时，设定定时器，超过RTO后，重新发送数据，并将RTO加倍，两次超时说明网络环境较差，不宜频繁发生。 快速重传：接收方收到不按顺序传递的报文，会重复对已收到的连续报文发送确认消息，发送方连续收到三个重复的ACK后，进行重传。 SACK：选择性确认，TCP头部增加SACK选项，发送方可以收到接收方已收到的数据范围，连续收单三次相同的ACK后，进行重传，但是仅重传缺失部分。 D-SACK：重复选择性确认，可以让发送方知道是数据包丢失还是接收方的ACK包丢失。 5.3.2 滑动窗口 窗口大小指的是，无需等待确认应答，而可以继续发送数据的最大值。\n途中接收方的ACK如果丢失，可以通过下一个ACK来进行确认，也就是累计确认。\n发送方窗口\n接收方窗口\n接收窗口和发送窗口是约等于关系。\n通常窗口的大小是由接收方的窗口大小决定的。TCP头中有一个字段叫Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据接收端的处理能力来发送数据。\n5.3.3 流量控制 发送方收到ACK确认后，才可以进行窗口的移动，使得发送方可以根据接收方的实际接受能力控制发送的数据量。 TCP规定不可以同时减少缓存和收缩窗口，应先收缩窗口，后减少缓存（与操作系统的缓冲区有关） 窗口大小为0时，就会阻止发送方给接收方传递数据，知道窗口变为非零。这就是窗口关闭。针对窗口非零的通知报文丢失的问题，接收方在接收到窗口关闭的通知后，会进行发送窗口探测报文。 如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症。解决方式：发送方使用Nagle算法，延时处理，接收方不通知小窗口。 5.3.4 拥塞控制 **慢启动：**当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1（表现到每一轮数据发送和拥塞窗口大小关系上是指数增加），直到达到慢启动门限（ssthresh，slow start threshold）。 **拥塞避免：**每当收到一个 ACK 时，cwnd 增加 1/cwnd（表现到每一轮数据发送和拥塞窗口大小关系上是线性增加）。 拥塞发生： 发生超时重传时，会使用拥塞发生算法，ssthresh设置为cwnd/2，cwnd重置为1； 发生快速重传时，会将cwnd设置为cwnd/2，然后再将ssthresh设置为cwnd当前的大小，随后进入快速恢复算法。 快速恢复： 拥塞窗口cwnd = ssthresh+3； 重传丢失的数据包； 如果再收到重复的ACK，那么cwnd增加1； 如果收到新数据的ACK，那么把cwnd设置为ssthresh值，因为该ACK确认了丢失数据已经收到，恢复结束，进入拥塞避免状态。 5.4 ARQ协议 自动重传请求（Automatic Repeat-reQuest，ARQ）是 OSI 模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认信息（Acknowledgements，就是我们常说的 ACK），它通常会重新发送，直到收到确认或者重试超过一定的次数。\nARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。\n6 Ping PING 命令是一种常用的网络诊断工具，经常用来测试网络中主机之间的连通性和网络延迟。\nPING 命令的输出结果通常包括以下几部分信息：\nICMP Echo Request（请求报文）信息：序列号、TTL（Time to Live）值。 目标主机的域名或 IP 地址：输出结果的第一行。 往返时间（RTT，Round-Trip Time）：从发送 ICMP Echo Request（请求报文）到接收到 ICMP Echo Reply（响应报文）的总时间，用来衡量网络连接的延迟。 统计结果（Statistics）：包括发送的 ICMP 请求数据包数量、接收到的 ICMP 响应数据包数量、丢包率、往返时间（RTT）的最小、平均、最大和标准偏差值。 如果 PING 对应的目标主机无法得到正确的响应，则表明这两个主机之间的连通性存在问题（有些主机或网络管理员可能禁用了对 ICMP 请求的回复，这样也会导致无法得到正确的响应）。如果往返时间（RTT）过高，则表明网络延迟过高。\nPing工作原理\nPING 基于网络层的 ICMP（Internet Control Message Protocol，互联网控制报文协议），其主要原理就是通过在网络上发送和接收 ICMP 报文实现的。\nICMP 报文中包含了类型字段，用于标识 ICMP 报文类型。ICMP 报文的类型有很多种，但大致可以分为两类：\n查询报文类型：向目标主机发送请求并期望得到响应。 差错报文类型：向源主机发送错误信息，用于报告网络中的错误情况。 PING 用到的 ICMP Echo Request（类型为 8 ） 和 ICMP Echo Reply（类型为 0） 属于查询报文类型 。\nPING 命令会向目标主机发送 ICMP Echo Request。 如果两个主机的连通性正常，目标主机会返回一个对应的 ICMP Echo Reply。 7 DNS DNS（Domain Name System）域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议。DNS 要解决的是域名和 IP 地址的映射问题。\n目前 DNS 的设计采用的是分布式、层次数据库结构，DNS 是应用层协议，它可以在 UDP 或 TCP 协议之上运行，端口为 53 。\nDNS服务器有哪些\nDNS 服务器自底向上可以依次分为以下几个层级(所有 DNS 服务器都属于以下四个类别之一):\n根 DNS 服务器。根 DNS 服务器提供 TLD 服务器的 IP 地址。目前世界上只有 13 组根服务器，我国境内目前仍没有根服务器。 顶级域 DNS 服务器（TLD 服务器）。顶级域是指域名的后缀，如com、org、net和edu等。国家也有自己的顶级域，如uk、fr和ca。TLD 服务器提供了权威 DNS 服务器的 IP 地址。 权威 DNS 服务器。在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。 本地 DNS 服务器。每个 ISP（互联网服务提供商）都有一个自己的本地 DNS 服务器。当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器，它起着代理的作用，并将该请求转发到 DNS 层次结构中。严格说来，不属于 DNS 层级结构。 DNS解析过程\n迭代 递归 DNS劫持\nDNS 劫持是一种网络攻击，它通过修改 DNS 服务器的解析结果，使用户访问的域名指向错误的 IP 地址，从而导致用户无法访问正常的网站，或者被引导到恶意的网站。DNS 劫持有时也被称为 DNS 重定向、DNS 欺骗或 DNS 污染。\n8 ARP ARP 协议，全称 地址解析协议（Address Resolution Protocol），它解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。\nMAC地址长度为6字节（48bit）\nMAC 地址具有可携带性、永久性，身份证号永久地标识一个人的身份，不论他到哪里都不会改变。而 IP 地址不具有这些性质，当一台设备更换了网络，它的 IP 地址也就可能发生改变，也就是它在互联网中的定位发生了变化。\n最后，记住，MAC 地址有一个特殊地址：FF-FF-FF-FF-FF-FF（全 1 地址），该地址表示广播地址。\n工作原理 ARP 协议工作时有一个大前提，那就是 ARP 表。\n在一个局域网内，每个网络设备都自己维护了一个 ARP 表，ARP 表记录了某些其他网络设备的 IP 地址-MAC 地址映射关系，该映射关系以 三元组的形式存储。其中，TTL 为该映射关系的生存周期，典型值为 20 分钟，超过该时间，该条目将被丢弃。\nA. 同一局域网内： A 检查自己ARP表，没找到B A构造ARP查询分组（包括A的IP、MAC，B的IP、广播MAC），广播到局域网 局域网内其他设备检查自己IP是否与查询IP相同：相同则返回ARP响应（B的IP、MAC、A的IP、MAC），并在自己的ARP表中构造映射，否则丢弃。 A提取信息加入到自己ARP表中。 B. 不同局域网内MAC寻址： A查表找目标路由器，没找到 与局域网内相同的方式寻找目标路由器MAC地址。 A收到目标路由器MAC，构造IP数据报，单播发给路由器 路由器查ARP表，没找到B 路由器用ARP找B 路由器重新封装IP数据报，单播给B。 9 NAT NAT 协议（Network Address Translation） 的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，Local Area Network，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（Wide Area Network，WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。\n路由器内部运行NAT协议，维护NAT转换表。\n主机10.0.0.1向 IP 地址为128.119.40.186的 Web 服务器（端口 80）发送了 HTTP 请求（如请求页面）。此时，主机10.0.0.1将随机指派一个端口，如3345，作为本次请求的源端口号，将该请求发送到路由器中（目的地址将是128.119.40.186，但会先到达10.0.0.4）。 10.0.0.4即路由器的 LAN 接口收到10.0.0.1的请求。路由器将为该请求指派一个新的源端口号，如5001，并将请求报文发送给 WAN 接口138.76.29.7。同时，在 NAT 转换表中记录一条转换记录138.76.29.7:5001——10.0.0.1:3345。 请求报文到达 WAN 接口，继续向目的主机128.119.40.186发送。 之后，将会有如下响应发生：\n主机128.119.40.186收到请求，构造响应报文，并将其发送给目的地138.76.29.7:5001。 响应报文到达路由器的 WAN 接口。路由器查询 NAT 转换表，发现138.76.29.7:5001在转换表中有记录，从而将其目的地址和目的端口转换成为10.0.0.1:3345，再发送到10.0.0.4上。 被转换的响应报文到达路由器的 LAN 接口，继而被转发至目的地10.0.0.1。 总结 NAT 协议的特点，有以下几点：\nNAT 协议通过对 WAN 屏蔽 LAN，有效地缓解了 IPv4 地址分配压力。 LAN 主机 IP 地址的变更，无需通告 WAN。 WAN 的 ISP 变更接口地址时，无需通告 LAN 内主机。 LAN 主机对 WAN 不可见，不可直接寻址，可以保证一定程度的安全性。 10 IP IP（Internet Protocol，网际协议） 是 TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。\n目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。\n当网络设备发送 IP 数据包时，数据包中包含了 源 IP 地址 和 目的 IP 地址 。源 IP 地址用于标识数据包的发送方设备或域，而目的 IP 地址则用于标识数据包的接收方设备或域。这类似于一封邮件中同时包含了目的地地址和回邮地址。\nIPv4和IPv6 IPv4（Internet Protocol version 4） 是目前广泛使用的 IP 地址版本，其格式是四组由点分隔的数字，例如：123.89.46.72。IPv4 使用 32 位地址作为其 Internet 地址，这意味着共有约 42 亿（ 2^32）个可用 IP 地址。\nIPv6 地址使用更复杂的格式，该格式使用由单或双冒号分隔的一组数字和字母，例如：2001:0db8:85a3:0000:0000:8a2e:0370:7334 。IPv6 使用 128 位互联网地址，这意味着有 2^128（3 开头的 39 位数字，恐怖如斯） 个可用 IP 地址。\nIPv6优势： 无状态地址自动配置（Stateless Address Autoconfiguration，简称 SLAAC）：主机可以直接通过根据接口标识和网络前缀生成全局唯一的 IPv6 地址，而无需依赖 DHCP（Dynamic Host Configuration Protocol）服务器，简化了网络配置和管理。\nNAT（Network Address Translation，网络地址转换） 成为可选项：IPv6 地址资源充足，可以给全球每个设备一个独立的地址。\n对标头结构进行了改进：IPv6 标头结构相较于 IPv4 更加简化和高效，减少了处理开销，提高了网络性能。\n可选的扩展头：允许在 IPv6 标头中添加不同的扩展头（Extension Headers），用于实现不同类型的功能和选项。\nICMPv6（Internet Control Message Protocol for IPv6）：IPv6 中的 ICMPv6 相较于 IPv4 中的 ICMP 有了一些改进，如邻居发现、路径 MTU 发现等功能的改进，从而提升了网络的可靠性和性能。\n11 网络攻击 IP欺骗 SYN Flood UDP Flood Http Flood DNS Flood TCP重置攻击 中间人劫持 ","wordCount":"681","inLanguage":"en","image":"https://roaraeonliou.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-09-26T00:00:00Z","dateModified":"2024-09-26T00:00:00Z","author":{"@type":"Person","name":"RLTEA"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://roaraeonliou.github.io/posts/interviewnotes/networks/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},"publisher":{"@type":"Organization","name":"RLTEA BLOG","logo":{"@type":"ImageObject","url":"https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E"}}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["\\(","\\)"],["$","$"]]}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://roaraeonliou.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://roaraeonliou.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://roaraeonliou.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://roaraeonliou.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://roaraeonliou.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://roaraeonliou.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://roaraeonliou.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://roaraeonliou.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">计算机网络</h1><div class=post-meta><span title='2024-09-26 00:00:00 +0000 UTC'>September 26, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;681 words&nbsp;·&nbsp;RLTEA&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/InterviewNotes/Networks/%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c aria-label=计算机网络>计算机网络</a></li><li><a href=#1-%e5%88%86%e5%b1%82%e6%a8%a1%e5%9e%8b aria-label="1 分层模型">1 分层模型</a></li><li><a href=#2-%e5%b8%b8%e8%a7%81%e7%bd%91%e7%bb%9c%e5%8d%8f%e8%ae%ae aria-label="2 常见网络协议">2 常见网络协议</a></li><li><a href=#3-http aria-label="3 HTTP">3 HTTP</a><ul><li><a href=#31-%e4%bb%8e%e8%be%93%e5%85%a5url%e5%88%b0%e9%a1%b5%e9%9d%a2%e5%b1%95%e7%a4%ba%e5%8f%91%e7%94%9f%e4%ba%86%e4%bb%80%e4%b9%88 aria-label="3.1 从输入URL到页面展示发生了什么？">3.1 从输入URL到页面展示发生了什么？</a></li><li><a href=#32-http%e5%92%8chttps%e7%9a%84%e5%8c%ba%e5%88%ab aria-label="3.2 HTTP和HTTPS的区别">3.2 HTTP和HTTPS的区别</a></li><li><a href=#33-http10%e5%92%8chttp11%e5%8c%ba%e5%88%ab aria-label="3.3 HTTP/1.0和HTTP/1.1区别">3.3 HTTP/1.0和HTTP/1.1区别</a></li><li><a href=#34-http11%e5%92%8chttp20%e5%8c%ba%e5%88%ab aria-label="3.4 HTTP/1.1和HTTP/2.0区别">3.4 HTTP/1.1和HTTP/2.0区别</a></li><li><a href=#35-http20%e5%92%8chttp30%e5%8c%ba%e5%88%ab aria-label="3.5 HTTP/2.0和HTTP/3.0区别">3.5 HTTP/2.0和HTTP/3.0区别</a></li><li><a href=#36-http%e6%98%af%e4%b8%8d%e4%bf%9d%e5%ad%98%e7%8a%b6%e6%80%81%e7%9a%84%e5%8d%8f%e8%ae%ae%e9%82%a3%e4%b9%88%e5%a6%82%e4%bd%95%e4%bf%9d%e5%ad%98%e7%94%a8%e6%88%b7%e7%8a%b6%e6%80%81 aria-label="3.6 HTTP是不保存状态的协议，那么如何保存用户状态？">3.6 HTTP是不保存状态的协议，那么如何保存用户状态？</a></li><li><a href=#37-get%e5%92%8cpost%e5%8c%ba%e5%88%ab aria-label="3.7 GET和POST区别">3.7 GET和POST区别</a></li></ul></li><li><a href=#4-websocket aria-label="4 WebSocket">4 WebSocket</a><ul><ul><ul><li><a href=#%e5%a6%82%e4%bd%95%e9%80%89%e6%8b%a9%e5%af%b9%e4%ba%8e%e6%b8%b8%e6%88%8f%e5%8d%b3%e6%97%b6%e9%80%9a%e4%bf%a1%e4%bb%a5%e5%8f%8a%e9%9c%80%e8%a6%81%e5%8f%8c%e5%90%91%e8%bf%91%e4%b9%8e%e5%ae%9e%e6%97%b6%e6%9b%b4%e6%96%b0%e7%9a%84%e5%9c%ba%e6%99%af%e6%8b%a5%e6%9c%89%e5%8f%8c%e5%90%91%e9%80%9a%e9%81%93%e6%9b%b4%e5%85%b7%e5%90%b8%e5%bc%95%e5%8a%9b%e7%ab%99%e5%86%85%e4%bf%a1%e6%9c%aa%e8%af%bb%e6%b6%88%e6%81%af%e6%95%b0%e7%8a%b6%e6%80%81%e6%9b%b4%e6%96%b0%e8%82%a1%e7%a5%a8%e8%a1%8c%e6%83%85%e7%9b%91%e6%8e%a7%e6%95%b0%e9%87%8f%e7%ad%89%e5%9c%ba%e6%99%afsee-%e4%b8%8d%e7%ae%a1%e6%98%af%e4%bb%8e%e5%ae%9e%e7%8e%b0%e7%9a%84%e9%9a%be%e6%98%93%e5%92%8c%e6%88%90%e6%9c%ac%e4%b8%8a%e9%83%bd%e6%9b%b4%e5%8a%a0%e6%9c%89%e4%bc%98%e5%8a%bf%e6%ad%a4%e5%a4%96sse-%e5%85%b7%e6%9c%89-websocket-%e5%9c%a8%e8%ae%be%e8%ae%a1%e4%b8%8a%e7%bc%ba%e4%b9%8f%e7%9a%84%e5%a4%9a%e7%a7%8d%e5%8a%9f%e8%83%bd%e4%be%8b%e5%a6%82%e8%87%aa%e5%8a%a8%e9%87%8d%e6%96%b0%e8%bf%9e%e6%8e%a5%e4%ba%8b%e4%bb%b6-id-%e5%92%8c%e5%8f%91%e9%80%81%e4%bb%bb%e6%84%8f%e4%ba%8b%e4%bb%b6%e7%9a%84%e8%83%bd%e5%8a%9b aria-label="如何选择：对于游戏、即时通信以及需要双向近乎实时更新的场景，拥有双向通道更具吸引力。站内信、未读消息数、状态更新、股票行情、监控数量等场景，SEE 不管是从实现的难易和成本上都更加有优势。此外，SSE 具有 WebSocket 在设计上缺乏的多种功能，例如：自动重新连接、事件 ID 和发送任意事件的能力。">如何选择：对于游戏、即时通信以及需要双向近乎实时更新的场景，拥有双向通道更具吸引力。站内信、未读消息数、状态更新、股票行情、监控数量等场景，SEE 不管是从实现的难易和成本上都更加有优势。此外，SSE 具有 WebSocket 在设计上缺乏的多种功能，例如：自动重新连接、事件 ID 和发送任意事件的能力。</a></li></ul></ul></ul></li><li><a href=#5-tcp--udp aria-label="5 TCP & UDP">5 TCP & UDP</a><ul><li><a href=#51-tcp%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b aria-label="5.1 TCP三次握手">5.1 TCP三次握手</a><ul><ul><li><a href=#%e8%bf%87%e7%a8%8b aria-label=过程：>过程：</a></li><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b aria-label=为什么要三次握手：>为什么要三次握手：</a></li><li><a href=#%e7%ac%ac%e4%ba%8c%e6%ac%a1%e6%8f%a1%e6%89%8b%e4%bc%a0%e5%9b%9e%e4%ba%86ack%e4%b8%ba%e4%bb%80%e4%b9%88%e8%bf%98%e8%a6%81%e4%bc%a0%e5%9b%9esyn aria-label=第二次握手传回了ACK为什么还要传回SYN？>第二次握手传回了ACK为什么还要传回SYN？</a></li></ul></ul></li><li><a href=#52-tcp%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b aria-label="5.2 TCP四次挥手">5.2 TCP四次挥手</a><ul><ul><li><a href=#%e8%bf%87%e7%a8%8b-1 aria-label=过程：>过程：</a></li><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b aria-label=为什么要四次挥手：>为什么要四次挥手：</a></li><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e8%83%bd%e6%8a%8a%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%8f%91%e9%80%81%e7%9a%84ack%e5%92%8cfin%e7%bb%93%e5%90%88%e8%b5%b7%e6%9d%a5%e5%8f%98%e6%88%90%e4%b8%89%e6%ac%a1%e6%8c%a5%e6%89%8b aria-label=为什么不能把服务器发送的ACK和FIN结合起来，变成三次挥手？>为什么不能把服务器发送的ACK和FIN结合起来，变成三次挥手？</a></li><li><a href=#%e7%ac%ac%e4%ba%8c%e6%ac%a1%e6%8c%a5%e6%89%8b%e6%97%b6%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%9a%84ack%e6%b2%a1%e6%9c%89%e9%80%81%e8%be%be%e5%ae%a2%e6%88%b7%e7%ab%af%e6%80%8e%e4%b9%88%e5%8a%9e aria-label=第二次挥手时服务器的ACK没有送达客户端怎么办？>第二次挥手时服务器的ACK没有送达客户端怎么办？</a></li><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e7%ac%ac%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b%e5%ae%a2%e6%88%b7%e7%ab%af%e9%9c%80%e8%a6%81%e7%ad%89%e5%be%852msl%e6%8a%a5%e6%96%87%e6%9c%80%e9%95%bf%e5%af%bf%e5%91%bd%e5%90%8e%e6%89%8d%e8%bf%9b%e5%85%a5close%e7%8a%b6%e6%80%81 aria-label=为什么第四次挥手客户端需要等待2*MSL（报文最长寿命）后才进入CLOSE状态？>为什么第四次挥手客户端需要等待2*MSL（报文最长寿命）后才进入CLOSE状态？</a></li></ul></ul></li><li><a href=#53-%e5%8f%af%e9%9d%a0%e4%bc%a0%e8%be%93 aria-label="5.3 可靠传输">5.3 可靠传输</a><ul><li><a href=#531-%e9%87%8d%e4%bc%a0%e6%9c%ba%e5%88%b6 aria-label="5.3.1 重传机制">5.3.1 重传机制</a></li><li><a href=#532-%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3 aria-label="5.3.2 滑动窗口">5.3.2 滑动窗口</a></li><li><a href=#533-%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6 aria-label="5.3.3 流量控制">5.3.3 流量控制</a></li><li><a href=#534-%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6 aria-label="5.3.4 拥塞控制">5.3.4 拥塞控制</a></li></ul></li><li><a href=#54-arq%e5%8d%8f%e8%ae%ae aria-label="5.4 ARQ协议">5.4 ARQ协议</a></li></ul></li><li><a href=#6-ping aria-label="6 Ping">6 Ping</a></li><li><a href=#7-dns aria-label="7 DNS">7 DNS</a></li><li><a href=#8-arp aria-label="8 ARP">8 ARP</a><ul><ul><ul><li><a href=#%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86 aria-label=工作原理>工作原理</a></li><li><a href=#a-%e5%90%8c%e4%b8%80%e5%b1%80%e5%9f%9f%e7%bd%91%e5%86%85 aria-label="A. 同一局域网内：">A. 同一局域网内：</a></li><li><a href=#b-%e4%b8%8d%e5%90%8c%e5%b1%80%e5%9f%9f%e7%bd%91%e5%86%85mac%e5%af%bb%e5%9d%80 aria-label="B. 不同局域网内MAC寻址：">B. 不同局域网内MAC寻址：</a></li></ul></ul></ul></li><li><a href=#9-nat aria-label="9 NAT">9 NAT</a></li><li><a href=#10-ip aria-label="10 IP">10 IP</a><ul><ul><ul><li><a href=#ipv4%e5%92%8cipv6 aria-label=IPv4和IPv6>IPv4和IPv6</a></li><li><a href=#ipv6%e4%bc%98%e5%8a%bf aria-label=IPv6优势：>IPv6优势：</a></li></ul></ul></ul></li><li><a href=#11-%e7%bd%91%e7%bb%9c%e6%94%bb%e5%87%bb aria-label="11 网络攻击">11 网络攻击</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=计算机网络>计算机网络<a hidden class=anchor aria-hidden=true href=#计算机网络>#</a></h1><h1 id=1-分层模型>1 分层模型<a hidden class=anchor aria-hidden=true href=#1-分层模型>#</a></h1><p><strong>OSI七层模型：</strong></p><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/76dc9725b7bfb139393871234d619c6c/4678df4aa40bd122affa3ea51dd59b09.png alt=image.png></p><ul><li>口诀：<strong>物联网书会使用</strong></li><li>优点：概念结构清楚，理论完整</li><li>缺点：复杂不实用、某些功能在多个层中重复出现。</li></ul><p><strong>TCP/IP四层模型：</strong></p><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/76dc9725b7bfb139393871234d619c6c/6899e058ede579c02b961b0321f67565.png alt=image.png></p><p><strong>为什么要分层？</strong></p><ul><li>使得各层之间独立。</li><li>提高灵活性和可替换性（高内聚低耦合）。</li><li>大问题化小，复杂问题分解。</li></ul><h1 id=2-常见网络协议>2 常见网络协议<a hidden class=anchor aria-hidden=true href=#2-常见网络协议>#</a></h1><p><strong>应用层：</strong></p><ul><li>HTTP</li><li>SMTP</li><li>POP3/IMAP</li><li>FTP</li><li>Telnet</li><li>SSH</li><li>RTP</li><li>DNS</li></ul><p><strong>传输层：</strong></p><ul><li>TCP</li><li>UDP</li></ul><p><strong>网络层：</strong></p><ul><li>IP</li><li>ARP</li><li>ICMP</li><li>NAT</li><li>OSFP</li><li>RIP</li><li>BGP</li></ul><h1 id=3-http>3 HTTP<a hidden class=anchor aria-hidden=true href=#3-http>#</a></h1><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/76dc9725b7bfb139393871234d619c6c/d32d5c681e7549dee4d3dbb4173d3c65.png alt=image.png></p><h2 id=31-从输入url到页面展示发生了什么>3.1 从输入URL到页面展示发生了什么？<a hidden class=anchor aria-hidden=true href=#31-从输入url到页面展示发生了什么>#</a></h2><p><strong>过程：</strong></p><ol><li>用户输入URL。</li><li>浏览器查找域名IP地址（通过DNS：浏览器缓存、路由器缓存、DNS缓存）。</li><li>浏览器根据IP地址和端口号，向目标服务器发起TCP连接请求。</li><li>浏览器与服务器建立TCP连接，并发送HTTP请求报文。</li><li>服务器收到报文进行处理请求，并返回HTTP响应报文给浏览器。</li><li>浏览器收到HTTP响应报文后，解析响应体中的内容，并进行网页渲染，同时根据HTML中其他资源URL再次发起HTTP请求，直到网页完全加载显示。</li><li>浏览器在不需要和服务器通信时，可主动关闭TCP连接，或者等待服务器关闭请求。</li></ol><p><strong>使用到的协议：DNS、TCP、IP、OPSF、ARP、HTTP</strong></p><h2 id=32-http和https的区别>3.2 HTTP和HTTPS的区别<a hidden class=anchor aria-hidden=true href=#32-http和https的区别>#</a></h2><ul><li>URL前缀不同（http和https）</li><li>端口号不同（80和443）</li><li>安全性，HTTPS大于HTTP</li><li>资源消耗：HTTP优于HTTPS</li><li>SEO搜索引擎优化：优先显示HTTPS网页</li></ul><p><strong>::HTTPS中的S如何实现？::</strong></p><h2 id=33-http10和http11区别>3.3 HTTP/1.0和HTTP/1.1区别<a hidden class=anchor aria-hidden=true href=#33-http10和http11区别>#</a></h2><ul><li>1.1实现了长连接</li><li>1.1加入了大量状态码</li><li>1.1有更多的缓存控制机制</li><li>1.1支持断点续传</li></ul><h2 id=34-http11和http20区别>3.4 HTTP/1.1和HTTP/2.0区别<a hidden class=anchor aria-hidden=true href=#34-http11和http20区别>#</a></h2><ul><li>2.0实现了多路复用</li><li>2.0使用二进制帧传输（1.1使用文本格式报文）</li><li>2.0支持对头部压缩（1.1仅 支持对body压缩）</li><li>2.0支持服务器推送，可以减少客户端请求次数。</li></ul><h2 id=35-http20和http30区别>3.5 HTTP/2.0和HTTP/3.0区别<a hidden class=anchor aria-hidden=true href=#35-http20和http30区别>#</a></h2><ul><li><strong>传输协议</strong>：3.0基于QUIC（UDP升级版），提供与TLS/SSL相当的安全性</li><li><strong>连接建立</strong>：2.0需要经过TCP三次握手外加一个TLS安全握手，需约3个RTT；而3.0由于QUIC的特性，仅需要0个或1个RTT。</li><li><strong>队头阻塞</strong>：2.0复用一个TCP连接，一旦包丢失，会阻塞所有HTTP请求。3.0一个连接有多个不同的数据流，互不影响。</li><li><strong>错误恢复</strong>：3.0具有更快的恢复和重传机制，2.0需要依赖于TCP的错误恢复机制。</li><li><strong>安全加密</strong>：2.0使用TLS协议进行加密，3.0基于QUIC协议，内置加密和身份验证机制，可以提供更强的安全性。</li></ul><h2 id=36-http是不保存状态的协议那么如何保存用户状态>3.6 HTTP是不保存状态的协议，那么如何保存用户状态？<a hidden class=anchor aria-hidden=true href=#36-http是不保存状态的协议那么如何保存用户状态>#</a></h2><p>Session机制：通过服务端记录用户状态，时间限制到后销毁Session</p><p>Cookie中加入Session ID跟踪。</p><p><code>Session</code> <strong>的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 <code>Session</code> 之后就可以标识这个用户并且跟踪这个用户了。</p><p><code>Cookie</code> 数据保存在客户端(浏览器端)，<code>Session</code> 数据保存在服务器端。相对来说 <code>Session</code> 安全性更高。如果使用 <code>Cookie</code> 的一些敏感信息不要写入 <code>Cookie</code> 中，最好能将 <code>Cookie</code> 信息加密然后使用到的时候再去服务器端解密。</p><h2 id=37-get和post区别>3.7 GET和POST区别<a hidden class=anchor aria-hidden=true href=#37-get和post区别>#</a></h2><ul><li>语义：GET用于查询和获取、POST用于创建和修改</li><li>幂等：GET是幂等的，POST不是幂等的</li><li>格式：GET将参数放在URL中，POST将参数放在请求体中</li><li>缓存：GET适合缓存，POST不适合缓存，由于幂等的原因</li><li>安全性：都不安全，但是GET更不安全</li></ul><h1 id=4-websocket>4 WebSocket<a hidden class=anchor aria-hidden=true href=#4-websocket>#</a></h1><p>WebSocket是一种基于TCP连接的全双工通信协议。应用层协议，用于弥补HTTP在持久通信能力上的补足，仅需一次握手就可以创建持久性连接，并进行双向数据传输。</p><p><strong>工作过程</strong></p><ol><li>客户端向服务端发送一个HTTP请求，包含Upgrade:websocket和Sec-webSocket-Key等字段；</li><li>服务器收到请求，如果服务器支持，则回复101状态码，表示升级到WebSocket协议</li><li>连接建立，双向传输，数据以帧的形式传输，每条消息可能会被划分为多个帧。</li><li>客户端或服务器主动发送关闭帧，接收方回复关闭帧关闭TCP连接。</li></ol><p>Socket建立后，通过心跳机制保持连接稳定性和活跃性。</p><p><strong>WebSocket和Http的区别</strong></p><ul><li>通信：websocket是双向实时的，而http只能由客户端主动发起。</li><li>前缀：websocket使用ww://或wws://</li><li>扩展：websocket支持扩展</li><li>网络开销：websocket数据格式轻量，开销更小。</li></ul><p><strong>Websocket与SSE区别</strong></p><ul><li>SSE基于HTTP协议，不需要特殊协议或服务器即可实现工作；WebSocket需要单独的服务器处理协议</li><li>SSE单向通信，只能由服务端向客户端。WebSocket全双工。</li><li>SSE实现简单，开发成本低；WebSocket传输数据需要做二次解析。</li><li>SSE默认支持断线重连，WebSocket需要自己实现。</li><li>SSE只能传送文本消息，二进制数据需要编码后传送，WebSocket默认支持传送二进制数据。</li></ul><h4 id=如何选择对于游戏即时通信以及需要双向近乎实时更新的场景拥有双向通道更具吸引力站内信未读消息数状态更新股票行情监控数量等场景see-不管是从实现的难易和成本上都更加有优势此外sse-具有-websocket-在设计上缺乏的多种功能例如自动重新连接事件-id-和发送任意事件的能力>如何选择：对于游戏、即时通信以及需要双向近乎实时更新的场景，拥有双向通道更具吸引力。站内信、未读消息数、状态更新、股票行情、监控数量等场景，SEE 不管是从实现的难易和成本上都更加有优势。此外，SSE 具有 WebSocket 在设计上缺乏的多种功能，例如：自动重新连接、事件 ID 和发送任意事件的能力。<a hidden class=anchor aria-hidden=true href=#如何选择对于游戏即时通信以及需要双向近乎实时更新的场景拥有双向通道更具吸引力站内信未读消息数状态更新股票行情监控数量等场景see-不管是从实现的难易和成本上都更加有优势此外sse-具有-websocket-在设计上缺乏的多种功能例如自动重新连接事件-id-和发送任意事件的能力>#</a></h4><h1 id=5-tcp--udp>5 TCP & UDP<a hidden class=anchor aria-hidden=true href=#5-tcp--udp>#</a></h1><table><thead><tr><th style=text-align:left></th><th style=text-align:left><strong>TCP</strong></th><th style=text-align:left><strong>UDP</strong></th></tr></thead><tbody><tr><td style=text-align:left><strong>是否面向连接</strong></td><td style=text-align:left>是</td><td style=text-align:left>否</td></tr><tr><td style=text-align:left><strong>是否可靠</strong></td><td style=text-align:left>是</td><td style=text-align:left>否</td></tr><tr><td style=text-align:left><strong>是否有状态</strong></td><td style=text-align:left>是</td><td style=text-align:left>否</td></tr><tr><td style=text-align:left><strong>传输效率</strong></td><td style=text-align:left>较慢</td><td style=text-align:left>较快</td></tr><tr><td style=text-align:left><strong>传输形式</strong></td><td style=text-align:left>字节流</td><td style=text-align:left>数据报文段</td></tr><tr><td style=text-align:left><strong>首部开销</strong></td><td style=text-align:left>20~60bytes</td><td style=text-align:left>8bytes</td></tr><tr><td style=text-align:left><strong>支持广播/多播</strong></td><td style=text-align:left>否</td><td style=text-align:left>是</td></tr></tbody></table><h2 id=51-tcp三次握手>5.1 TCP三次握手<a hidden class=anchor aria-hidden=true href=#51-tcp三次握手>#</a></h2><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/76dc9725b7bfb139393871234d619c6c/659216500ba4d758739cf84c27432ec7.png alt=image.png></p><h4 id=过程>过程：<a hidden class=anchor aria-hidden=true href=#过程>#</a></h4><ol><li>客户端发送SYN(SEQ=X)标志的数据包到服务器，然后客户端进入SYN_SEND状态等待确认；</li><li>服务端发送带有SYN+ACK(SEQ=Y, ACK=X+1)标志的数据包到用户端，然后进入SYN_RECV状态；</li><li>客户端发送带有ACK(ACK=y+1)标志的数据包给服务端，然后客户端和服务端进入ESTABLISHED状态。</li></ol><h4 id=为什么要三次握手>为什么要三次握手：<a hidden class=anchor aria-hidden=true href=#为什么要三次握手>#</a></h4><ol><li>第一次握手：S确认接受正常、对方发送正常；</li><li>第二次握手：C确认发送、接受正常，对方发送、接收正常；</li><li>第三次握手：S确认对方接受正常，自己发送正常。</li></ol><p>两次握手服务端无法确认自己消息是否被接受，四次效率较低。</p><h4 id=第二次握手传回了ack为什么还要传回syn>第二次握手传回了ACK为什么还要传回SYN？<a hidden class=anchor aria-hidden=true href=#第二次握手传回了ack为什么还要传回syn>#</a></h4><p>ACK表示服务端确认收到客户端消息，SYN是为了建立并确认从服务端到客户端的通信。</p><p><strong>为什么两次握手不可以？</strong></p><ol><li><strong>避免历史连接：</strong> 假设客户端发起连接，但是该请求因为网络阻塞，没有到达服务器，此时客户端尝试重写发起，但是随后历史请求到达服务器，服务器建立连接并发送数据，客户端发现这个数据并不是此时需要的，于是RST终止连接，过了一段时间后，新的请求才到达服务器，建立起真正需要的连接。这种情况下，两次握手由于没有中间的服务器状态，无法过滤历史连接，会造成资源浪费。</li><li>**同步双方序列号：**TCP的可靠传输是基于序列号的，而双方相互确认序列号，都需要向对方发送序列号并得到确认，进一步可以优化为3次握手，而两次握手只能确认一方的序列号被对方接受。</li><li>**避免资源浪费：**与第一种情况类似（第一种情况时旧的请求先到，这种情况是旧的请求后到，导致建立无用的空连接）。</li></ol><p><strong>为什么不使用四次握手？</strong></p><p>双方建立起一个可靠的TCP连接，需要相互确认序列号，而服务器确认客户端序列号时，可以同时把自己的序列号也送出，可以减少开销。</p><p><strong>为什么每次建立TCP连接时，初始化的序列号都要求不一样？</strong></p><p>为了防止在网络中阻塞的历史报文被新的连接接受，导致数据错乱。</p><p>为了防止黑客伪造相同序列号的TCP报文被对方接受。</p><h2 id=52-tcp四次挥手>5.2 TCP四次挥手<a hidden class=anchor aria-hidden=true href=#52-tcp四次挥手>#</a></h2><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/76dc9725b7bfb139393871234d619c6c/d74d83942eeebfb6c391d25764b2ba7d.png alt=image.png></p><h4 id=过程-1>过程：<a hidden class=anchor aria-hidden=true href=#过程-1>#</a></h4><ol><li>C发送FIN(SEQ=X)标志的数据包到服务端，用来关闭客户端到服务端的数据传送。客户端进入FIN-WAIT-1状态</li><li>S收到FIN(SEQ=X)标志数据包，发送ACK(ACK=X+1)标志的数据包到客户端，服务端进入CLOSE-WAIT状态，客户端进入FIN-WAIT-2状态。</li><li>服务端发送一个FIN(SEQ=Y)标志的数据包到客户端，请求关闭连接，然后服务器进入LAST-ACK状态。</li><li>客户端发送ACK(ACK=Y+1)标志的数据包给服务端，然后客户端进入TIME-WAIT状态，服务端收到后，进入CLOSE状态。此时客户端等待2MSL后依然没有收到回复，就证明服务端正常关闭，客户端关闭连接。</li></ol><h4 id=为什么要四次挥手>为什么要四次挥手：<a hidden class=anchor aria-hidden=true href=#为什么要四次挥手>#</a></h4><p>TCP全双工，任何一方发出结束通知后，会进入半关闭状态，当另一方没有数据传输时，发出关闭通知，释放连接。</p><h4 id=为什么不能把服务器发送的ack和fin结合起来变成三次挥手>为什么不能把服务器发送的ACK和FIN结合起来，变成三次挥手？<a hidden class=anchor aria-hidden=true href=#为什么不能把服务器发送的ack和fin结合起来变成三次挥手>#</a></h4><p>全双工，服务器可能还有数据要传送给客户端。</p><h4 id=第二次挥手时服务器的ack没有送达客户端怎么办>第二次挥手时服务器的ACK没有送达客户端怎么办？<a hidden class=anchor aria-hidden=true href=#第二次挥手时服务器的ack没有送达客户端怎么办>#</a></h4><p>客户端会重新发送FIN请求。</p><h4 id=为什么第四次挥手客户端需要等待2msl报文最长寿命后才进入close状态>为什么第四次挥手客户端需要等待2*MSL（报文最长寿命）后才进入CLOSE状态？<a hidden class=anchor aria-hidden=true href=#为什么第四次挥手客户端需要等待2msl报文最长寿命后才进入close状态>#</a></h4><p>第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。</p><h2 id=53-可靠传输>5.3 可靠传输<a hidden class=anchor aria-hidden=true href=#53-可靠传输>#</a></h2><p>RTT：<strong>数据发送时刻到接收到确认的时刻的差值，也就是包往返时间。</strong></p><p>RTO：Retransmission Timeout 超时重传时间，<strong>应该略大于报文往返 RTT 的值</strong>。</p><h3 id=531-重传机制>5.3.1 重传机制<a hidden class=anchor aria-hidden=true href=#531-重传机制>#</a></h3><p>基于序列号与确认应答。</p><ul><li>超时重传：发送数据报时，设定定时器，超过RTO后，重新发送数据，并将RTO加倍，两次超时说明网络环境较差，不宜频繁发生。</li><li>快速重传：接收方收到不按顺序传递的报文，会重复对已收到的连续报文发送确认消息，发送方连续收到三个重复的ACK后，进行重传。</li><li>SACK：选择性确认，TCP头部增加SACK选项，发送方可以收到接收方已收到的数据范围，连续收单三次相同的ACK后，进行重传，但是仅重传缺失部分。</li><li>D-SACK：重复选择性确认，可以让发送方知道是数据包丢失还是接收方的ACK包丢失。</li></ul><h3 id=532-滑动窗口>5.3.2 滑动窗口<a hidden class=anchor aria-hidden=true href=#532-滑动窗口>#</a></h3><p>窗口大小指的是，无需等待确认应答，而可以继续发送数据的最大值。</p><p>途中接收方的ACK如果丢失，可以通过下一个ACK来进行确认，也就是<strong>累计确认</strong>。</p><p><strong>发送方窗口</strong></p><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/76dc9725b7bfb139393871234d619c6c/311eb9d7e5fe0a36bfe5a1a5a42f9c27.png alt=image.png></p><p><strong>接收方窗口</strong></p><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/76dc9725b7bfb139393871234d619c6c/94e1a3cdefc1b4da3bc77188a8c16772.png alt=image.png></p><p>接收窗口和发送窗口是约等于关系。</p><p>通常窗口的大小是由接收方的窗口大小决定的。TCP头中有一个字段叫Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据接收端的处理能力来发送数据。</p><h3 id=533-流量控制>5.3.3 流量控制<a hidden class=anchor aria-hidden=true href=#533-流量控制>#</a></h3><ol><li>发送方收到ACK确认后，才可以进行窗口的移动，使得发送方可以根据接收方的实际接受能力控制发送的数据量。</li><li>TCP规定不可以同时减少缓存和收缩窗口，应先收缩窗口，后减少缓存（与操作系统的缓冲区有关）</li><li>窗口大小为0时，就会阻止发送方给接收方传递数据，知道窗口变为非零。这就是<strong>窗口关闭</strong>。针对窗口非零的通知报文丢失的问题，接收方在接收到窗口关闭的通知后，会进行发送窗口探测报文。</li><li>如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是<strong>糊涂窗口综合症</strong>。解决方式：发送方使用Nagle算法，延时处理，接收方不通知小窗口。</li></ol><h3 id=534-拥塞控制>5.3.4 拥塞控制<a hidden class=anchor aria-hidden=true href=#534-拥塞控制>#</a></h3><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/76dc9725b7bfb139393871234d619c6c/dc8e77c75c924df48919f4ef09b8ef65.png alt=image.png></p><ul><li>**慢启动：**当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1（表现到每一轮数据发送和拥塞窗口大小关系上是指数增加），直到达到慢启动门限（ssthresh，slow start threshold）。</li><li>**拥塞避免：**每当收到一个 ACK 时，cwnd 增加 1/cwnd（表现到每一轮数据发送和拥塞窗口大小关系上是线性增加）。</li><li><strong>拥塞发生：</strong><ul><li>发生超时重传时，会使用拥塞发生算法，ssthresh设置为cwnd/2，cwnd重置为1；</li><li>发生快速重传时，会将cwnd设置为cwnd/2，然后再将ssthresh设置为cwnd当前的大小，随后进入快速恢复算法。</li></ul></li><li><strong>快速恢复：</strong><ul><li>拥塞窗口cwnd = ssthresh+3；</li><li>重传丢失的数据包；</li><li>如果再收到重复的ACK，那么cwnd增加1；</li><li>如果收到新数据的ACK，那么把cwnd设置为ssthresh值，因为该ACK确认了丢失数据已经收到，恢复结束，进入拥塞避免状态。</li></ul></li></ul><h2 id=54-arq协议>5.4 ARQ协议<a hidden class=anchor aria-hidden=true href=#54-arq协议>#</a></h2><p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是 OSI 模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认信息（Acknowledgements，就是我们常说的 ACK），它通常会重新发送，直到收到确认或者重试超过一定的次数。</p><p>ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。</p><h1 id=6-ping>6 Ping<a hidden class=anchor aria-hidden=true href=#6-ping>#</a></h1><p>PING 命令是一种常用的网络诊断工具，经常用来测试网络中主机之间的连通性和网络延迟。</p><p>PING 命令的输出结果通常包括以下几部分信息：</p><ol><li><strong>ICMP Echo Request（请求报文）信息</strong>：序列号、TTL（Time to Live）值。</li><li><strong>目标主机的域名或 IP 地址</strong>：输出结果的第一行。</li><li><strong>往返时间（RTT，Round-Trip Time）</strong>：从发送 ICMP Echo Request（请求报文）到接收到 ICMP Echo Reply（响应报文）的总时间，用来衡量网络连接的延迟。</li><li><strong>统计结果（Statistics）</strong>：包括发送的 ICMP 请求数据包数量、接收到的 ICMP 响应数据包数量、丢包率、往返时间（RTT）的最小、平均、最大和标准偏差值。</li></ol><p>如果 PING 对应的目标主机无法得到正确的响应，则表明这两个主机之间的连通性存在问题（有些主机或网络管理员可能禁用了对 ICMP 请求的回复，这样也会导致无法得到正确的响应）。如果往返时间（RTT）过高，则表明网络延迟过高。</p><p><strong>Ping工作原理</strong></p><p>PING 基于网络层的 <strong>ICMP（Internet Control Message Protocol，互联网控制报文协议）</strong>，其主要原理就是通过在网络上发送和接收 ICMP 报文实现的。</p><p>ICMP 报文中包含了类型字段，用于标识 ICMP 报文类型。ICMP 报文的类型有很多种，但大致可以分为两类：</p><ul><li><strong>查询报文类型</strong>：向目标主机发送请求并期望得到响应。</li><li><strong>差错报文类型</strong>：向源主机发送错误信息，用于报告网络中的错误情况。</li></ul><p>PING 用到的 ICMP Echo Request（类型为 8 ） 和 ICMP Echo Reply（类型为 0） 属于查询报文类型 。</p><ul><li>PING 命令会向目标主机发送 ICMP Echo Request。</li><li>如果两个主机的连通性正常，目标主机会返回一个对应的 ICMP Echo Reply。</li></ul><h1 id=7-dns>7 DNS<a hidden class=anchor aria-hidden=true href=#7-dns>#</a></h1><p>DNS（Domain Name System）域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议。DNS 要解决的是<strong>域名和 IP 地址的映射问题</strong>。</p><p>目前 DNS 的设计采用的是分布式、层次数据库结构，<strong>DNS 是应用层协议，它可以在 UDP 或 TCP 协议之上运行，端口为 53</strong> 。</p><p><strong>DNS服务器有哪些</strong></p><p>DNS 服务器自底向上可以依次分为以下几个层级(所有 DNS 服务器都属于以下四个类别之一):</p><ul><li>根 DNS 服务器。根 DNS 服务器提供 TLD 服务器的 IP 地址。目前世界上只有 13 组根服务器，我国境内目前仍没有根服务器。</li><li>顶级域 DNS 服务器（TLD 服务器）。顶级域是指域名的后缀，如<code>com</code>、<code>org</code>、<code>net</code>和<code>edu</code>等。国家也有自己的顶级域，如<code>uk</code>、<code>fr</code>和<code>ca</code>。TLD 服务器提供了权威 DNS 服务器的 IP 地址。</li><li>权威 DNS 服务器。在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。</li><li>本地 DNS 服务器。每个 ISP（互联网服务提供商）都有一个自己的本地 DNS 服务器。当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器，它起着代理的作用，并将该请求转发到 DNS 层次结构中。严格说来，不属于 DNS 层级结构。</li></ul><p><strong>DNS解析过程</strong></p><ul><li>迭代</li><li>递归</li></ul><p><strong>DNS劫持</strong></p><p>DNS 劫持是一种网络攻击，它通过修改 DNS 服务器的解析结果，使用户访问的域名指向错误的 IP 地址，从而导致用户无法访问正常的网站，或者被引导到恶意的网站。DNS 劫持有时也被称为 DNS 重定向、DNS 欺骗或 DNS 污染。</p><h1 id=8-arp>8 ARP<a hidden class=anchor aria-hidden=true href=#8-arp>#</a></h1><p>ARP 协议，全称 <strong>地址解析协议（Address Resolution Protocol）</strong>，它解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。</p><p>MAC地址长度为6字节（48bit）</p><p>MAC 地址具有可携带性、永久性，身份证号永久地标识一个人的身份，不论他到哪里都不会改变。而 IP 地址不具有这些性质，当一台设备更换了网络，它的 IP 地址也就可能发生改变，也就是它在互联网中的定位发生了变化。</p><p>最后，记住，MAC 地址有一个特殊地址：FF-FF-FF-FF-FF-FF（全 1 地址），该地址表示广播地址。</p><h4 id=工作原理>工作原理<a hidden class=anchor aria-hidden=true href=#工作原理>#</a></h4><p>ARP 协议工作时有一个大前提，那就是 <strong>ARP 表</strong>。</p><p>在一个局域网内，每个网络设备都自己维护了一个 ARP 表，ARP 表记录了某些其他网络设备的 IP 地址-MAC 地址映射关系，该映射关系以 <code>&lt;IP, MAC, TTL></code> 三元组的形式存储。其中，TTL 为该映射关系的生存周期，典型值为 20 分钟，超过该时间，该条目将被丢弃。</p><h4 id=a-同一局域网内>A. 同一局域网内：<a hidden class=anchor aria-hidden=true href=#a-同一局域网内>#</a></h4><ol><li>A 检查自己ARP表，没找到B</li><li>A构造ARP查询分组（包括A的IP、MAC，B的IP、广播MAC），广播到局域网</li><li>局域网内其他设备检查自己IP是否与查询IP相同：相同则返回ARP响应（B的IP、MAC、A的IP、MAC），并在自己的ARP表中构造映射，否则丢弃。</li><li>A提取信息加入到自己ARP表中。</li></ol><h4 id=b-不同局域网内mac寻址>B. 不同局域网内MAC寻址：<a hidden class=anchor aria-hidden=true href=#b-不同局域网内mac寻址>#</a></h4><ol><li>A查表找目标路由器，没找到</li><li>与局域网内相同的方式寻找目标路由器MAC地址。</li><li>A收到目标路由器MAC，构造IP数据报，单播发给路由器</li><li>路由器查ARP表，没找到B</li><li>路由器用ARP找B</li><li>路由器重新封装IP数据报，单播给B。</li></ol><h1 id=9-nat>9 NAT<a hidden class=anchor aria-hidden=true href=#9-nat>#</a></h1><p><strong>NAT 协议（Network Address Translation）</strong> 的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，Local Area Network，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（Wide Area Network，WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。</p><p>路由器内部运行NAT协议，维护NAT转换表。</p><ol><li>主机<code>10.0.0.1</code>向 IP 地址为<code>128.119.40.186</code>的 Web 服务器（端口 80）发送了 HTTP 请求（如请求页面）。此时，主机<code>10.0.0.1</code>将随机指派一个端口，如<code>3345</code>，作为本次请求的源端口号，将该请求发送到路由器中（目的地址将是<code>128.119.40.186</code>，但会先到达<code>10.0.0.4</code>）。</li><li><code>10.0.0.4</code>即路由器的 LAN 接口收到<code>10.0.0.1</code>的请求。路由器将为该请求指派一个新的源端口号，如<code>5001</code>，并将请求报文发送给 WAN 接口<code>138.76.29.7</code>。同时，在 NAT 转换表中记录一条转换记录<strong>138.76.29.7:5001——10.0.0.1:3345</strong>。</li><li>请求报文到达 WAN 接口，继续向目的主机<code>128.119.40.186</code>发送。</li></ol><p>之后，将会有如下响应发生：</p><ol><li>主机<code>128.119.40.186</code>收到请求，构造响应报文，并将其发送给目的地<code>138.76.29.7:5001</code>。</li><li>响应报文到达路由器的 WAN 接口。路由器查询 NAT 转换表，发现<code>138.76.29.7:5001</code>在转换表中有记录，从而将其目的地址和目的端口转换成为<code>10.0.0.1:3345</code>，再发送到<code>10.0.0.4</code>上。</li><li>被转换的响应报文到达路由器的 LAN 接口，继而被转发至目的地<code>10.0.0.1</code>。</li></ol><p>总结 NAT 协议的特点，有以下几点：</p><ol><li>NAT 协议通过对 WAN 屏蔽 LAN，有效地缓解了 IPv4 地址分配压力。</li><li>LAN 主机 IP 地址的变更，无需通告 WAN。</li><li>WAN 的 ISP 变更接口地址时，无需通告 LAN 内主机。</li><li>LAN 主机对 WAN 不可见，不可直接寻址，可以保证一定程度的安全性。</li></ol><h1 id=10-ip>10 IP<a hidden class=anchor aria-hidden=true href=#10-ip>#</a></h1><p><strong>IP（Internet Protocol，网际协议）</strong> 是 TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。</p><p>目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。</p><p>当网络设备发送 IP 数据包时，数据包中包含了 <strong>源 IP 地址</strong> 和 <strong>目的 IP 地址</strong> 。源 IP 地址用于标识数据包的发送方设备或域，而目的 IP 地址则用于标识数据包的接收方设备或域。这类似于一封邮件中同时包含了目的地地址和回邮地址。</p><h4 id=ipv4和ipv6>IPv4和IPv6<a hidden class=anchor aria-hidden=true href=#ipv4和ipv6>#</a></h4><p><strong>IPv4（Internet Protocol version 4）</strong> 是目前广泛使用的 IP 地址版本，其格式是四组由点分隔的数字，例如：123.89.46.72。IPv4 使用 32 位地址作为其 Internet 地址，这意味着共有约 42 亿（ 2^32）个可用 IP 地址。</p><p><strong>IPv6</strong> 地址使用更复杂的格式，该格式使用由单或双冒号分隔的一组数字和字母，例如：2001:0db8:85a3:0000:0000:8a2e:0370:7334 。IPv6 使用 128 位互联网地址，这意味着有 2^128（3 开头的 39 位数字，恐怖如斯） 个可用 IP 地址。</p><h4 id=ipv6优势>IPv6优势：<a hidden class=anchor aria-hidden=true href=#ipv6优势>#</a></h4><p><strong>无状态地址自动配置（Stateless Address Autoconfiguration，简称 SLAAC）</strong>：主机可以直接通过根据接口标识和网络前缀生成全局唯一的 IPv6 地址，而无需依赖 DHCP（Dynamic Host Configuration Protocol）服务器，简化了网络配置和管理。</p><p><strong>NAT（Network Address Translation，网络地址转换） 成为可选项</strong>：IPv6 地址资源充足，可以给全球每个设备一个独立的地址。</p><p><strong>对标头结构进行了改进</strong>：IPv6 标头结构相较于 IPv4 更加简化和高效，减少了处理开销，提高了网络性能。</p><p><strong>可选的扩展头</strong>：允许在 IPv6 标头中添加不同的扩展头（Extension Headers），用于实现不同类型的功能和选项。</p><p><strong>ICMPv6（Internet Control Message Protocol for IPv6）</strong>：IPv6 中的 ICMPv6 相较于 IPv4 中的 ICMP 有了一些改进，如邻居发现、路径 MTU 发现等功能的改进，从而提升了网络的可靠性和性能。</p><h1 id=11-网络攻击>11 网络攻击<a hidden class=anchor aria-hidden=true href=#11-网络攻击>#</a></h1><ul><li>IP欺骗</li><li>SYN Flood</li><li>UDP Flood</li><li>Http Flood</li><li>DNS Flood</li><li>TCP重置攻击</li><li>中间人劫持</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://roaraeonliou.github.io/tags/%E7%AC%94%E8%AE%B0/>笔记</a></li><li><a href=https://roaraeonliou.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/>计算机网络</a></li></ul><nav class=paginav><a class=prev href=https://roaraeonliou.github.io/posts/interviewnotes/designmode/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/><span class=title>« Prev</span><br><span>行为型模式</span>
</a><a class=next href=https://roaraeonliou.github.io/posts/interviewnotes/designmode/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8Euml%E7%B1%BB%E5%9B%BE/><span class=title>Next »</span><br><span>软件设计原则与UML类图</span></a></nav></footer><div id=comments><script src=https://giscus.app/client.js data-repo=RoaraeonLiou/roaraeonliou.github.io data-repo-id=R_kgDOMIxQ4w data-category=Announcements data-category-id=DIC_kwDOMIxQ484CgZUR data-mapping=title data-strict=1 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2024 <a href=https://roaraeonliou.github.io/>RLTEA BLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>