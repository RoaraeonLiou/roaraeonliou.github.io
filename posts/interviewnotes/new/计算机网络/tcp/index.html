<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>TCP | RLTEA BLOG</title>
<meta name=keywords content><meta name=description content="1 TCP基础
1.1 头部字段


序列号：建立时生成随机数，后续每发送一次数据加一，用于解决网络包乱序的问题
确认应答号：表示下一次「期待」收到的序列号，发送端收到这个确认应答后认为在这个序列号之前的数据都被正常接受，用来解决丢包问题
控制位：

ACK：为1表示「确认应答」字段有效，除SYN包之外该位必须设置为1
RST：为1表示TCP连接异常，强制断开
SYN：为1时表示希望建立连接，并初始化「序列号」
FIN：为1时表示之后不会再有数据发送，表示希望断开连接



1.2 TCP的特点

面向连接：一对一建立连接，通过「源地址，源端口，目的地址，目的端口」确定唯一连接
可靠：TCP协议尽自己最大努力保证报文一定能够到达接收端
字节流：通过TCP传输的数据，可能会被操作系统拆分为多个TCP报文，如果接收方不知道「消息边界」就无法正确读取消息。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。

2 TCP三次握手
2.1 三次握手如何建立


首先，客户端和服务器都处于close状态，然后服务器主动监听某个端口，处于Listen状态。
客户端随机初始化序号，同时把SYN标识为设为1，表示SYN报文，把SYN送给服务端后，变换为SYN-SENT状态。
服务端收到客户端的SYN报文后，随机初始化自己的序号，同时把确认应答号设置为客户端初始序号+1，然后把SYN和ACK标识为设置为1，最后送给客户端，变换为SYN-RCVD状态。
客户端收到服务端报文后，向服务器回应最后一个应答报文，将ACK标识为设置为1，确认应答号填入服务器初始序号+1，这次报文可以携带数据，然后送给服务端，状态变化为ESTABLISHED。
服务器收到应答报文后，状态也设置为ESTABLISHED。

2.2 如何在Linux中查看TCP状态
netstat -napt
2.3 为什么是三次握手？而不是两次、四次?

三次的原因：

三次可以阻止重复历史连接的初始化： 两次握手对于新旧TCP连接请提无法避免初始化步骤。
三次可以同步双方的初始序列号：可以保证双方初始的序列号被可靠的同步给对方，四次握手没有必要，服务器确认和初始化自己的两步可以合并为一步。
三次可以避免浪费资源：两次握手由于服务器没有中间状态，无法知道客户端是否收到自己回复的ACK，所以每收到一个SYN报文就需要建立一个连接，同一个连接由于网络阻塞而重发SYN报文时，服务端会产生资源浪费。


为什么每次建立TCP连接初始化序列号都要求不同：

为了防止历史报文被下一个相同四元组接受。
为了安全性， 防止黑客伪造TCP报文。



2.4 IP层即然会分片，为什么TCP还需要MSS呢？


MTU：指的是一个网络包的最大长度，以太网中一般为1500字节
MSS：除去IP和TCP头部之后，一个网络包能容纳的TCP数据的最大长度

当IP层有一个超过MTU大小的数据要发送时，IP层就要进行分片，但是当一个分片丢失时，整个IP报文就需要重传，因为IP层没有超时重传机制，所以为了达到最佳的传输效率，建立TCP连接时通常需要协商双方的MSS值，当TCP层发现报文超过MSS时，就会进行分片，保证在IP层形成的IP包长度不会大于MTU，所以也就不会分片了。
2.5 三次握手信息丢失会发生什么


第一次握手丢失"><meta name=author content="RLTEA"><link rel=canonical href=https://roaraeonliou.github.io/posts/interviewnotes/new/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcp/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.258803b0f0cc9a4a109c6fe78a9d39f2e0437217d71c5c9848255af9250f2b1b.css integrity="sha256-JYgDsPDMmkoQnG/nip058uBDchfXHFyYSCVa+SUPKxs=" rel="preload stylesheet" as=style><link rel=icon href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://roaraeonliou.github.io/posts/interviewnotes/new/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcp/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="TCP"><meta property="og:description" content="1 TCP基础
1.1 头部字段


序列号：建立时生成随机数，后续每发送一次数据加一，用于解决网络包乱序的问题
确认应答号：表示下一次「期待」收到的序列号，发送端收到这个确认应答后认为在这个序列号之前的数据都被正常接受，用来解决丢包问题
控制位：

ACK：为1表示「确认应答」字段有效，除SYN包之外该位必须设置为1
RST：为1表示TCP连接异常，强制断开
SYN：为1时表示希望建立连接，并初始化「序列号」
FIN：为1时表示之后不会再有数据发送，表示希望断开连接



1.2 TCP的特点

面向连接：一对一建立连接，通过「源地址，源端口，目的地址，目的端口」确定唯一连接
可靠：TCP协议尽自己最大努力保证报文一定能够到达接收端
字节流：通过TCP传输的数据，可能会被操作系统拆分为多个TCP报文，如果接收方不知道「消息边界」就无法正确读取消息。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。

2 TCP三次握手
2.1 三次握手如何建立


首先，客户端和服务器都处于close状态，然后服务器主动监听某个端口，处于Listen状态。
客户端随机初始化序号，同时把SYN标识为设为1，表示SYN报文，把SYN送给服务端后，变换为SYN-SENT状态。
服务端收到客户端的SYN报文后，随机初始化自己的序号，同时把确认应答号设置为客户端初始序号+1，然后把SYN和ACK标识为设置为1，最后送给客户端，变换为SYN-RCVD状态。
客户端收到服务端报文后，向服务器回应最后一个应答报文，将ACK标识为设置为1，确认应答号填入服务器初始序号+1，这次报文可以携带数据，然后送给服务端，状态变化为ESTABLISHED。
服务器收到应答报文后，状态也设置为ESTABLISHED。

2.2 如何在Linux中查看TCP状态
netstat -napt
2.3 为什么是三次握手？而不是两次、四次?

三次的原因：

三次可以阻止重复历史连接的初始化： 两次握手对于新旧TCP连接请提无法避免初始化步骤。
三次可以同步双方的初始序列号：可以保证双方初始的序列号被可靠的同步给对方，四次握手没有必要，服务器确认和初始化自己的两步可以合并为一步。
三次可以避免浪费资源：两次握手由于服务器没有中间状态，无法知道客户端是否收到自己回复的ACK，所以每收到一个SYN报文就需要建立一个连接，同一个连接由于网络阻塞而重发SYN报文时，服务端会产生资源浪费。


为什么每次建立TCP连接初始化序列号都要求不同：

为了防止历史报文被下一个相同四元组接受。
为了安全性， 防止黑客伪造TCP报文。



2.4 IP层即然会分片，为什么TCP还需要MSS呢？


MTU：指的是一个网络包的最大长度，以太网中一般为1500字节
MSS：除去IP和TCP头部之后，一个网络包能容纳的TCP数据的最大长度

当IP层有一个超过MTU大小的数据要发送时，IP层就要进行分片，但是当一个分片丢失时，整个IP报文就需要重传，因为IP层没有超时重传机制，所以为了达到最佳的传输效率，建立TCP连接时通常需要协商双方的MSS值，当TCP层发现报文超过MSS时，就会进行分片，保证在IP层形成的IP包长度不会大于MTU，所以也就不会分片了。
2.5 三次握手信息丢失会发生什么


第一次握手丢失"><meta property="og:type" content="article"><meta property="og:url" content="https://roaraeonliou.github.io/posts/interviewnotes/new/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcp/"><meta property="og:image" content="https://roaraeonliou.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-26T00:00:00+00:00"><meta property="article:modified_time" content="2024-09-26T00:00:00+00:00"><meta property="og:site_name" content="RLTEA BLOG"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://roaraeonliou.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="TCP"><meta name=twitter:description content="1 TCP基础
1.1 头部字段


序列号：建立时生成随机数，后续每发送一次数据加一，用于解决网络包乱序的问题
确认应答号：表示下一次「期待」收到的序列号，发送端收到这个确认应答后认为在这个序列号之前的数据都被正常接受，用来解决丢包问题
控制位：

ACK：为1表示「确认应答」字段有效，除SYN包之外该位必须设置为1
RST：为1表示TCP连接异常，强制断开
SYN：为1时表示希望建立连接，并初始化「序列号」
FIN：为1时表示之后不会再有数据发送，表示希望断开连接



1.2 TCP的特点

面向连接：一对一建立连接，通过「源地址，源端口，目的地址，目的端口」确定唯一连接
可靠：TCP协议尽自己最大努力保证报文一定能够到达接收端
字节流：通过TCP传输的数据，可能会被操作系统拆分为多个TCP报文，如果接收方不知道「消息边界」就无法正确读取消息。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。

2 TCP三次握手
2.1 三次握手如何建立


首先，客户端和服务器都处于close状态，然后服务器主动监听某个端口，处于Listen状态。
客户端随机初始化序号，同时把SYN标识为设为1，表示SYN报文，把SYN送给服务端后，变换为SYN-SENT状态。
服务端收到客户端的SYN报文后，随机初始化自己的序号，同时把确认应答号设置为客户端初始序号+1，然后把SYN和ACK标识为设置为1，最后送给客户端，变换为SYN-RCVD状态。
客户端收到服务端报文后，向服务器回应最后一个应答报文，将ACK标识为设置为1，确认应答号填入服务器初始序号+1，这次报文可以携带数据，然后送给服务端，状态变化为ESTABLISHED。
服务器收到应答报文后，状态也设置为ESTABLISHED。

2.2 如何在Linux中查看TCP状态
netstat -napt
2.3 为什么是三次握手？而不是两次、四次?

三次的原因：

三次可以阻止重复历史连接的初始化： 两次握手对于新旧TCP连接请提无法避免初始化步骤。
三次可以同步双方的初始序列号：可以保证双方初始的序列号被可靠的同步给对方，四次握手没有必要，服务器确认和初始化自己的两步可以合并为一步。
三次可以避免浪费资源：两次握手由于服务器没有中间状态，无法知道客户端是否收到自己回复的ACK，所以每收到一个SYN报文就需要建立一个连接，同一个连接由于网络阻塞而重发SYN报文时，服务端会产生资源浪费。


为什么每次建立TCP连接初始化序列号都要求不同：

为了防止历史报文被下一个相同四元组接受。
为了安全性， 防止黑客伪造TCP报文。



2.4 IP层即然会分片，为什么TCP还需要MSS呢？


MTU：指的是一个网络包的最大长度，以太网中一般为1500字节
MSS：除去IP和TCP头部之后，一个网络包能容纳的TCP数据的最大长度

当IP层有一个超过MTU大小的数据要发送时，IP层就要进行分片，但是当一个分片丢失时，整个IP报文就需要重传，因为IP层没有超时重传机制，所以为了达到最佳的传输效率，建立TCP连接时通常需要协商双方的MSS值，当TCP层发现报文超过MSS时，就会进行分片，保证在IP层形成的IP包长度不会大于MTU，所以也就不会分片了。
2.5 三次握手信息丢失会发生什么


第一次握手丢失"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://roaraeonliou.github.io/posts/"},{"@type":"ListItem","position":2,"name":"TCP","item":"https://roaraeonliou.github.io/posts/interviewnotes/new/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcp/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"TCP","name":"TCP","description":"1 TCP基础 1.1 头部字段 序列号：建立时生成随机数，后续每发送一次数据加一，用于解决网络包乱序的问题 确认应答号：表示下一次「期待」收到的序列号，发送端收到这个确认应答后认为在这个序列号之前的数据都被正常接受，用来解决丢包问题 控制位： ACK：为1表示「确认应答」字段有效，除SYN包之外该位必须设置为1 RST：为1表示TCP连接异常，强制断开 SYN：为1时表示希望建立连接，并初始化「序列号」 FIN：为1时表示之后不会再有数据发送，表示希望断开连接 1.2 TCP的特点 面向连接：一对一建立连接，通过「源地址，源端口，目的地址，目的端口」确定唯一连接 可靠：TCP协议尽自己最大努力保证报文一定能够到达接收端 字节流：通过TCP传输的数据，可能会被操作系统拆分为多个TCP报文，如果接收方不知道「消息边界」就无法正确读取消息。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。 2 TCP三次握手 2.1 三次握手如何建立 首先，客户端和服务器都处于close状态，然后服务器主动监听某个端口，处于Listen状态。 客户端随机初始化序号，同时把SYN标识为设为1，表示SYN报文，把SYN送给服务端后，变换为SYN-SENT状态。 服务端收到客户端的SYN报文后，随机初始化自己的序号，同时把确认应答号设置为客户端初始序号+1，然后把SYN和ACK标识为设置为1，最后送给客户端，变换为SYN-RCVD状态。 客户端收到服务端报文后，向服务器回应最后一个应答报文，将ACK标识为设置为1，确认应答号填入服务器初始序号+1，这次报文可以携带数据，然后送给服务端，状态变化为ESTABLISHED。 服务器收到应答报文后，状态也设置为ESTABLISHED。 2.2 如何在Linux中查看TCP状态 netstat -napt\n2.3 为什么是三次握手？而不是两次、四次? 三次的原因： 三次可以阻止重复历史连接的初始化： 两次握手对于新旧TCP连接请提无法避免初始化步骤。 三次可以同步双方的初始序列号：可以保证双方初始的序列号被可靠的同步给对方，四次握手没有必要，服务器确认和初始化自己的两步可以合并为一步。 三次可以避免浪费资源：两次握手由于服务器没有中间状态，无法知道客户端是否收到自己回复的ACK，所以每收到一个SYN报文就需要建立一个连接，同一个连接由于网络阻塞而重发SYN报文时，服务端会产生资源浪费。 为什么每次建立TCP连接初始化序列号都要求不同： 为了防止历史报文被下一个相同四元组接受。 为了安全性， 防止黑客伪造TCP报文。 2.4 IP层即然会分片，为什么TCP还需要MSS呢？ MTU：指的是一个网络包的最大长度，以太网中一般为1500字节 MSS：除去IP和TCP头部之后，一个网络包能容纳的TCP数据的最大长度 当IP层有一个超过MTU大小的数据要发送时，IP层就要进行分片，但是当一个分片丢失时，整个IP报文就需要重传，因为IP层没有超时重传机制，所以为了达到最佳的传输效率，建立TCP连接时通常需要协商双方的MSS值，当TCP层发现报文超过MSS时，就会进行分片，保证在IP层形成的IP包长度不会大于MTU，所以也就不会分片了。\n2.5 三次握手信息丢失会发生什么 第一次握手丢失\n","keywords":[],"articleBody":"1 TCP基础 1.1 头部字段 序列号：建立时生成随机数，后续每发送一次数据加一，用于解决网络包乱序的问题 确认应答号：表示下一次「期待」收到的序列号，发送端收到这个确认应答后认为在这个序列号之前的数据都被正常接受，用来解决丢包问题 控制位： ACK：为1表示「确认应答」字段有效，除SYN包之外该位必须设置为1 RST：为1表示TCP连接异常，强制断开 SYN：为1时表示希望建立连接，并初始化「序列号」 FIN：为1时表示之后不会再有数据发送，表示希望断开连接 1.2 TCP的特点 面向连接：一对一建立连接，通过「源地址，源端口，目的地址，目的端口」确定唯一连接 可靠：TCP协议尽自己最大努力保证报文一定能够到达接收端 字节流：通过TCP传输的数据，可能会被操作系统拆分为多个TCP报文，如果接收方不知道「消息边界」就无法正确读取消息。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。 2 TCP三次握手 2.1 三次握手如何建立 首先，客户端和服务器都处于close状态，然后服务器主动监听某个端口，处于Listen状态。 客户端随机初始化序号，同时把SYN标识为设为1，表示SYN报文，把SYN送给服务端后，变换为SYN-SENT状态。 服务端收到客户端的SYN报文后，随机初始化自己的序号，同时把确认应答号设置为客户端初始序号+1，然后把SYN和ACK标识为设置为1，最后送给客户端，变换为SYN-RCVD状态。 客户端收到服务端报文后，向服务器回应最后一个应答报文，将ACK标识为设置为1，确认应答号填入服务器初始序号+1，这次报文可以携带数据，然后送给服务端，状态变化为ESTABLISHED。 服务器收到应答报文后，状态也设置为ESTABLISHED。 2.2 如何在Linux中查看TCP状态 netstat -napt\n2.3 为什么是三次握手？而不是两次、四次? 三次的原因： 三次可以阻止重复历史连接的初始化： 两次握手对于新旧TCP连接请提无法避免初始化步骤。 三次可以同步双方的初始序列号：可以保证双方初始的序列号被可靠的同步给对方，四次握手没有必要，服务器确认和初始化自己的两步可以合并为一步。 三次可以避免浪费资源：两次握手由于服务器没有中间状态，无法知道客户端是否收到自己回复的ACK，所以每收到一个SYN报文就需要建立一个连接，同一个连接由于网络阻塞而重发SYN报文时，服务端会产生资源浪费。 为什么每次建立TCP连接初始化序列号都要求不同： 为了防止历史报文被下一个相同四元组接受。 为了安全性， 防止黑客伪造TCP报文。 2.4 IP层即然会分片，为什么TCP还需要MSS呢？ MTU：指的是一个网络包的最大长度，以太网中一般为1500字节 MSS：除去IP和TCP头部之后，一个网络包能容纳的TCP数据的最大长度 当IP层有一个超过MTU大小的数据要发送时，IP层就要进行分片，但是当一个分片丢失时，整个IP报文就需要重传，因为IP层没有超时重传机制，所以为了达到最佳的传输效率，建立TCP连接时通常需要协商双方的MSS值，当TCP层发现报文超过MSS时，就会进行分片，保证在IP层形成的IP包长度不会大于MTU，所以也就不会分片了。\n2.5 三次握手信息丢失会发生什么 第一次握手丢失\n客户端触发超时重传，重传次数默认为5，超时重试时间从1s开始翻倍。 超过次数限制后断开连接 第二次握手丢失\n客户端和服务端都超时重传，各自超过重传次数上限后，就会断开连接，回到Close状态 第三次握手丢失\nACK报文不重传，服务端触发超时重传，超过次数限制后断开连接。 2.6 SYN攻击 攻击者伪造不同IP的tcp请求，打满服务器半连接队列。\nTCP三次握手时，Linux内核会维护两个队列\n半连接队列：SYN队列 全连接队列：accept队列 当服务器收到SYN报文时，会创建一个半连接对象，加入到内核的SYN对队列 发送SYN+ACK等待客户端响应 服务器收到客户端响应的ACK报文，从SYN队列取出半连接对象，构建一个新的连接对象放入全连接队列 应用通过调用accept()的socket接口，从全连接队列中取出连接对象。 避免方式：\n增大netdev_max_backlog：网卡接受数据包速度大于内核处理速度时，会有一个队列保存数据包，这个参数对应的就是队列长度\n增大半连接队列\n增大 net.ipv4.tcp_max_syn_backlog 增大 listen() 函数中的 backlog 增大 net.core.somaxconn 开启tcp-syncookies：开启后可以在不使用SYN半连接队列的情况下成功建立连接。\n当SYN队列满后，服务器收到SYN会根据算法算出一个cookie值 将cookie值放入第二次握手报文的序列号中 服务器收到应答报文时会检查ACK包的合法性，如果合法则放入全连接队列中，最后应用程序调用accept（）接口取出连接。 减少SYN+ACK重传次数：内核参数tcp_synack_retries\n3 TCP四次挥手 3.1 挥手过程 客户端打算关闭连接，发送FIN报文，进入FIN_WAIT_1状态 服务器收到报文后，发送ACK应答报文，服务器进入CLOSE_WAIT状态 客户端收到ACK报文进入FIN_WAIT_2状态 服务器处理完数据，发送FIN报文，进入LAST_ACK状态 客户端收到FIN报文，回应ACK报文，进入TIME_WAIT状态 服务器收到ACK报文后，进入CLOSE状态，服务端完成连接关闭动作 客户端经过2MSL后，自动进入CLOSE状态，客户端完成连接关闭动作 3.2 为什么需要四次挥手 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。 特定情况下会变成三次挥手：被动关闭方「没有数据要发送」并且「开启了TCP延迟确认机制」，那么第二次和第三次挥手就会合并传输。 当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方 当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送 如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK 3.3 挥手报文丢失会发生什么 第一次挥手丢失：客户端触发超时重传，超过tcp_orphan_retries定义的重传次数时，直接关闭TCP连接。服务器处于连接建立状态。 第二次挥手丢失：服务器ACK丢失，但是ACK报文不重传，所以客户端会触发超时重传机制，服务器处于CLOSE_WAIT状态。 正常使用close关闭连接，客户端收到第二次挥手后进入FIN_WAIT_2状态会默认等待60秒（tcp_fin_timeout可以控制close关闭的连接），超时自动关闭连接。 但是如果使用shutdown关闭连接（只关闭了发送反向），那么进入FIN_WAIT_2状态后就会死等（tcp_fin_timeout无法控制shutdown关闭的连接）。 第三次挥手丢失：服务端会触发超时重传机制，超过重试次数后关闭TCP连接，客户端处于FIN_WAIT_2有等待时常上线，超时没有收到第三次挥手报文会主动断开连接 第四次挥手丢失：服务器会触发超时重传机制，而客户端进入2MSL的TIME_WAIT状态，但是客户端每收到一个第三次挥手消息就会重置2MSL的时间，所以等服务器达到超时上限后发出最后一个报文，再过2MSL客户端会进入关闭状态。 3.4 TIME_WAIT状态 为什么要有TIME_WAIT状态：\n防止历史连接中的数据被后面相同四元组连接错误接受。 保证「被动关闭」一方能够被正确关闭。 TIME_WAIT过多，会占用系统资源，占用端口资源\n如果客户端（主动发起关闭连接方）的 TIME_WAIT 状态过多，占满了所有端口资源，那么就无法对「目的 IP+ 目的 PORT」都一样的服务端发起连接了，但是被使用的端口，还是可以继续对另外一个服务端发起连接的。 如果服务端（主动发起关闭连接方）的 TIME_WAIT 状态过多，并不会导致端口资源受限，因为服务端只监听一个端口，而且由于一个四元组唯一确定一个 TCP 连接，因此理论上服务端可以建立很多连接，但是 TCP 连接过多，会占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等。 优化TIME_WAIT\n打开net.ipv4.tcp_tw_reuse 和 tcp_timestamps选项：复用处于TIME_WAIT状态的socket作为新的连接使用。 设置net.ipv4.tcp_max_tw_buckets：TIME_WAIT的连接超过这个值，系统会将后续的TIME_WAIT连接状态直接重置。 程序使用SO_LINGER，如果l_onoff为非 0， 且l_linger值为 0，那么调用close后，会立该发送一个RST标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了TIME_WAIT状态，直接关闭。不提倡 服务器出现大量TIME_WAIT有什么原因\nTIME_WAIT 状态是主动关闭连接方才会出现的状态，所以如果服务器出现大量的 TIME_WAIT 状态的 TCP 连接，就是说明服务器主动断开了很多 TCP 连接。\nHTTP没有使用长连接，禁用Keep-Alive后，服务器会主动关闭连接，所以会出现大量TIME_WAIT。 HTTP长连接超时，长连接没有请求超过一定时间，服务器会主动关闭。（比如nginx提供的keepalive_timeout） HTTP长连接的请求数量达到上限，Web服务器会定义一个参数，表示一个HTTP长连接上能够请求的最大请求数量，超过数量后会主动关闭。 服务器出现大量CLOSE_WAIT有什么原因\nCLOSE_WAIT 状态是「被动关闭方」才会有的状态，而且如果「被动关闭方」没有调用 close 函数关闭连接，那么就无法发出 FIN 报文，从而无法使得 CLOSE_WAIT 状态的连接转变为 LAST_ACK 状态。当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接。\nTCP服务端流程\n创建服务端 socket，bind 绑定端口、listen 监听端口 将服务端 socket 注册到 epoll epoll_wait 等待连接到来，连接到来时，调用 accpet 获取已连接的 socket 将已连接的 socket 注册到 epoll epoll_wait 等待事件发生 对方连接关闭时，我方调用 close 可能导致服务端没有调用close的原因：\n第二步没做：没有将服务端 socket 注册到 epoll，这样有新连接到来时，服务端没办法感知这个事件，也就无法获取到已连接的 socket，那服务端自然就没机会对 socket 调用 close 函数了。\n第三步没做：有新连接到来时没有调用 accpet 获取该连接的 socket，导致当有大量的客户端主动断开了连接，而服务端没机会对这些 socket 调用 close 函数，从而导致服务端出现大量 CLOSE_WAIT 状态的连接。\n第四步没做：通过 accpet 获取已连接的 socket 后，没有将其注册到 epoll，导致后续收到 FIN 报文的时候，服务端没办法感知这个事件，那服务端就没机会调用 close 函数了。\n第六步没做：当发现客户端关闭连接后，服务端没有执行 close 函数，可能是因为代码漏处理，或者是在执行 close 函数之前，代码卡在某一个逻辑，比如发生死锁等等。\n通常都是代码问题，主要分析方向就是为什么没有调用close。\n3.5 建立连接后，有一方崩溃会发生什么？ 主机崩溃：TCP有保活机制，应用层可以自行实现心跳机制。如果没有开启保活机制，服务端会一直保持ESTABLISHED的TCP连接。\ntcp_keepalive_time=7200：表示保活时间是 7200 秒（2小时），也就 2 小时内如果没有任何连接相关的活动，则会启动保活机制； tcp_keepalive_intvl=75：表示每次检测间隔 75 秒； tcp_keepalive_probes=9：表示检测 9 次无响应，认为对方是不可达的，从而中断本次的连接。 应用程序若想使用 TCP 保活机制需要通过 socket 接口设置 SO_KEEPALIVE 选项才能够生效。（对端响应，重置保活时间；对端重启，回应RST报文；对端无响应，达到上限报告死亡）。\n进程崩溃：TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程。\n客户端主机宕机：\n服务端发送数据：超时重传达到上限断开连接 服务器不发送数据 开启保活机制：探测到死亡后断开连接 一直存在保持ESTABLISHED状态。 4 TCP重传、滑动窗口、流量控制、拥塞控制 4.1 重传机制 超时重传：发送数据时，启动一个定时器，超过指定时间，没有收到ACK 确认报文，就重发该数据 RTO超时时间设置小于RTT（包往返时间时）会造成网络拥塞，当过于大于RTT时会没有效率，所以应当略大于RTT。 快速重传：收到三次相同的ACK，就开始重传ACK中期望的数据包 SACK：在TCP头部增加SACK选项，可以将已经收到的数据信息发送给发送方，从而发送方就不需要重传全部信息。 D-SACK：可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;可以知道是不是「发送方」的数据包被网络延迟了;可以知道网络中是不是把「发送方」的数据包给复制了。 4.2 滑动窗口 窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。\n对应累计应答模式，只要收到ACK报文，就表示之前的报文全部都被正确接受。\n窗口大小的确定：TCP头部有一个字段叫Window，接收段用来告诉发送端自己还有多少缓冲区可以接受数据，然后发送端根据接收端的能力发送数据，所以通常是由接收端确认窗口大小的。 接收窗口和发送窗口的大小是相等的吗？并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。 4.3 流量控制 TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。\n操作系统缓冲区和滑动窗口的关系：实际上，发送窗口和接收窗口中所存放的字节数，都是放在操作系统内存缓冲区中的，而操作系统的缓冲区，会被操作系统调整。\n当接收方应用进程没办法及时读取缓冲区的内容时，接收方接受窗口会关闭 当接收方资源紧张，操作系统直接减少了接收缓冲区大小，应用程序又无法及时读取缓存数据，这是数据包会丢失，发送方可用窗口大小会变为负值。 为了防止这种情况发生，TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。 窗口关闭：如果窗口大小为0，就会阻止发送方给接受方出阿奴第数据，直到窗口非0为止。接收方向发送方通告窗口大小时，是通过 ACK 报文来通告的。\n窗口关闭后，处理完数据，发送的非零ACK报文丢失会出现死锁（相互等待）：TCP 为每个连接设有一个持续定时器，只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。如果持续计时器超时，就会发送窗口探测 ( Window probe ) 报文，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。 糊涂窗口综合症：如果接收方太忙了，来不及取走接收窗口里的数据，那么就会导致发送方的发送窗口越来越小。到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症。\n让接收方不通告小窗口给发送方：当「窗口大小」小于 min( MSS，缓存空间/2 ) ，也就是小于 MSS 与 1/2 缓存大小中的最小值时，就会向发送方通告窗口为 0，也就阻止了发送方再发数据过来。等到接收方处理了一些数据后，窗口大小 \u003e= MSS，或者接收方缓存空间有一半可以使用，就可以把窗口打开让发送方发送数据过来。 让发送方避免发送小数据：使用 Nagle 算法，满足1）要等到窗口大小 \u003e= MSS 并且 数据大小 \u003e= MSS；2）收到之前发送数据的 ack 回包；二者之一就发送数据，否则一直囤积数据。 接收方得满足「不通告小窗口给发送方」+ 发送方开启 Nagle 算法，才能避免糊涂窗口综合症。\n4.4 拥塞控制 为什么要有拥塞控制呀，不是有流量控制了吗？\n流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。\n在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….\n什么是拥塞窗口？和发送窗口有什么关系呢？\n拥塞窗口 cwnd是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化的。\n发送窗口 swnd 和接收窗口 rwnd 是约等于的关系，加入了拥塞窗口的概念后，此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。只要网络中没有出现拥塞，cwnd 就会增大；但网络中出现了拥塞，cwnd 就减少。\n拥塞控制算法：cwnd初始大小为10，ssthresh初始大小为65535字节。\n慢启动：当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。\n拥塞避免：当拥塞窗口 cwnd 「超过」慢启动门限 ssthresh 就会进入拥塞避免算法。每当收到一个 ACK 时，cwnd 增加 1/cwnd。\n拥塞发生：拥塞发生后触发超时重传机制，此时ssthresh 会设为 cwnd/2，cwnd 重置为 初始值，重新开始慢启动。\n快速恢复：拥塞发生后触发快速重传机制（快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 RTO 超时那么强烈），此时cwnd = cwnd/2 ，也就是设置为原来的一半；ssthresh = cwnd`；然后进入快速恢复算法：\n拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）\n重传丢失的数据包；\n如果再收到重复的 ACK，那么 cwnd 增加 1；\n如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态。\n","wordCount":"425","inLanguage":"en","image":"https://roaraeonliou.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-09-26T00:00:00Z","dateModified":"2024-09-26T00:00:00Z","author":{"@type":"Person","name":"RLTEA"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://roaraeonliou.github.io/posts/interviewnotes/new/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcp/"},"publisher":{"@type":"Organization","name":"RLTEA BLOG","logo":{"@type":"ImageObject","url":"https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E"}}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["\\(","\\)"],["$","$"]]}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://roaraeonliou.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://roaraeonliou.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://roaraeonliou.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://roaraeonliou.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://roaraeonliou.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://roaraeonliou.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://roaraeonliou.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://roaraeonliou.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">TCP</h1><div class=post-meta><span title='2024-09-26 00:00:00 +0000 UTC'>September 26, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;425 words&nbsp;·&nbsp;RLTEA&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/InterviewNotes/new/%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c/TCP.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-tcp%e5%9f%ba%e7%a1%80 aria-label="1 TCP基础">1 TCP基础</a><ul><ul><li><a href=#11-%e5%a4%b4%e9%83%a8%e5%ad%97%e6%ae%b5 aria-label="1.1 头部字段">1.1 头部字段</a></li><li><a href=#12-tcp%e7%9a%84%e7%89%b9%e7%82%b9 aria-label="1.2 TCP的特点">1.2 TCP的特点</a></li></ul></ul></li><li><a href=#2-tcp%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b aria-label="2 TCP三次握手">2 TCP三次握手</a><ul><ul><li><a href=#21-%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%e5%a6%82%e4%bd%95%e5%bb%ba%e7%ab%8b aria-label="2.1 三次握手如何建立">2.1 三次握手如何建立</a></li><li><a href=#22-%e5%a6%82%e4%bd%95%e5%9c%a8linux%e4%b8%ad%e6%9f%a5%e7%9c%8btcp%e7%8a%b6%e6%80%81 aria-label="2.2 如何在Linux中查看TCP状态">2.2 如何在Linux中查看TCP状态</a></li><li><a href=#23-%e4%b8%ba%e4%bb%80%e4%b9%88%e6%98%af%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%e8%80%8c%e4%b8%8d%e6%98%af%e4%b8%a4%e6%ac%a1%e5%9b%9b%e6%ac%a1 aria-label="2.3 为什么是三次握手？而不是两次、四次?">2.3 为什么是三次握手？而不是两次、四次?</a></li><li><a href=#24-ip%e5%b1%82%e5%8d%b3%e7%84%b6%e4%bc%9a%e5%88%86%e7%89%87%e4%b8%ba%e4%bb%80%e4%b9%88tcp%e8%bf%98%e9%9c%80%e8%a6%81mss%e5%91%a2 aria-label="2.4 IP层即然会分片，为什么TCP还需要MSS呢？">2.4 IP层即然会分片，为什么TCP还需要MSS呢？</a></li><li><a href=#25-%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%e4%bf%a1%e6%81%af%e4%b8%a2%e5%a4%b1%e4%bc%9a%e5%8f%91%e7%94%9f%e4%bb%80%e4%b9%88 aria-label="2.5 三次握手信息丢失会发生什么">2.5 三次握手信息丢失会发生什么</a></li><li><a href=#26-syn%e6%94%bb%e5%87%bb aria-label="2.6 SYN攻击">2.6 SYN攻击</a></li></ul></ul></li><li><a href=#3-tcp%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b aria-label="3 TCP四次挥手">3 TCP四次挥手</a><ul><ul><li><a href=#31-%e6%8c%a5%e6%89%8b%e8%bf%87%e7%a8%8b aria-label="3.1 挥手过程">3.1 挥手过程</a></li><li><a href=#32-%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b aria-label="3.2 为什么需要四次挥手">3.2 为什么需要四次挥手</a></li><li><a href=#33-%e6%8c%a5%e6%89%8b%e6%8a%a5%e6%96%87%e4%b8%a2%e5%a4%b1%e4%bc%9a%e5%8f%91%e7%94%9f%e4%bb%80%e4%b9%88 aria-label="3.3 挥手报文丢失会发生什么">3.3 挥手报文丢失会发生什么</a></li><li><a href=#34-time_wait%e7%8a%b6%e6%80%81 aria-label="3.4 TIME_WAIT状态">3.4 TIME_WAIT状态</a></li><li><a href=#35-%e5%bb%ba%e7%ab%8b%e8%bf%9e%e6%8e%a5%e5%90%8e%e6%9c%89%e4%b8%80%e6%96%b9%e5%b4%a9%e6%ba%83%e4%bc%9a%e5%8f%91%e7%94%9f%e4%bb%80%e4%b9%88 aria-label="3.5 建立连接后，有一方崩溃会发生什么？">3.5 建立连接后，有一方崩溃会发生什么？</a></li></ul></ul></li><li><a href=#4-tcp%e9%87%8d%e4%bc%a0%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6 aria-label="4 TCP重传、滑动窗口、流量控制、拥塞控制">4 TCP重传、滑动窗口、流量控制、拥塞控制</a><ul><ul><li><a href=#41-%e9%87%8d%e4%bc%a0%e6%9c%ba%e5%88%b6 aria-label="4.1 重传机制">4.1 重传机制</a></li><li><a href=#42-%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3 aria-label="4.2 滑动窗口">4.2 滑动窗口</a></li><li><a href=#43-%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6 aria-label="4.3 流量控制">4.3 流量控制</a></li><li><a href=#44-%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6 aria-label="4.4 拥塞控制">4.4 拥塞控制</a></li></ul></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=1-tcp基础>1 TCP基础<a hidden class=anchor aria-hidden=true href=#1-tcp基础>#</a></h2><h4 id=11-头部字段>1.1 头部字段<a hidden class=anchor aria-hidden=true href=#11-头部字段>#</a></h4><ul><li>序列号：建立时生成随机数，后续每发送一次数据加一，<strong>用于解决网络包乱序的问题</strong></li><li>确认应答号：表示下一次「期待」收到的序列号，发送端收到这个确认应答后认为在这个序列号之前的数据都被正常接受，<strong>用来解决丢包问题</strong></li><li>控制位：<ul><li>ACK：为1表示「确认应答」字段有效，除SYN包之外该位必须设置为1</li><li>RST：为1表示TCP连接异常，强制断开</li><li>SYN：为1时表示希望建立连接，并初始化「序列号」</li><li>FIN：为1时表示之后不会再有数据发送，表示希望断开连接</li></ul></li></ul><h4 id=12-tcp的特点>1.2 TCP的特点<a hidden class=anchor aria-hidden=true href=#12-tcp的特点>#</a></h4><ul><li>面向连接：一对一建立连接，通过「源地址，源端口，目的地址，目的端口」确定唯一连接</li><li>可靠：TCP协议尽自己最大努力保证报文一定能够到达接收端</li><li>字节流：通过TCP传输的数据，可能会被操作系统拆分为多个TCP报文，如果接收方不知道「消息边界」就无法正确读取消息。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。</li></ul><h2 id=2-tcp三次握手>2 TCP三次握手<a hidden class=anchor aria-hidden=true href=#2-tcp三次握手>#</a></h2><h4 id=21-三次握手如何建立>2.1 三次握手如何建立<a hidden class=anchor aria-hidden=true href=#21-三次握手如何建立>#</a></h4><ul><li>首先，客户端和服务器都处于<code>close</code>状态，然后服务器主动监听某个端口，处于<code>Listen</code>状态。</li><li>客户端随机初始化序号，同时把<code>SYN</code>标识为设为1，表示SYN报文，把SYN送给服务端后，变换为<code>SYN-SENT</code>状态。</li><li>服务端收到客户端的SYN报文后，随机初始化自己的序号，同时把确认应答号设置为客户端初始序号+1，然后把<code>SYN</code>和<code>ACK</code>标识为设置为1，最后送给客户端，变换为<code>SYN-RCVD</code>状态。</li><li>客户端收到服务端报文后，向服务器回应最后一个应答报文，将ACK标识为设置为1，确认应答号填入服务器初始序号+1，这次报文可以携带数据，然后送给服务端，状态变化为<code>ESTABLISHED</code>。</li><li>服务器收到应答报文后，状态也设置为<code>ESTABLISHED</code>。</li></ul><h4 id=22-如何在linux中查看tcp状态>2.2 如何在Linux中查看TCP状态<a hidden class=anchor aria-hidden=true href=#22-如何在linux中查看tcp状态>#</a></h4><p>netstat -napt</p><h4 id=23-为什么是三次握手而不是两次四次>2.3 为什么是三次握手？而不是两次、四次?<a hidden class=anchor aria-hidden=true href=#23-为什么是三次握手而不是两次四次>#</a></h4><ul><li>三次的原因：<ul><li>三次可以阻止重复<strong>历史连接的初始化</strong>： 两次握手对于新旧TCP连接请提无法避免初始化步骤。</li><li>三次可以同步双方的初始序列号：可以保证双方初始的序列号被可靠的同步给对方，四次握手没有必要，服务器确认和初始化自己的两步可以合并为一步。</li><li>三次可以避免浪费资源：两次握手由于服务器没有中间状态，无法知道客户端是否收到自己回复的ACK，所以每收到一个SYN报文就需要建立一个连接，同一个连接由于网络阻塞而重发SYN报文时，服务端会产生资源浪费。</li></ul></li><li>为什么每次建立TCP连接初始化序列号都要求不同：<ul><li>为了防止历史报文被下一个相同四元组接受。</li><li>为了安全性， 防止黑客伪造TCP报文。</li></ul></li></ul><h4 id=24-ip层即然会分片为什么tcp还需要mss呢>2.4 IP层即然会分片，为什么TCP还需要MSS呢？<a hidden class=anchor aria-hidden=true href=#24-ip层即然会分片为什么tcp还需要mss呢>#</a></h4><ul><li>MTU：指的是一个网络包的最大长度，以太网中一般为1500字节</li><li>MSS：除去IP和TCP头部之后，一个网络包能容纳的TCP数据的最大长度</li></ul><p>当IP层有一个超过MTU大小的数据要发送时，IP层就要进行分片，但是当一个分片丢失时，整个IP报文就需要重传，因为IP层没有超时重传机制，所以为了达到最佳的传输效率，建立TCP连接时通常需要协商双方的MSS值，当TCP层发现报文超过MSS时，就会进行分片，保证在IP层形成的IP包长度不会大于MTU，所以也就不会分片了。</p><h4 id=25-三次握手信息丢失会发生什么>2.5 三次握手信息丢失会发生什么<a hidden class=anchor aria-hidden=true href=#25-三次握手信息丢失会发生什么>#</a></h4><ul><li><p>第一次握手丢失</p><ul><li>客户端触发超时重传，重传次数默认为5，超时重试时间从1s开始翻倍。</li><li>超过次数限制后断开连接</li></ul></li><li><p>第二次握手丢失</p><ul><li>客户端和服务端都超时重传，各自超过重传次数上限后，就会断开连接，回到<code>Close</code>状态</li></ul></li><li><p>第三次握手丢失</p><ul><li>ACK报文不重传，服务端触发超时重传，超过次数限制后断开连接。</li></ul></li></ul><h4 id=26-syn攻击>2.6 SYN攻击<a hidden class=anchor aria-hidden=true href=#26-syn攻击>#</a></h4><p>攻击者伪造不同IP的tcp请求，打满服务器半连接队列。</p><ul><li><p>TCP三次握手时，Linux内核会维护两个队列</p><ul><li>半连接队列：SYN队列</li><li>全连接队列：accept队列</li></ul><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/24cce0d4df88e72956d3e28f7dc9efbf/29735555c9ddb402dff8fdfa5c2b5c01.png alt=image-20240824174930240></p><ul><li>当服务器收到SYN报文时，会创建一个半连接对象，加入到内核的SYN对队列</li><li>发送SYN+ACK等待客户端响应</li><li>服务器收到客户端响应的ACK报文，从SYN队列取出半连接对象，构建一个新的连接对象放入全连接队列</li><li>应用通过调用accept()的socket接口，从全连接队列中取出连接对象。</li></ul></li><li><p>避免方式：</p><ul><li><p>增大netdev_max_backlog：网卡接受数据包速度大于内核处理速度时，会有一个队列保存数据包，这个参数对应的就是队列长度</p></li><li><p>增大半连接队列</p><ul><li>增大 net.ipv4.tcp_max_syn_backlog</li><li>增大 listen() 函数中的 backlog</li><li>增大 net.core.somaxconn</li></ul></li><li><p>开启tcp-syncookies：开启后可以在不使用SYN半连接队列的情况下成功建立连接。</p><ul><li>当SYN队列满后，服务器收到SYN会根据算法算出一个cookie值</li><li>将cookie值放入第二次握手报文的序列号中</li><li>服务器收到应答报文时会检查ACK包的合法性，如果合法则放入全连接队列中，最后应用程序调用accept（）接口取出连接。</li></ul></li><li><p>减少SYN+ACK重传次数：内核参数tcp_synack_retries</p></li></ul></li></ul><h2 id=3-tcp四次挥手>3 TCP四次挥手<a hidden class=anchor aria-hidden=true href=#3-tcp四次挥手>#</a></h2><h4 id=31-挥手过程>3.1 挥手过程<a hidden class=anchor aria-hidden=true href=#31-挥手过程>#</a></h4><ul><li>客户端打算关闭连接，发送FIN报文，进入FIN_WAIT_1状态</li><li>服务器收到报文后，发送ACK应答报文，服务器进入CLOSE_WAIT状态</li><li>客户端收到ACK报文进入FIN_WAIT_2状态</li><li>服务器处理完数据，发送FIN报文，进入LAST_ACK状态</li><li>客户端收到FIN报文，回应ACK报文，进入TIME_WAIT状态</li><li>服务器收到ACK报文后，进入CLOSE状态，服务端完成连接关闭动作</li><li>客户端经过2MSL后，自动进入CLOSE状态，客户端完成连接关闭动作</li></ul><h4 id=32-为什么需要四次挥手>3.2 为什么需要四次挥手<a hidden class=anchor aria-hidden=true href=#32-为什么需要四次挥手>#</a></h4><ul><li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li><li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li><li>特定情况下会变成三次挥手：被动关闭方「没有数据要发送」并且「开启了TCP延迟确认机制」，那么第二次和第三次挥手就会合并传输。<ul><li>当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方</li><li>当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送</li><li>如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK</li></ul></li></ul><h4 id=33-挥手报文丢失会发生什么>3.3 挥手报文丢失会发生什么<a hidden class=anchor aria-hidden=true href=#33-挥手报文丢失会发生什么>#</a></h4><ul><li>第一次挥手丢失：客户端触发超时重传，超过tcp_orphan_retries定义的重传次数时，直接关闭TCP连接。服务器处于连接建立状态。</li><li>第二次挥手丢失：服务器ACK丢失，但是ACK报文不重传，所以客户端会触发超时重传机制，服务器处于CLOSE_WAIT状态。<ul><li>正常使用close关闭连接，客户端收到第二次挥手后进入FIN_WAIT_2状态会默认等待60秒（tcp_fin_timeout可以控制close关闭的连接），超时自动关闭连接。</li><li>但是如果使用shutdown关闭连接（只关闭了发送反向），那么进入FIN_WAIT_2状态后就会死等（tcp_fin_timeout无法控制shutdown关闭的连接）。</li></ul></li><li>第三次挥手丢失：服务端会触发超时重传机制，超过重试次数后关闭TCP连接，客户端处于FIN_WAIT_2有等待时常上线，超时没有收到第三次挥手报文会主动断开连接</li><li>第四次挥手丢失：服务器会触发超时重传机制，而客户端进入2MSL的TIME_WAIT状态，但是客户端每收到一个第三次挥手消息就会重置2MSL的时间，所以等服务器达到超时上限后发出最后一个报文，再过2MSL客户端会进入关闭状态。</li></ul><h4 id=34-time_wait状态>3.4 TIME_WAIT状态<a hidden class=anchor aria-hidden=true href=#34-time_wait状态>#</a></h4><ul><li><p>为什么要有TIME_WAIT状态：</p><ul><li>防止历史连接中的数据被后面相同四元组连接错误接受。</li><li>保证「被动关闭」一方能够被正确关闭。</li></ul></li><li><p>TIME_WAIT过多，会占用系统资源，占用端口资源</p><ul><li><strong>如果客户端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong>，占满了所有端口资源，那么就无法对「目的 IP+ 目的 PORT」都一样的服务端发起连接了，但是被使用的端口，还是可以继续对另外一个服务端发起连接的。</li><li><strong>如果服务端（主动发起关闭连接方）的 TIME_WAIT 状态过多</strong>，并不会导致端口资源受限，因为服务端只监听一个端口，而且由于一个四元组唯一确定一个 TCP 连接，因此理论上服务端可以建立很多连接，但是 TCP 连接过多，会占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等。</li></ul></li><li><p>优化TIME_WAIT</p><ul><li>打开<em>net.ipv4.tcp_tw_reuse 和 tcp_timestamps</em>选项：复用处于TIME_WAIT状态的socket作为新的连接使用。</li><li>设置<em>net.ipv4.tcp_max_tw_buckets</em>：TIME_WAIT的连接超过这个值，系统会将后续的TIME_WAIT连接状态直接重置。</li><li>程序使用SO_LINGER，如果<code>l_onoff</code>为非 0， 且<code>l_linger</code>值为 0，那么调用<code>close</code>后，会立该发送一个<code>RST</code>标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了<code>TIME_WAIT</code>状态，直接关闭。不提倡</li></ul></li><li><p>服务器出现大量TIME_WAIT有什么原因</p><p>TIME_WAIT 状态是主动关闭连接方才会出现的状态，所以如果服务器出现大量的 TIME_WAIT 状态的 TCP 连接，就是说明服务器主动断开了很多 TCP 连接。</p><ul><li>HTTP没有使用长连接，禁用Keep-Alive后，服务器会主动关闭连接，所以会出现大量TIME_WAIT。</li><li>HTTP长连接超时，长连接没有请求超过一定时间，服务器会主动关闭。（比如nginx提供的keepalive_timeout）</li><li>HTTP长连接的请求数量达到上限，Web服务器会定义一个参数，表示一个HTTP长连接上能够请求的最大请求数量，超过数量后会主动关闭。</li></ul></li><li><p>服务器出现大量CLOSE_WAIT有什么原因</p><p>CLOSE_WAIT 状态是「被动关闭方」才会有的状态，而且如果「被动关闭方」没有调用 close 函数关闭连接，那么就无法发出 FIN 报文，从而无法使得 CLOSE_WAIT 状态的连接转变为 LAST_ACK 状态。<strong>当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接</strong>。</p><ul><li><p>TCP服务端流程</p><ol><li>创建服务端 socket，bind 绑定端口、listen 监听端口</li><li>将服务端 socket 注册到 epoll</li><li>epoll_wait 等待连接到来，连接到来时，调用 accpet 获取已连接的 socket</li><li>将已连接的 socket 注册到 epoll</li><li>epoll_wait 等待事件发生</li><li>对方连接关闭时，我方调用 close</li></ol><p>可能导致服务端没有调用close的原因：</p></li><li><p>第二步没做：没有将服务端 socket 注册到 epoll，这样有新连接到来时，服务端没办法感知这个事件，也就无法获取到已连接的 socket，那服务端自然就没机会对 socket 调用 close 函数了。</p></li><li><p>第三步没做：有新连接到来时没有调用 accpet 获取该连接的 socket，导致当有大量的客户端主动断开了连接，而服务端没机会对这些 socket 调用 close 函数，从而导致服务端出现大量 CLOSE_WAIT 状态的连接。</p></li><li><p>第四步没做：通过 accpet 获取已连接的 socket 后，没有将其注册到 epoll，导致后续收到 FIN 报文的时候，服务端没办法感知这个事件，那服务端就没机会调用 close 函数了。</p></li><li><p>第六步没做：当发现客户端关闭连接后，服务端没有执行 close 函数，可能是因为代码漏处理，或者是在执行 close 函数之前，代码卡在某一个逻辑，比如发生死锁等等。</p></li></ul><p>通常都是代码问题，主要分析方向就是<strong>为什么没有调用close</strong>。</p></li></ul><h4 id=35-建立连接后有一方崩溃会发生什么>3.5 建立连接后，有一方崩溃会发生什么？<a hidden class=anchor aria-hidden=true href=#35-建立连接后有一方崩溃会发生什么>#</a></h4><ul><li><p>主机崩溃：TCP有<strong>保活机制</strong>，应用层可以自行实现心跳机制。如果没有开启保活机制，服务端会一直保持ESTABLISHED的TCP连接。</p><ul><li>tcp_keepalive_time=7200：表示保活时间是 7200 秒（2小时），也就 2 小时内如果没有任何连接相关的活动，则会启动保活机制；</li><li>tcp_keepalive_intvl=75：表示每次检测间隔 75 秒；</li><li>tcp_keepalive_probes=9：表示检测 9 次无响应，认为对方是不可达的，从而中断本次的连接。</li></ul><p>应用程序若想使用 TCP 保活机制需要通过 socket 接口设置 <code>SO_KEEPALIVE</code> 选项才能够生效。（对端响应，重置保活时间；对端重启，回应RST报文；对端无响应，达到上限报告死亡）。</p></li><li><p>进程崩溃：TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程。</p></li><li><p>客户端主机宕机：</p><ul><li>服务端发送数据：超时重传达到上限断开连接</li><li>服务器不发送数据<ul><li>开启保活机制：探测到死亡后断开连接</li><li>一直存在保持ESTABLISHED状态。</li></ul></li></ul></li></ul><h2 id=4-tcp重传滑动窗口流量控制拥塞控制>4 TCP重传、滑动窗口、流量控制、拥塞控制<a hidden class=anchor aria-hidden=true href=#4-tcp重传滑动窗口流量控制拥塞控制>#</a></h2><h4 id=41-重传机制>4.1 重传机制<a hidden class=anchor aria-hidden=true href=#41-重传机制>#</a></h4><ul><li>超时重传：发送数据时，启动一个定时器，超过指定时间，没有收到ACK 确认报文，就重发该数据<ul><li>RTO超时时间设置小于RTT（包往返时间时）会造成网络拥塞，当过于大于RTT时会没有效率，所以应当略大于RTT。</li></ul></li><li>快速重传：收到三次相同的ACK，就开始重传ACK中期望的数据包</li><li>SACK：在TCP头部增加SACK选项，可以将已经收到的数据信息发送给发送方，从而发送方就不需要重传全部信息。</li><li>D-SACK：可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;可以知道是不是「发送方」的数据包被网络延迟了;可以知道网络中是不是把「发送方」的数据包给复制了。</li></ul><h4 id=42-滑动窗口>4.2 滑动窗口<a hidden class=anchor aria-hidden=true href=#42-滑动窗口>#</a></h4><p>窗口大小就是指<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>。</p><p>对应累计应答模式，只要收到ACK报文，就表示之前的报文全部都被正确接受。</p><ul><li>窗口大小的确定：TCP头部有一个字段叫Window，接收段用来告诉发送端自己还有多少缓冲区可以接受数据，然后发送端根据接收端的能力发送数据，所以通常是由接收端确认窗口大小的。</li><li>接收窗口和发送窗口的大小是相等的吗？并不是完全相等，接收窗口的大小是<strong>约等于</strong>发送窗口的大小的。当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。</li></ul><h4 id=43-流量控制>4.3 流量控制<a hidden class=anchor aria-hidden=true href=#43-流量控制>#</a></h4><p><strong>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</strong></p><ul><li><p>操作系统缓冲区和滑动窗口的关系：实际上，发送窗口和接收窗口中所存放的字节数，都是放在操作系统内存缓冲区中的，而操作系统的缓冲区，会<strong>被操作系统调整</strong>。</p><ul><li>当接收方应用进程没办法及时读取缓冲区的内容时，接收方接受窗口会关闭</li><li>当接收方资源紧张，操作系统直接减少了接收缓冲区大小，应用程序又无法及时读取缓存数据，这是数据包会丢失，发送方可用窗口大小会变为负值。<ul><li><strong>为了防止这种情况发生，TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。</strong></li></ul></li></ul></li><li><p>窗口关闭：如果窗口大小为0，就会阻止发送方给接受方出阿奴第数据，直到窗口非0为止。接收方向发送方通告窗口大小时，是通过 <code>ACK</code> 报文来通告的。</p><ul><li>窗口关闭后，处理完数据，发送的非零ACK报文丢失会出现死锁（相互等待）：TCP 为每个连接设有一个持续定时器，<strong>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。<strong>如果持续计时器超时，就会发送</strong>窗口探测 ( Window probe ) 报文</strong>，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</li></ul></li><li><p>糊涂窗口综合症：如果接收方太忙了，来不及取走接收窗口里的数据，那么就会导致发送方的发送窗口越来越小。到最后，<strong>如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症</strong>。</p><ul><li>让接收方不通告小窗口给发送方：当「窗口大小」小于 min( MSS，缓存空间/2 ) ，也就是小于 MSS 与 1/2 缓存大小中的最小值时，就会向发送方通告窗口为 <code>0</code>，也就阻止了发送方再发数据过来。等到接收方处理了一些数据后，窗口大小 >= MSS，或者接收方缓存空间有一半可以使用，就可以把窗口打开让发送方发送数据过来。</li><li>让发送方避免发送小数据：使用 Nagle 算法，满足1）要等到窗口大小 >= <code>MSS</code> 并且 数据大小 >= <code>MSS</code>；2）收到之前发送数据的 <code>ack</code> 回包；二者之一就发送数据，否则一直囤积数据。</li></ul><p><strong>接收方得满足「不通告小窗口给发送方」+ 发送方开启 Nagle 算法，才能避免糊涂窗口综合症</strong>。</p></li></ul><h4 id=44-拥塞控制>4.4 拥塞控制<a hidden class=anchor aria-hidden=true href=#44-拥塞控制>#</a></h4><ul><li><p>为什么要有拥塞控制呀，不是有流量控制了吗？</p><p>流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。</p><p><strong>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大&mldr;.</strong></p></li><li><p>什么是拥塞窗口？和发送窗口有什么关系呢？</p><p><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。</p><p>发送窗口 <code>swnd</code> 和接收窗口 <code>rwnd</code> 是约等于的关系，加入了拥塞窗口的概念后，此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。只要网络中没有出现拥塞，<code>cwnd</code> 就会增大；但网络中出现了拥塞，<code>cwnd</code> 就减少。</p></li><li><p>拥塞控制算法：cwnd初始大小为10，ssthresh初始大小为65535字节。</p><ul><li><p>慢启动：<strong>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。</strong></p></li><li><p>拥塞避免：当拥塞窗口 <code>cwnd</code> 「超过」慢启动门限 <code>ssthresh</code> 就会进入拥塞避免算法。<strong>每当收到一个 ACK 时，cwnd 增加 1/cwnd。</strong></p></li><li><p>拥塞发生：拥塞发生后触发超时重传机制，此时<code>ssthresh</code> 会设为 <code>cwnd/2</code>，<code>cwnd</code> 重置为 <code>初始值</code>，重新开始慢启动。</p></li><li><p>快速恢复：拥塞发生后触发快速重传机制（快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 <code>RTO</code> 超时那么强烈），此时<code>cwnd = cwnd/2</code> ，也就是设置为原来的一半；ssthresh = cwnd`；然后进入快速恢复算法：</p><ul><li><p>拥塞窗口 <code>cwnd = ssthresh + 3</code> （ 3 的意思是确认有 3 个数据包被收到了）</p></li><li><p>重传丢失的数据包；</p></li><li><p>如果再收到重复的 ACK，那么 cwnd 增加 1；</p></li><li><p>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态。</p></li></ul></li></ul></li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://roaraeonliou.github.io/posts/interviewnotes/redis/redis%E8%A1%A5%E5%85%85/><span class=title>« Prev</span><br><span>Redis补充</span>
</a><a class=next href=https://roaraeonliou.github.io/posts/interviewnotes/designmode/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/><span class=title>Next »</span><br><span>创建型模式</span></a></nav></footer><div id=comments><script src=https://giscus.app/client.js data-repo=RoaraeonLiou/roaraeonliou.github.io data-repo-id=R_kgDOMIxQ4w data-category=Announcements data-category-id=DIC_kwDOMIxQ484CgZUR data-mapping=title data-strict=1 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2024 <a href=https://roaraeonliou.github.io/>RLTEA BLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>