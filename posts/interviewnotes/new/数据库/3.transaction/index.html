<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>3.Transaction | RLTEA BLOG</title>
<meta name=keywords content><meta name=description content="3.1 事务的特性

原子性：一个事务中的操作要么全部完成，要么全部不完成。
一致性：事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。
隔离性：数据库允许多个并发事务的同时，防止多个事务并发时由于交叉执行而导致数据不一致。
持久性：事务处理结束后，对数据的修改是永久的。

InnoDB通过redo log保证持久性，通过undo log保证原子性，隔离性通过MVCC机制或锁机制保证，一致性则通过持久性+原子性+隔离性来保证。
3.2 并发事务会引发什么问题
脏读
如果一个事务读到了另一个事务还没有提交的修改数据，就意味着发生了脏读。
不可重复度
在一次事务内多次读取同一个数据，如果出现两次读到的数据不一致的情况，就意味着发生了不可重复读现象。
幻读
在一个事务内多次查询某个符合查询条件的记录数量，如果出现前后两次查询到的记录数量不一致的情况，就意味着发生了幻读现象。
3.3 事务的隔离级别

读未提交（*read uncommitted*），指一个事务还没提交时，它做的变更就能被其他事务看到；
读提交（*read committed*），指一个事务提交之后，它做的变更才能被其他事务看到；
可重复读（*repeatable read*），指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别；
串行化（*serializable* ）；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；

MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了：

针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。
针对当前读（select &mldr; for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select &mldr; for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。

3.4 Read View在MVCC中如何工作？
Read View中的四个字段


m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的事务 id 列表，注意是一个列表，“活跃事务”指的就是，启动了但还没提交的事务。
min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 id 最小的事务，也就是 m_ids 的最小值。
max_trx_id ：这个并不是 m_ids 的最大值，而是创建 Read View 时当前数据库中应该给下一个事务的 id 值，也就是全局事务中最大的事务 id 值 + 1；
creator_trx_id ：指的是创建该 Read View 的事务的事务 id。

聚簇索引记录的两个隐藏列


trx_id，当一个事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在 trx_id 隐藏列里；
roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后这个隐藏列是个指针，指向每一个旧版本记录，于是就可以通过它找到修改前的记录。

一个事务去访问记录时，除了自己更新的记录总是可见的之外："><meta name=author content="RLTEA"><link rel=canonical href=https://roaraeonliou.github.io/posts/interviewnotes/new/%E6%95%B0%E6%8D%AE%E5%BA%93/3.transaction/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.258803b0f0cc9a4a109c6fe78a9d39f2e0437217d71c5c9848255af9250f2b1b.css integrity="sha256-JYgDsPDMmkoQnG/nip058uBDchfXHFyYSCVa+SUPKxs=" rel="preload stylesheet" as=style><link rel=icon href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://roaraeonliou.github.io/posts/interviewnotes/new/%E6%95%B0%E6%8D%AE%E5%BA%93/3.transaction/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="3.Transaction"><meta property="og:description" content="3.1 事务的特性

原子性：一个事务中的操作要么全部完成，要么全部不完成。
一致性：事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。
隔离性：数据库允许多个并发事务的同时，防止多个事务并发时由于交叉执行而导致数据不一致。
持久性：事务处理结束后，对数据的修改是永久的。

InnoDB通过redo log保证持久性，通过undo log保证原子性，隔离性通过MVCC机制或锁机制保证，一致性则通过持久性+原子性+隔离性来保证。
3.2 并发事务会引发什么问题
脏读
如果一个事务读到了另一个事务还没有提交的修改数据，就意味着发生了脏读。
不可重复度
在一次事务内多次读取同一个数据，如果出现两次读到的数据不一致的情况，就意味着发生了不可重复读现象。
幻读
在一个事务内多次查询某个符合查询条件的记录数量，如果出现前后两次查询到的记录数量不一致的情况，就意味着发生了幻读现象。
3.3 事务的隔离级别

读未提交（*read uncommitted*），指一个事务还没提交时，它做的变更就能被其他事务看到；
读提交（*read committed*），指一个事务提交之后，它做的变更才能被其他事务看到；
可重复读（*repeatable read*），指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别；
串行化（*serializable* ）；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；

MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了：

针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。
针对当前读（select &mldr; for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select &mldr; for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。

3.4 Read View在MVCC中如何工作？
Read View中的四个字段


m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的事务 id 列表，注意是一个列表，“活跃事务”指的就是，启动了但还没提交的事务。
min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 id 最小的事务，也就是 m_ids 的最小值。
max_trx_id ：这个并不是 m_ids 的最大值，而是创建 Read View 时当前数据库中应该给下一个事务的 id 值，也就是全局事务中最大的事务 id 值 + 1；
creator_trx_id ：指的是创建该 Read View 的事务的事务 id。

聚簇索引记录的两个隐藏列


trx_id，当一个事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在 trx_id 隐藏列里；
roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后这个隐藏列是个指针，指向每一个旧版本记录，于是就可以通过它找到修改前的记录。

一个事务去访问记录时，除了自己更新的记录总是可见的之外："><meta property="og:type" content="article"><meta property="og:url" content="https://roaraeonliou.github.io/posts/interviewnotes/new/%E6%95%B0%E6%8D%AE%E5%BA%93/3.transaction/"><meta property="og:image" content="https://roaraeonliou.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-26T00:00:00+00:00"><meta property="article:modified_time" content="2024-09-26T00:00:00+00:00"><meta property="og:site_name" content="RLTEA BLOG"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://roaraeonliou.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="3.Transaction"><meta name=twitter:description content="3.1 事务的特性

原子性：一个事务中的操作要么全部完成，要么全部不完成。
一致性：事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。
隔离性：数据库允许多个并发事务的同时，防止多个事务并发时由于交叉执行而导致数据不一致。
持久性：事务处理结束后，对数据的修改是永久的。

InnoDB通过redo log保证持久性，通过undo log保证原子性，隔离性通过MVCC机制或锁机制保证，一致性则通过持久性+原子性+隔离性来保证。
3.2 并发事务会引发什么问题
脏读
如果一个事务读到了另一个事务还没有提交的修改数据，就意味着发生了脏读。
不可重复度
在一次事务内多次读取同一个数据，如果出现两次读到的数据不一致的情况，就意味着发生了不可重复读现象。
幻读
在一个事务内多次查询某个符合查询条件的记录数量，如果出现前后两次查询到的记录数量不一致的情况，就意味着发生了幻读现象。
3.3 事务的隔离级别

读未提交（*read uncommitted*），指一个事务还没提交时，它做的变更就能被其他事务看到；
读提交（*read committed*），指一个事务提交之后，它做的变更才能被其他事务看到；
可重复读（*repeatable read*），指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别；
串行化（*serializable* ）；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；

MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了：

针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。
针对当前读（select &mldr; for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select &mldr; for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。

3.4 Read View在MVCC中如何工作？
Read View中的四个字段


m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的事务 id 列表，注意是一个列表，“活跃事务”指的就是，启动了但还没提交的事务。
min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 id 最小的事务，也就是 m_ids 的最小值。
max_trx_id ：这个并不是 m_ids 的最大值，而是创建 Read View 时当前数据库中应该给下一个事务的 id 值，也就是全局事务中最大的事务 id 值 + 1；
creator_trx_id ：指的是创建该 Read View 的事务的事务 id。

聚簇索引记录的两个隐藏列


trx_id，当一个事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在 trx_id 隐藏列里；
roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后这个隐藏列是个指针，指向每一个旧版本记录，于是就可以通过它找到修改前的记录。

一个事务去访问记录时，除了自己更新的记录总是可见的之外："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://roaraeonliou.github.io/posts/"},{"@type":"ListItem","position":2,"name":"3.Transaction","item":"https://roaraeonliou.github.io/posts/interviewnotes/new/%E6%95%B0%E6%8D%AE%E5%BA%93/3.transaction/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"3.Transaction","name":"3.Transaction","description":"3.1 事务的特性 原子性：一个事务中的操作要么全部完成，要么全部不完成。 一致性：事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。 隔离性：数据库允许多个并发事务的同时，防止多个事务并发时由于交叉执行而导致数据不一致。 持久性：事务处理结束后，对数据的修改是永久的。 InnoDB通过redo log保证持久性，通过undo log保证原子性，隔离性通过MVCC机制或锁机制保证，一致性则通过持久性+原子性+隔离性来保证。\n3.2 并发事务会引发什么问题 脏读 如果一个事务读到了另一个事务还没有提交的修改数据，就意味着发生了脏读。\n不可重复度 在一次事务内多次读取同一个数据，如果出现两次读到的数据不一致的情况，就意味着发生了不可重复读现象。\n幻读 在一个事务内多次查询某个符合查询条件的记录数量，如果出现前后两次查询到的记录数量不一致的情况，就意味着发生了幻读现象。\n3.3 事务的隔离级别 读未提交（*read uncommitted*），指一个事务还没提交时，它做的变更就能被其他事务看到； 读提交（*read committed*），指一个事务提交之后，它做的变更才能被其他事务看到； 可重复读（*repeatable read*），指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别； 串行化（*serializable* ）；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行； MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了：\n针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。 针对当前读（select \u0026hellip; for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select \u0026hellip; for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。 3.4 Read View在MVCC中如何工作？ Read View中的四个字段 m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的事务 id 列表，注意是一个列表，“活跃事务”指的就是，启动了但还没提交的事务。 min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 id 最小的事务，也就是 m_ids 的最小值。 max_trx_id ：这个并不是 m_ids 的最大值，而是创建 Read View 时当前数据库中应该给下一个事务的 id 值，也就是全局事务中最大的事务 id 值 + 1； creator_trx_id ：指的是创建该 Read View 的事务的事务 id。 聚簇索引记录的两个隐藏列 trx_id，当一个事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在 trx_id 隐藏列里； roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后这个隐藏列是个指针，指向每一个旧版本记录，于是就可以通过它找到修改前的记录。 一个事务去访问记录时，除了自己更新的记录总是可见的之外：\n","keywords":[],"articleBody":"3.1 事务的特性 原子性：一个事务中的操作要么全部完成，要么全部不完成。 一致性：事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。 隔离性：数据库允许多个并发事务的同时，防止多个事务并发时由于交叉执行而导致数据不一致。 持久性：事务处理结束后，对数据的修改是永久的。 InnoDB通过redo log保证持久性，通过undo log保证原子性，隔离性通过MVCC机制或锁机制保证，一致性则通过持久性+原子性+隔离性来保证。\n3.2 并发事务会引发什么问题 脏读 如果一个事务读到了另一个事务还没有提交的修改数据，就意味着发生了脏读。\n不可重复度 在一次事务内多次读取同一个数据，如果出现两次读到的数据不一致的情况，就意味着发生了不可重复读现象。\n幻读 在一个事务内多次查询某个符合查询条件的记录数量，如果出现前后两次查询到的记录数量不一致的情况，就意味着发生了幻读现象。\n3.3 事务的隔离级别 读未提交（*read uncommitted*），指一个事务还没提交时，它做的变更就能被其他事务看到； 读提交（*read committed*），指一个事务提交之后，它做的变更才能被其他事务看到； 可重复读（*repeatable read*），指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别； 串行化（*serializable* ）；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行； MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了：\n针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。 针对当前读（select … for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。 3.4 Read View在MVCC中如何工作？ Read View中的四个字段 m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的事务 id 列表，注意是一个列表，“活跃事务”指的就是，启动了但还没提交的事务。 min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 id 最小的事务，也就是 m_ids 的最小值。 max_trx_id ：这个并不是 m_ids 的最大值，而是创建 Read View 时当前数据库中应该给下一个事务的 id 值，也就是全局事务中最大的事务 id 值 + 1； creator_trx_id ：指的是创建该 Read View 的事务的事务 id。 聚簇索引记录的两个隐藏列 trx_id，当一个事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在 trx_id 隐藏列里； roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后这个隐藏列是个指针，指向每一个旧版本记录，于是就可以通过它找到修改前的记录。 一个事务去访问记录时，除了自己更新的记录总是可见的之外：\n如果记录的trx_id值小于Read View中的min_trx_id值，则表示这个版本的记录是在创建Read View之前就已经提交的事务生成的，所以可见; 如果记录的trx_id值大于等于Read View中的min_trx_id值，则表示这个版本记录是在创建Read View之后才启动的事务生成的，所以该版本记录对当前事务不可见; 如果记录的trx_id值在Read View的min_trx_id和max_trx_id之间，需要判断trx_id是否在m_ids中： 如果trx_id在m_ids中，表示生成该版本记录的活跃事务依然活跃，所以该版本记录不可见 如果不在m_ids中，表示该版本记录的活跃事务已经被提交，所以该版本记录对当前事务可见. 这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。\n3.5 可重复读是如何工作的 可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View。\n3.6 读已提交是如何工作的 读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View。\n3.7 幻读现象 案例1 在可重复读隔离级别下，事务 A 第一次执行普通的 select 语句时生成了一个 ReadView，之后事务 B 向表中新插入了一条 id = 5 的记录并提交。接着，事务 A 对 id = 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。\n因为这种特殊现象的存在，所以我们认为 MySQL Innodb 中的 MVCC 并不能完全避免幻读现象。\n案例2 T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id \u003e 100 得到了 3 条记录。 T2 时刻：事务 B 往插入一个 id= 200 的记录并提交； T3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id \u003e 100 for update 就会得到 4 条记录，此时也发生了幻读现象。 要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select … for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。\nMySQL 可重复读隔离级别并没有彻底解决幻读，只是很大程度上避免了幻读现象的发生。\n","wordCount":"213","inLanguage":"en","image":"https://roaraeonliou.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-09-26T00:00:00Z","dateModified":"2024-09-26T00:00:00Z","author":{"@type":"Person","name":"RLTEA"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://roaraeonliou.github.io/posts/interviewnotes/new/%E6%95%B0%E6%8D%AE%E5%BA%93/3.transaction/"},"publisher":{"@type":"Organization","name":"RLTEA BLOG","logo":{"@type":"ImageObject","url":"https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E"}}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["\\(","\\)"],["$","$"]]}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://roaraeonliou.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://roaraeonliou.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://roaraeonliou.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://roaraeonliou.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://roaraeonliou.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://roaraeonliou.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://roaraeonliou.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://roaraeonliou.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">3.Transaction</h1><div class=post-meta><span title='2024-09-26 00:00:00 +0000 UTC'>September 26, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;213 words&nbsp;·&nbsp;RLTEA&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/InterviewNotes/new/%e6%95%b0%e6%8d%ae%e5%ba%93/3.Transaction.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#31-%e4%ba%8b%e5%8a%a1%e7%9a%84%e7%89%b9%e6%80%a7 aria-label="3.1 事务的特性">3.1 事务的特性</a></li><li><a href=#32-%e5%b9%b6%e5%8f%91%e4%ba%8b%e5%8a%a1%e4%bc%9a%e5%bc%95%e5%8f%91%e4%bb%80%e4%b9%88%e9%97%ae%e9%a2%98 aria-label="3.2 并发事务会引发什么问题">3.2 并发事务会引发什么问题</a><ul><ul><li><a href=#%e8%84%8f%e8%af%bb aria-label=脏读>脏读</a></li><li><a href=#%e4%b8%8d%e5%8f%af%e9%87%8d%e5%a4%8d%e5%ba%a6 aria-label=不可重复度>不可重复度</a></li><li><a href=#%e5%b9%bb%e8%af%bb aria-label=幻读>幻读</a></li></ul></ul></li><li><a href=#33-%e4%ba%8b%e5%8a%a1%e7%9a%84%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab aria-label="3.3 事务的隔离级别">3.3 事务的隔离级别</a></li><li><a href=#34-read-view%e5%9c%a8mvcc%e4%b8%ad%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c aria-label="3.4 Read View在MVCC中如何工作？">3.4 Read View在MVCC中如何工作？</a><ul><ul><li><a href=#read-view%e4%b8%ad%e7%9a%84%e5%9b%9b%e4%b8%aa%e5%ad%97%e6%ae%b5 aria-label="Read View中的四个字段">Read View中的四个字段</a></li><li><a href=#%e8%81%9a%e7%b0%87%e7%b4%a2%e5%bc%95%e8%ae%b0%e5%bd%95%e7%9a%84%e4%b8%a4%e4%b8%aa%e9%9a%90%e8%97%8f%e5%88%97 aria-label=聚簇索引记录的两个隐藏列>聚簇索引记录的两个隐藏列</a></li></ul></ul></li><li><a href=#35-%e5%8f%af%e9%87%8d%e5%a4%8d%e8%af%bb%e6%98%af%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c%e7%9a%84 aria-label="3.5 可重复读是如何工作的">3.5 可重复读是如何工作的</a></li><li><a href=#36-%e8%af%bb%e5%b7%b2%e6%8f%90%e4%ba%a4%e6%98%af%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c%e7%9a%84 aria-label="3.6 读已提交是如何工作的">3.6 读已提交是如何工作的</a></li><li><a href=#37-%e5%b9%bb%e8%af%bb%e7%8e%b0%e8%b1%a1 aria-label="3.7 幻读现象">3.7 幻读现象</a><ul><ul><li><a href=#%e6%a1%88%e4%be%8b1 aria-label=案例1>案例1</a></li><li><a href=#%e6%a1%88%e4%be%8b2 aria-label=案例2>案例2</a></li></ul></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=31-事务的特性>3.1 事务的特性<a hidden class=anchor aria-hidden=true href=#31-事务的特性>#</a></h2><ul><li>原子性：一个事务中的操作要么全部完成，要么全部不完成。</li><li>一致性：事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。</li><li>隔离性：数据库允许多个并发事务的同时，防止多个事务并发时由于交叉执行而导致数据不一致。</li><li>持久性：事务处理结束后，对数据的修改是永久的。</li></ul><p>InnoDB通过redo log保证持久性，通过undo log保证原子性，隔离性通过MVCC机制或锁机制保证，一致性则通过持久性+原子性+隔离性来保证。</p><h2 id=32-并发事务会引发什么问题>3.2 并发事务会引发什么问题<a hidden class=anchor aria-hidden=true href=#32-并发事务会引发什么问题>#</a></h2><h4 id=脏读>脏读<a hidden class=anchor aria-hidden=true href=#脏读>#</a></h4><p>如果一个事务读到了另一个事务还没有提交的修改数据，就意味着发生了脏读。</p><h4 id=不可重复度>不可重复度<a hidden class=anchor aria-hidden=true href=#不可重复度>#</a></h4><p>在一次事务内多次读取同一个数据，如果出现两次读到的数据不一致的情况，就意味着发生了不可重复读现象。</p><h4 id=幻读>幻读<a hidden class=anchor aria-hidden=true href=#幻读>#</a></h4><p>在一个事务内多次查询某个符合查询条件的<strong>记录数量</strong>，如果出现前后两次查询到的记录数量不一致的情况，就意味着发生了幻读现象。</p><h2 id=33-事务的隔离级别>3.3 事务的隔离级别<a hidden class=anchor aria-hidden=true href=#33-事务的隔离级别>#</a></h2><ul><li><strong>读未提交（*read uncommitted*）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到；</li><li><strong>读提交（*read committed*）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到；</li><li><strong>可重复读（*repeatable read*）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>；</li><li><strong>串行化（*serializable* ）</strong>；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li></ul><p><strong>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了</strong>：</p><ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li><li>针对<strong>当前读</strong>（select &mldr; for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select &mldr; for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li></ul><h2 id=34-read-view在mvcc中如何工作>3.4 Read View在MVCC中如何工作？<a hidden class=anchor aria-hidden=true href=#34-read-view在mvcc中如何工作>#</a></h2><h4 id=read-view中的四个字段>Read View中的四个字段<a hidden class=anchor aria-hidden=true href=#read-view中的四个字段>#</a></h4><ul><li>m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的<strong>事务 id 列表</strong>，注意是一个列表，<strong>“活跃事务”指的就是，启动了但还没提交的事务</strong>。</li><li>min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 <strong>id 最小的事务</strong>，也就是 m_ids 的最小值。</li><li>max_trx_id ：这个并不是 m_ids 的最大值，而是<strong>创建 Read View 时当前数据库中应该给下一个事务的 id 值</strong>，也就是全局事务中最大的事务 id 值 + 1；</li><li>creator_trx_id ：指的是<strong>创建该 Read View 的事务的事务 id</strong>。</li></ul><h4 id=聚簇索引记录的两个隐藏列>聚簇索引记录的两个隐藏列<a hidden class=anchor aria-hidden=true href=#聚簇索引记录的两个隐藏列>#</a></h4><ul><li>trx_id，当一个事务对某条聚簇索引记录进行改动时，就会<strong>把该事务的事务 id 记录在 trx_id 隐藏列里</strong>；</li><li>roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后<strong>这个隐藏列是个指针，指向每一个旧版本记录</strong>，于是就可以通过它找到修改前的记录。</li></ul><p>一个事务去访问记录时，除了自己更新的记录总是可见的之外：</p><ul><li>如果记录的trx_id值小于Read View中的min_trx_id值，则表示这个版本的记录是在创建Read View之前就已经提交的事务生成的，所以可见;</li><li>如果记录的trx_id值大于等于Read View中的min_trx_id值，则表示这个版本记录是在创建Read View之后才启动的事务生成的，所以该版本记录对当前事务不可见;</li><li>如果记录的trx_id值在Read View的min_trx_id和max_trx_id之间，需要判断trx_id是否在m_ids中：<ul><li>如果trx_id在m_ids中，表示生成该版本记录的活跃事务依然活跃，所以该版本记录不可见</li><li>如果不在m_ids中，表示该版本记录的活跃事务已经被提交，所以该版本记录对当前事务可见.</li></ul></li></ul><p><strong>这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。</strong></p><h2 id=35-可重复读是如何工作的>3.5 可重复读是如何工作的<a hidden class=anchor aria-hidden=true href=#35-可重复读是如何工作的>#</a></h2><p><strong>可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View</strong>。</p><h2 id=36-读已提交是如何工作的>3.6 读已提交是如何工作的<a hidden class=anchor aria-hidden=true href=#36-读已提交是如何工作的>#</a></h2><p><strong>读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View</strong>。</p><h2 id=37-幻读现象>3.7 幻读现象<a hidden class=anchor aria-hidden=true href=#37-幻读现象>#</a></h2><h4 id=案例1>案例1<a hidden class=anchor aria-hidden=true href=#案例1>#</a></h4><p>在可重复读隔离级别下，事务 A 第一次执行普通的 select 语句时生成了一个 ReadView，之后事务 B 向表中新插入了一条 id = 5 的记录并提交。接着，事务 A 对 id = 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了，于是就发生了幻读。</p><p>因为这种特殊现象的存在，所以我们认为 <strong>MySQL Innodb 中的 MVCC 并不能完全避免幻读现象</strong>。</p><h4 id=案例2>案例2<a hidden class=anchor aria-hidden=true href=#案例2>#</a></h4><ul><li>T1 时刻：事务 A 先执行「快照读语句」：select * from t_test where id > 100 得到了 3 条记录。</li><li>T2 时刻：事务 B 往插入一个 id= 200 的记录并提交；</li><li>T3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id > 100 for update 就会得到 4 条记录，此时也发生了幻读现象。</li></ul><p><strong>要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select &mldr; for update 这类当前读的语句</strong>，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。</p><p><strong>MySQL 可重复读隔离级别并没有彻底解决幻读，只是很大程度上避免了幻读现象的发生。</strong></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://roaraeonliou.github.io/posts/interviewnotes/new/java/3.juc/><span class=title>« Prev</span><br><span>3.JUC</span>
</a><a class=next href=https://roaraeonliou.github.io/posts/interviewnotes/new/java/4.jvm/><span class=title>Next »</span><br><span>4.JVM</span></a></nav></footer><div id=comments><script src=https://giscus.app/client.js data-repo=RoaraeonLiou/roaraeonliou.github.io data-repo-id=R_kgDOMIxQ4w data-category=Announcements data-category-id=DIC_kwDOMIxQ484CgZUR data-mapping=title data-strict=1 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2024 <a href=https://roaraeonliou.github.io/>RLTEA BLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>