<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>5.Log | RLTEA BLOG</title>
<meta name=keywords content><meta name=description content="5.1 Undo Log
用于保证事务ACID中的原子性。
事务没提交时，会将记录更新前的数据记录到undo log日志文件中。

插入：记录主键值
删除：记录这条记录全部内容
更新：记录这条记录旧值

一条记录的每一次更新操作产生的undo log格式都有一个roll_pointer和trx_id指针，分别用于将undo log串成链表和记录被哪个事务所修改。
所以undo log还可以和ReadView配合实现MVCC。
作用：

实现事务回滚，保障事务的原子性。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。
实现 MVCC（多版本并发控制）关键因素之一。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。

5.2 Redo Log
redo log用于保证ACID中的持久性。
由于更新数据会先写入Buffer Pool，而内存是不可靠的，所以为了防止断电导致数据丢失，InnoDB会先更新内存，然后将本次对这个页的修改以redo log的形式记录，后续在适当的时候，后台线程再将Buffer Pool中的脏页刷到磁盘中，这就是WAL（Write-Ahead Logging）技术。
WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上。
redo log是物理日志，记录某个数据页做了什么修改，每执行一个事务就会产生这样一条或者多条物理日志，事务提交时，只需要将redo log持久化到磁盘即可，不需要等待buffer pool中的脏页持久化。
这样即使系统崩溃，虽然脏页没有持久化，但是MySQL可以根据redo log的内容，将数据恢复到最新状态。
被修改的Undo页面，需要记录对应的redo log。在内存修改该 Undo 页面后，需要记录对应的 redo log。

redo log 和 undo log区别：

两种日志都是存储引擎日志
redo log 记录了此次事务「完成后」的状态，记录的是更新之后的值。
undo log 记录了此次事务「开始前」的状态，记录的是更新之前的值。




写入 redo log 的方式使用了追加操作， 所以磁盘操作是顺序写，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是随机写。"><meta name=author content="RLTEA"><link rel=canonical href=https://roaraeonliou.github.io/posts/interviewnotes/new/%E6%95%B0%E6%8D%AE%E5%BA%93/5.log/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.258803b0f0cc9a4a109c6fe78a9d39f2e0437217d71c5c9848255af9250f2b1b.css integrity="sha256-JYgDsPDMmkoQnG/nip058uBDchfXHFyYSCVa+SUPKxs=" rel="preload stylesheet" as=style><link rel=icon href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://roaraeonliou.github.io/posts/interviewnotes/new/%E6%95%B0%E6%8D%AE%E5%BA%93/5.log/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="5.Log"><meta property="og:description" content="5.1 Undo Log
用于保证事务ACID中的原子性。
事务没提交时，会将记录更新前的数据记录到undo log日志文件中。

插入：记录主键值
删除：记录这条记录全部内容
更新：记录这条记录旧值

一条记录的每一次更新操作产生的undo log格式都有一个roll_pointer和trx_id指针，分别用于将undo log串成链表和记录被哪个事务所修改。
所以undo log还可以和ReadView配合实现MVCC。
作用：

实现事务回滚，保障事务的原子性。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。
实现 MVCC（多版本并发控制）关键因素之一。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。

5.2 Redo Log
redo log用于保证ACID中的持久性。
由于更新数据会先写入Buffer Pool，而内存是不可靠的，所以为了防止断电导致数据丢失，InnoDB会先更新内存，然后将本次对这个页的修改以redo log的形式记录，后续在适当的时候，后台线程再将Buffer Pool中的脏页刷到磁盘中，这就是WAL（Write-Ahead Logging）技术。
WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上。
redo log是物理日志，记录某个数据页做了什么修改，每执行一个事务就会产生这样一条或者多条物理日志，事务提交时，只需要将redo log持久化到磁盘即可，不需要等待buffer pool中的脏页持久化。
这样即使系统崩溃，虽然脏页没有持久化，但是MySQL可以根据redo log的内容，将数据恢复到最新状态。
被修改的Undo页面，需要记录对应的redo log。在内存修改该 Undo 页面后，需要记录对应的 redo log。

redo log 和 undo log区别：

两种日志都是存储引擎日志
redo log 记录了此次事务「完成后」的状态，记录的是更新之后的值。
undo log 记录了此次事务「开始前」的状态，记录的是更新之前的值。




写入 redo log 的方式使用了追加操作， 所以磁盘操作是顺序写，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是随机写。"><meta property="og:type" content="article"><meta property="og:url" content="https://roaraeonliou.github.io/posts/interviewnotes/new/%E6%95%B0%E6%8D%AE%E5%BA%93/5.log/"><meta property="og:image" content="https://roaraeonliou.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-26T00:00:00+00:00"><meta property="article:modified_time" content="2024-09-26T00:00:00+00:00"><meta property="og:site_name" content="RLTEA BLOG"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://roaraeonliou.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="5.Log"><meta name=twitter:description content="5.1 Undo Log
用于保证事务ACID中的原子性。
事务没提交时，会将记录更新前的数据记录到undo log日志文件中。

插入：记录主键值
删除：记录这条记录全部内容
更新：记录这条记录旧值

一条记录的每一次更新操作产生的undo log格式都有一个roll_pointer和trx_id指针，分别用于将undo log串成链表和记录被哪个事务所修改。
所以undo log还可以和ReadView配合实现MVCC。
作用：

实现事务回滚，保障事务的原子性。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。
实现 MVCC（多版本并发控制）关键因素之一。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。

5.2 Redo Log
redo log用于保证ACID中的持久性。
由于更新数据会先写入Buffer Pool，而内存是不可靠的，所以为了防止断电导致数据丢失，InnoDB会先更新内存，然后将本次对这个页的修改以redo log的形式记录，后续在适当的时候，后台线程再将Buffer Pool中的脏页刷到磁盘中，这就是WAL（Write-Ahead Logging）技术。
WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上。
redo log是物理日志，记录某个数据页做了什么修改，每执行一个事务就会产生这样一条或者多条物理日志，事务提交时，只需要将redo log持久化到磁盘即可，不需要等待buffer pool中的脏页持久化。
这样即使系统崩溃，虽然脏页没有持久化，但是MySQL可以根据redo log的内容，将数据恢复到最新状态。
被修改的Undo页面，需要记录对应的redo log。在内存修改该 Undo 页面后，需要记录对应的 redo log。

redo log 和 undo log区别：

两种日志都是存储引擎日志
redo log 记录了此次事务「完成后」的状态，记录的是更新之后的值。
undo log 记录了此次事务「开始前」的状态，记录的是更新之前的值。




写入 redo log 的方式使用了追加操作， 所以磁盘操作是顺序写，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是随机写。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://roaraeonliou.github.io/posts/"},{"@type":"ListItem","position":2,"name":"5.Log","item":"https://roaraeonliou.github.io/posts/interviewnotes/new/%E6%95%B0%E6%8D%AE%E5%BA%93/5.log/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"5.Log","name":"5.Log","description":"5.1 Undo Log 用于保证事务ACID中的原子性。\n事务没提交时，会将记录更新前的数据记录到undo log日志文件中。\n插入：记录主键值 删除：记录这条记录全部内容 更新：记录这条记录旧值 一条记录的每一次更新操作产生的undo log格式都有一个roll_pointer和trx_id指针，分别用于将undo log串成链表和记录被哪个事务所修改。\n所以undo log还可以和ReadView配合实现MVCC。\n作用：\n实现事务回滚，保障事务的原子性。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。 实现 MVCC（多版本并发控制）关键因素之一。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。 5.2 Redo Log redo log用于保证ACID中的持久性。\n由于更新数据会先写入Buffer Pool，而内存是不可靠的，所以为了防止断电导致数据丢失，InnoDB会先更新内存，然后将本次对这个页的修改以redo log的形式记录，后续在适当的时候，后台线程再将Buffer Pool中的脏页刷到磁盘中，这就是WAL（Write-Ahead Logging）技术。\nWAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上。\nredo log是物理日志，记录某个数据页做了什么修改，每执行一个事务就会产生这样一条或者多条物理日志，事务提交时，只需要将redo log持久化到磁盘即可，不需要等待buffer pool中的脏页持久化。\n这样即使系统崩溃，虽然脏页没有持久化，但是MySQL可以根据redo log的内容，将数据恢复到最新状态。\n被修改的Undo页面，需要记录对应的redo log。在内存修改该 Undo 页面后，需要记录对应的 redo log。\nredo log 和 undo log区别： 两种日志都是存储引擎日志 redo log 记录了此次事务「完成后」的状态，记录的是更新之后的值。 undo log 记录了此次事务「开始前」的状态，记录的是更新之前的值。 写入 redo log 的方式使用了追加操作， 所以磁盘操作是顺序写，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是随机写。\n","keywords":[],"articleBody":"5.1 Undo Log 用于保证事务ACID中的原子性。\n事务没提交时，会将记录更新前的数据记录到undo log日志文件中。\n插入：记录主键值 删除：记录这条记录全部内容 更新：记录这条记录旧值 一条记录的每一次更新操作产生的undo log格式都有一个roll_pointer和trx_id指针，分别用于将undo log串成链表和记录被哪个事务所修改。\n所以undo log还可以和ReadView配合实现MVCC。\n作用：\n实现事务回滚，保障事务的原子性。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。 实现 MVCC（多版本并发控制）关键因素之一。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。 5.2 Redo Log redo log用于保证ACID中的持久性。\n由于更新数据会先写入Buffer Pool，而内存是不可靠的，所以为了防止断电导致数据丢失，InnoDB会先更新内存，然后将本次对这个页的修改以redo log的形式记录，后续在适当的时候，后台线程再将Buffer Pool中的脏页刷到磁盘中，这就是WAL（Write-Ahead Logging）技术。\nWAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上。\nredo log是物理日志，记录某个数据页做了什么修改，每执行一个事务就会产生这样一条或者多条物理日志，事务提交时，只需要将redo log持久化到磁盘即可，不需要等待buffer pool中的脏页持久化。\n这样即使系统崩溃，虽然脏页没有持久化，但是MySQL可以根据redo log的内容，将数据恢复到最新状态。\n被修改的Undo页面，需要记录对应的redo log。在内存修改该 Undo 页面后，需要记录对应的 redo log。\nredo log 和 undo log区别： 两种日志都是存储引擎日志 redo log 记录了此次事务「完成后」的状态，记录的是更新之后的值。 undo log 记录了此次事务「开始前」的状态，记录的是更新之前的值。 写入 redo log 的方式使用了追加操作， 所以磁盘操作是顺序写，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是随机写。\n磁盘的「顺序写 」比「随机写」 高效的多，因此 redo log 写入磁盘的开销更小。\n作用：\n实现事务的持久性，让 MySQL 有 crash-safe 的能力，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失； 将写操作从「随机写」变成了「顺序写」，提升 MySQL 写入磁盘的性能。 5.2.1 产生的redo log是直接写入磁盘吗？ 不是，redo log有自己的缓存redo log buffer，每产生一条redo log时，会先写入redo log buffer。\n刷盘时机：\nMySQL正常关闭时； 当redo log buffer中写入量大于redo log buffer内存空间（16MB）的一半时； InnoDB的后台线程每隔1s，将redo log buffer持久化到磁盘； 每次事务提交时，都将缓存在redo log buffer中的redo log直接持久化到磁盘。 redo log Group：\nInnoDB存储引擎有一个重做日志文件组，有两个redo log文件组成，每个文件大小固定且一致，以循环写的方式工作。\nwrite pos：表示当前记录写到的位置； check point：表示当前要擦除的位置，因为buffer pool中的脏页已经刷新到了磁盘； 如果write pos追上了check point，此时redo log文件满，MySQL不能执行新的更新操作，会被阻塞，并将Buffer Pool中脏页数据刷到磁盘，然后标记可以擦除的记录。 5.3 Bin Log 5.4 两阶段提交 5.5 磁盘IO高怎么办 ","wordCount":"148","inLanguage":"en","image":"https://roaraeonliou.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-09-26T00:00:00Z","dateModified":"2024-09-26T00:00:00Z","author":{"@type":"Person","name":"RLTEA"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://roaraeonliou.github.io/posts/interviewnotes/new/%E6%95%B0%E6%8D%AE%E5%BA%93/5.log/"},"publisher":{"@type":"Organization","name":"RLTEA BLOG","logo":{"@type":"ImageObject","url":"https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E"}}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["\\(","\\)"],["$","$"]]}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://roaraeonliou.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://roaraeonliou.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://roaraeonliou.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://roaraeonliou.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://roaraeonliou.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://roaraeonliou.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://roaraeonliou.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://roaraeonliou.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">5.Log</h1><div class=post-meta><span title='2024-09-26 00:00:00 +0000 UTC'>September 26, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;148 words&nbsp;·&nbsp;RLTEA&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/InterviewNotes/new/%e6%95%b0%e6%8d%ae%e5%ba%93/5.Log.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#51-undo-log aria-label="5.1 Undo Log">5.1 Undo Log</a></li><li><a href=#52-redo-log aria-label="5.2 Redo Log">5.2 Redo Log</a><ul><ul><li><a href=#521-%e4%ba%a7%e7%94%9f%e7%9a%84redo-log%e6%98%af%e7%9b%b4%e6%8e%a5%e5%86%99%e5%85%a5%e7%a3%81%e7%9b%98%e5%90%97 aria-label="5.2.1 产生的redo log是直接写入磁盘吗？">5.2.1 产生的redo log是直接写入磁盘吗？</a></li></ul></ul></li><li><a href=#53-bin-log aria-label="5.3 Bin Log">5.3 Bin Log</a></li><li><a href=#54-%e4%b8%a4%e9%98%b6%e6%ae%b5%e6%8f%90%e4%ba%a4 aria-label="5.4 两阶段提交">5.4 两阶段提交</a></li><li><a href=#55-%e7%a3%81%e7%9b%98io%e9%ab%98%e6%80%8e%e4%b9%88%e5%8a%9e aria-label="5.5 磁盘IO高怎么办">5.5 磁盘IO高怎么办</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=51-undo-log>5.1 Undo Log<a hidden class=anchor aria-hidden=true href=#51-undo-log>#</a></h2><p>用于保证事务ACID中的原子性。</p><p>事务没提交时，会将记录更新前的数据记录到undo log日志文件中。</p><ul><li>插入：记录主键值</li><li>删除：记录这条记录全部内容</li><li>更新：记录这条记录旧值</li></ul><p>一条记录的每一次更新操作产生的undo log格式都有一个roll_pointer和trx_id指针，分别用于将undo log串成链表和记录被哪个事务所修改。</p><p><strong>所以undo log还可以和ReadView配合实现MVCC。</strong></p><p>作用：</p><ul><li><strong>实现事务回滚，保障事务的原子性</strong>。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。</li><li><strong>实现 MVCC（多版本并发控制）关键因素之一</strong>。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。</li></ul><h2 id=52-redo-log>5.2 Redo Log<a hidden class=anchor aria-hidden=true href=#52-redo-log>#</a></h2><p>redo log用于保证ACID中的持久性。</p><p>由于更新数据会先写入Buffer Pool，而内存是不可靠的，所以为了防止断电导致数据丢失，InnoDB会先更新内存，然后将本次对这个页的修改以redo log的形式记录，后续在适当的时候，后台线程再将Buffer Pool中的脏页刷到磁盘中，这就是WAL（Write-Ahead Logging）技术。</p><p><strong>WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上</strong>。</p><p>redo log是物理日志，记录某个数据页做了什么修改，每执行一个事务就会产生这样一条或者多条物理日志，事务提交时，只需要将redo log持久化到磁盘即可，不需要等待buffer pool中的脏页持久化。</p><p>这样即使系统崩溃，虽然脏页没有持久化，但是MySQL可以根据redo log的内容，将数据恢复到最新状态。</p><p><strong>被修改的Undo页面，需要记录对应的redo log。在内存修改该 Undo 页面后，需要记录对应的 redo log</strong>。</p><ul><li>redo log 和 undo log区别：<ul><li>两种日志都是存储引擎日志</li><li>redo log 记录了此次事务「完成后」的状态，记录的是更新之后的值。</li><li>undo log 记录了此次事务「开始前」的状态，记录的是更新之前的值。</li></ul></li></ul><p>写入 redo log 的方式使用了追加操作， 所以磁盘操作是<strong>顺序写</strong>，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是<strong>随机写</strong>。</p><p>磁盘的「顺序写 」比「随机写」 高效的多，因此 redo log 写入磁盘的开销更小。</p><p>作用：</p><ul><li><strong>实现事务的持久性，让 MySQL 有 crash-safe 的能力</strong>，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；</li><li><strong>将写操作从「随机写」变成了「顺序写」</strong>，提升 MySQL 写入磁盘的性能。</li></ul><h4 id=521-产生的redo-log是直接写入磁盘吗>5.2.1 产生的redo log是直接写入磁盘吗？<a hidden class=anchor aria-hidden=true href=#521-产生的redo-log是直接写入磁盘吗>#</a></h4><p>不是，redo log有自己的缓存redo log buffer，每产生一条redo log时，会先写入redo log buffer。</p><p>刷盘时机：</p><ul><li>MySQL正常关闭时；</li><li>当redo log buffer中写入量大于redo log buffer内存空间（16MB）的一半时；</li><li>InnoDB的后台线程每隔1s，将redo log buffer持久化到磁盘；</li><li>每次事务提交时，都将缓存在redo log buffer中的redo log直接持久化到磁盘。</li></ul><p>redo log Group：</p><p>InnoDB存储引擎有一个重做日志文件组，有两个redo log文件组成，每个文件大小固定且一致，以循环写的方式工作。</p><ul><li>write pos：表示当前记录写到的位置；</li><li>check point：表示当前要擦除的位置，因为buffer pool中的脏页已经刷新到了磁盘；</li><li>如果write pos追上了check point，此时redo log文件满，MySQL不能执行新的更新操作，会被阻塞，并将Buffer Pool中脏页数据刷到磁盘，然后标记可以擦除的记录。</li></ul><h2 id=53-bin-log>5.3 Bin Log<a hidden class=anchor aria-hidden=true href=#53-bin-log>#</a></h2><h2 id=54-两阶段提交>5.4 两阶段提交<a hidden class=anchor aria-hidden=true href=#54-两阶段提交>#</a></h2><h2 id=55-磁盘io高怎么办>5.5 磁盘IO高怎么办<a hidden class=anchor aria-hidden=true href=#55-磁盘io高怎么办>#</a></h2></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://roaraeonliou.github.io/posts/interviewnotes/new/%E6%95%B0%E6%8D%AE%E5%BA%93/4.lock/><span class=title>« Prev</span><br><span>4.Lock</span>
</a><a class=next href=https://roaraeonliou.github.io/posts/interviewnotes/new/%E6%95%B0%E6%8D%AE%E5%BA%93/6.cache/><span class=title>Next »</span><br><span>6.Cache</span></a></nav></footer><div id=comments><script src=https://giscus.app/client.js data-repo=RoaraeonLiou/roaraeonliou.github.io data-repo-id=R_kgDOMIxQ4w data-category=Announcements data-category-id=DIC_kwDOMIxQ484CgZUR data-mapping=title data-strict=1 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2024 <a href=https://roaraeonliou.github.io/>RLTEA BLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>