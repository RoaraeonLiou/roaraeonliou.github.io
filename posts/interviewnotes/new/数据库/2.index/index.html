<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>2.Index | RLTEA BLOG</title>
<meta name=keywords content><meta name=description content="1 索引基础
1.1 索引的分类
1.1.1 按数据结构分：B+Tree索引、Hash索引、Full-text索引
InnoDB支持B+Tree索引和Full-Text索引，不支持Hash索引但是内存结构中有一个自适应hash索引；
MyISAM支持B+Tree索引和Full-Text索引，但是不支持Hash索引；
Memory支持B+Tree索引和Hash索引，但是不支持Full-Text索引。
InnoDB存储引擎在创建表时：如果有主键，会默认使用主键作为聚簇索引的索引键；如果没有主键，就会选择第一个不包含NULL值的唯一列所谓聚簇索引的索引键；如果都没有则会自动生成一个隐式自增ID作为聚簇索引键。
其他索引都属于辅助索引，也称为二级索引或非聚簇索引。创建的主键索引和二级索引默认使用的都是B+Tree索引。B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4次。
B+Tree 是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每个节点里的数据是按主键顺序存放的。每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个双向链表。
主键索引的 B+Tree 和二级索引的 B+Tree 区别如下：

主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；
二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。

通过二级索引查询会先检二级索引中的 B+Tree 的索引值，找到对应的叶子节点，然后获取主键值，然后再通过主键索引中的 B+Tree 树查询到对应的叶子节点，然后获取整行数据。这个过程叫「回表」，也就是说要查两个 B+Tree 才能查到数据。当查询的数据是能在二级索引的 B+Tree 的叶子节点里查询到，这时就不用再查主键索引查。这种在二级索引的 B+Tree 就能查询到结果的过程就叫作「覆盖索引」，也就是只需要查一个 B+Tree 就能找到数据。

为什么InnoDB选择B+Tree作为索引的数据结构？


B+Tree vs B Tree
B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。


B+Tree vs 二叉树
对于有 N 个叶子节点的 B+Tree，其搜索复杂度为O(logdN)，其中 d 表示节点允许的最大子节点个数为 d 个。"><meta name=author content="RLTEA"><link rel=canonical href=https://roaraeonliou.github.io/posts/interviewnotes/new/%E6%95%B0%E6%8D%AE%E5%BA%93/2.index/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.258803b0f0cc9a4a109c6fe78a9d39f2e0437217d71c5c9848255af9250f2b1b.css integrity="sha256-JYgDsPDMmkoQnG/nip058uBDchfXHFyYSCVa+SUPKxs=" rel="preload stylesheet" as=style><link rel=icon href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://roaraeonliou.github.io/posts/interviewnotes/new/%E6%95%B0%E6%8D%AE%E5%BA%93/2.index/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="2.Index"><meta property="og:description" content="1 索引基础
1.1 索引的分类
1.1.1 按数据结构分：B+Tree索引、Hash索引、Full-text索引
InnoDB支持B+Tree索引和Full-Text索引，不支持Hash索引但是内存结构中有一个自适应hash索引；
MyISAM支持B+Tree索引和Full-Text索引，但是不支持Hash索引；
Memory支持B+Tree索引和Hash索引，但是不支持Full-Text索引。
InnoDB存储引擎在创建表时：如果有主键，会默认使用主键作为聚簇索引的索引键；如果没有主键，就会选择第一个不包含NULL值的唯一列所谓聚簇索引的索引键；如果都没有则会自动生成一个隐式自增ID作为聚簇索引键。
其他索引都属于辅助索引，也称为二级索引或非聚簇索引。创建的主键索引和二级索引默认使用的都是B+Tree索引。B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4次。
B+Tree 是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每个节点里的数据是按主键顺序存放的。每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个双向链表。
主键索引的 B+Tree 和二级索引的 B+Tree 区别如下：

主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；
二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。

通过二级索引查询会先检二级索引中的 B+Tree 的索引值，找到对应的叶子节点，然后获取主键值，然后再通过主键索引中的 B+Tree 树查询到对应的叶子节点，然后获取整行数据。这个过程叫「回表」，也就是说要查两个 B+Tree 才能查到数据。当查询的数据是能在二级索引的 B+Tree 的叶子节点里查询到，这时就不用再查主键索引查。这种在二级索引的 B+Tree 就能查询到结果的过程就叫作「覆盖索引」，也就是只需要查一个 B+Tree 就能找到数据。

为什么InnoDB选择B+Tree作为索引的数据结构？


B+Tree vs B Tree
B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。


B+Tree vs 二叉树
对于有 N 个叶子节点的 B+Tree，其搜索复杂度为O(logdN)，其中 d 表示节点允许的最大子节点个数为 d 个。"><meta property="og:type" content="article"><meta property="og:url" content="https://roaraeonliou.github.io/posts/interviewnotes/new/%E6%95%B0%E6%8D%AE%E5%BA%93/2.index/"><meta property="og:image" content="https://roaraeonliou.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-26T00:00:00+00:00"><meta property="article:modified_time" content="2024-09-26T00:00:00+00:00"><meta property="og:site_name" content="RLTEA BLOG"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://roaraeonliou.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="2.Index"><meta name=twitter:description content="1 索引基础
1.1 索引的分类
1.1.1 按数据结构分：B+Tree索引、Hash索引、Full-text索引
InnoDB支持B+Tree索引和Full-Text索引，不支持Hash索引但是内存结构中有一个自适应hash索引；
MyISAM支持B+Tree索引和Full-Text索引，但是不支持Hash索引；
Memory支持B+Tree索引和Hash索引，但是不支持Full-Text索引。
InnoDB存储引擎在创建表时：如果有主键，会默认使用主键作为聚簇索引的索引键；如果没有主键，就会选择第一个不包含NULL值的唯一列所谓聚簇索引的索引键；如果都没有则会自动生成一个隐式自增ID作为聚簇索引键。
其他索引都属于辅助索引，也称为二级索引或非聚簇索引。创建的主键索引和二级索引默认使用的都是B+Tree索引。B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4次。
B+Tree 是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每个节点里的数据是按主键顺序存放的。每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个双向链表。
主键索引的 B+Tree 和二级索引的 B+Tree 区别如下：

主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；
二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。

通过二级索引查询会先检二级索引中的 B+Tree 的索引值，找到对应的叶子节点，然后获取主键值，然后再通过主键索引中的 B+Tree 树查询到对应的叶子节点，然后获取整行数据。这个过程叫「回表」，也就是说要查两个 B+Tree 才能查到数据。当查询的数据是能在二级索引的 B+Tree 的叶子节点里查询到，这时就不用再查主键索引查。这种在二级索引的 B+Tree 就能查询到结果的过程就叫作「覆盖索引」，也就是只需要查一个 B+Tree 就能找到数据。

为什么InnoDB选择B+Tree作为索引的数据结构？


B+Tree vs B Tree
B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。


B+Tree vs 二叉树
对于有 N 个叶子节点的 B+Tree，其搜索复杂度为O(logdN)，其中 d 表示节点允许的最大子节点个数为 d 个。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://roaraeonliou.github.io/posts/"},{"@type":"ListItem","position":2,"name":"2.Index","item":"https://roaraeonliou.github.io/posts/interviewnotes/new/%E6%95%B0%E6%8D%AE%E5%BA%93/2.index/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"2.Index","name":"2.Index","description":"1 索引基础 1.1 索引的分类 1.1.1 按数据结构分：B+Tree索引、Hash索引、Full-text索引 InnoDB支持B+Tree索引和Full-Text索引，不支持Hash索引但是内存结构中有一个自适应hash索引；\nMyISAM支持B+Tree索引和Full-Text索引，但是不支持Hash索引；\nMemory支持B+Tree索引和Hash索引，但是不支持Full-Text索引。\nInnoDB存储引擎在创建表时：如果有主键，会默认使用主键作为聚簇索引的索引键；如果没有主键，就会选择第一个不包含NULL值的唯一列所谓聚簇索引的索引键；如果都没有则会自动生成一个隐式自增ID作为聚簇索引键。\n其他索引都属于辅助索引，也称为二级索引或非聚簇索引。创建的主键索引和二级索引默认使用的都是B+Tree索引。B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4次。\nB+Tree 是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每个节点里的数据是按主键顺序存放的。每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个双向链表。\n主键索引的 B+Tree 和二级索引的 B+Tree 区别如下：\n主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里； 二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。 通过二级索引查询会先检二级索引中的 B+Tree 的索引值，找到对应的叶子节点，然后获取主键值，然后再通过主键索引中的 B+Tree 树查询到对应的叶子节点，然后获取整行数据。这个过程叫「回表」，也就是说要查两个 B+Tree 才能查到数据。当查询的数据是能在二级索引的 B+Tree 的叶子节点里查询到，这时就不用再查主键索引查。这种在二级索引的 B+Tree 就能查询到结果的过程就叫作「覆盖索引」，也就是只需要查一个 B+Tree 就能找到数据。\n为什么InnoDB选择B+Tree作为索引的数据结构？\nB+Tree vs B Tree\nB+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。\nB+Tree vs 二叉树\n对于有 N 个叶子节点的 B+Tree，其搜索复杂度为O(logdN)，其中 d 表示节点允许的最大子节点个数为 d 个。\n","keywords":[],"articleBody":"1 索引基础 1.1 索引的分类 1.1.1 按数据结构分：B+Tree索引、Hash索引、Full-text索引 InnoDB支持B+Tree索引和Full-Text索引，不支持Hash索引但是内存结构中有一个自适应hash索引；\nMyISAM支持B+Tree索引和Full-Text索引，但是不支持Hash索引；\nMemory支持B+Tree索引和Hash索引，但是不支持Full-Text索引。\nInnoDB存储引擎在创建表时：如果有主键，会默认使用主键作为聚簇索引的索引键；如果没有主键，就会选择第一个不包含NULL值的唯一列所谓聚簇索引的索引键；如果都没有则会自动生成一个隐式自增ID作为聚簇索引键。\n其他索引都属于辅助索引，也称为二级索引或非聚簇索引。创建的主键索引和二级索引默认使用的都是B+Tree索引。B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4次。\nB+Tree 是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每个节点里的数据是按主键顺序存放的。每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个双向链表。\n主键索引的 B+Tree 和二级索引的 B+Tree 区别如下：\n主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里； 二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。 通过二级索引查询会先检二级索引中的 B+Tree 的索引值，找到对应的叶子节点，然后获取主键值，然后再通过主键索引中的 B+Tree 树查询到对应的叶子节点，然后获取整行数据。这个过程叫「回表」，也就是说要查两个 B+Tree 才能查到数据。当查询的数据是能在二级索引的 B+Tree 的叶子节点里查询到，这时就不用再查主键索引查。这种在二级索引的 B+Tree 就能查询到结果的过程就叫作「覆盖索引」，也就是只需要查一个 B+Tree 就能找到数据。\n为什么InnoDB选择B+Tree作为索引的数据结构？\nB+Tree vs B Tree\nB+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。\nB+Tree vs 二叉树\n对于有 N 个叶子节点的 B+Tree，其搜索复杂度为O(logdN)，其中 d 表示节点允许的最大子节点个数为 d 个。\n在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 34 层左右，也就是说一次数据查询操作只需要做 34 次的磁盘 I/O 操作就能查询到目标数据。\n而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 O(logN)，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。\nB+Tree vs Hash\nHash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。\n但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。\n1.1.2 **按物理存储分：**聚簇索引、二级索引 从物理存储的角度来看，索引分为聚簇索引（主键索引）、二级索引（辅助索引）。\n这两个区别在前面也提到了：\n主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里； 二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。 所以，在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是覆盖索引。如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是回表。\n1.1.3 **按字段特性分：**主键索引、唯一索引、普通索引 主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。\n唯一索引建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。\n普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。\n前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。\n1.1.4 **按字段个数分：**单列索引、联合索引 从字段个数的角度来看，索引分为单列索引、联合索引（复合索引）。\n建立在单列上的索引称为单列索引，比如主键索引； 建立在多列上的索引称为联合索引； 使用联合索引时，存在最左匹配原则，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了。\n联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。\nQ1: select * from t_table where a \u003e 1 and b = 2，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？a\nQ2: select * from t_table where a \u003e= 1 and b = 2，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？a和b\nQ3: SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b = 2，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？a和b\nQ4: SELECT * FROM t_user WHERE name like 'j%' and age = 22，联合索引（name, age）哪一个字段用到了联合索引的 B+Tree？name和age\n联合索引的最左匹配原则，在遇到范围查询（如 \u003e、\u003c）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 \u003e=、\u003c=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配。\n1.2 索引下堆 对于联合索引（a, b），在执行 select * from table where a \u003e 1 and b = 2 语句的时候，只有 a 字段能用到索引，那在联合索引的 B+Tree 找到第一个满足条件的主键值（ID 为 2）后，还需要判断其他条件是否满足（看 b 是否等于 2），那是在联合索引里判断？还是回主键索引去判断呢？\n在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。 而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。 当你的查询语句的执行计划里，出现了 Extra 为 Using index condition，那么说明使用了索引下推的优化。\n1.3 索引区分度 建立联合索引时的字段顺序，对索引效率也有很大影响。越靠前的字段被用于索引过滤的概率越高，实际开发工作中建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到。\n区分度就是某个字段 column 不同值的个数「除以」表的总行数\n1.4 联合索引进行排序 针对select * from order where status = 1 order by create_time asc这条SQL，\n给 status 和 create_time 列建立一个联合索引，因为这样可以避免 MySQL 数据库发生文件排序。因为在查询时，如果只用到 status 的索引，但是这条语句还要对 create_time 排序，这时就要用文件排序 filesort，也就是在 SQL 执行计划中，Extra 列会出现 Using filesort。\n1.5 什么时候需要建索引，什么时候不需要？ 索引需要占用物理空间，创建索引和维护索引要耗费时间，会降低表的增删改的效率。\n什么时候适用索引？\n字段有唯一性限制的，比如商品编码； 经常用于 WHERE 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。 经常用于 GROUP BY 和 ORDER BY 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。 什么时候不需要创建索引？\nWHERE 条件，GROUP BY，ORDER BY 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。 字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。 表数据太少的时候，不需要创建索引； 经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。 2 索引优化 2.1 前缀索引优化 前缀索引顾名思义就是使用某个字段中字符串的前几个字符建立索引，那我们为什么需要使用前缀来建立索引呢？\n使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。\n不过，前缀索引有一定的局限性，例如：\norder by 就无法使用前缀索引； 无法把前缀索引用作覆盖索引； 2.2 覆盖索引优化 覆盖索引是指 SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。\n假设我们只需要查询商品的名称、价格，有什么方式可以避免回表呢？\n我们可以建立一个联合索引，即「商品ID、名称、价格」作为一个联合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。\n所以，使用覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就减少了大量的 I/O 操作。\n2.3 主键索引最好是递增的 如果我们使用自增主键，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次插入一条新记录，都是追加操作，不需要重新移动数据，因此这种插入数据的方法效率非常高。\n如果我们使用非自增主键，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为页分裂。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。\n另外，主键字段的长度不要太大，因为主键字段长度越小，意味着二级索引的叶子节点越小（二级索引的叶子节点存放的数据是主键值），这样二级索引占用的空间也就越小。\n2.4 索引最好设置为NOT NULL 为了更好的利用索引，索引列要设置为 NOT NULL 约束。有两个原因：\n第一原因：索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为NULL 的行。 第二个原因：NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，因为 InnoDB 存储记录的时候，如果表中存在允许为 NULL 的字段，那么行格式中至少会用 1 字节空间存储 NULL 值列表，如下图的紫色部分： 2.5 防止索引失效 失效的情况：\n当我们使用左或者左右模糊匹配的时候，也就是 like %xx 或者 like %xx%这两种方式都会造成索引失效； 当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效； 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。 执行计划：\npossible_keys 字段表示可能用到的索引； key 字段表示实际用的索引，如果这一项为 NULL，说明没有使用索引； key_len 表示索引的长度； rows 表示扫描的数据行数。 type 表示数据扫描类型，我们需要重点看这个。 Type：\nAll（全表扫描） index（全索引扫描）：和All差不多，但是不需要排序 range（索引范围扫描）：只检索给定范围的行 ref（非唯一索引扫描）：采用了非唯一索引，或者是唯一索引的非唯一性前缀。因为虽然使用了索引，但该索引列的值并不唯一，有重复。这样即使使用索引快速查找到了第一条数据，仍然不能停止，要进行目标值附近的小范围扫描。但它的好处是它并不需要扫全表，因为索引是有序的，即便有重复值，也是在一个非常小的范围内扫描。 eq_ref（唯一索引扫描）：使用主键或唯一索引时产生的访问方式，通常使用在多表联查中。比如，对两张表进行联查，关联条件是两张表的 user_id 相等，且 user_id 是唯一索引，那么使用 EXPLAIN 进行执行计划查看的时候，type 就会显示 eq_ref。 const（结果只有一条的主键或唯一索引扫描）：表示使用了主键或者唯一索引与常量值进行比较。 需要说明的是 const 类型和 eq_ref 都使用了主键或唯一索引，不过这两个类型有所区别，const 是与常量进行比较，查询效率会更快，而 eq_ref 通常用于多表联查中。\nExtra：\nUsing filesort ：当查询语句中包含 group by 操作，而且无法利用索引完成排序操作的时候， 这时不得不选择相应的排序算法进行，甚至可能会通过文件排序，效率是很低的，所以要避免这种问题的出现。 Using temporary：使了用临时表保存中间结果，MySQL 在对查询结果排序时使用临时表，常见于排序 order by 和分组查询 group by。效率低，要避免这种问题的出现。 Using index：所需数据只需在索引即可全部获得，不须要再到表中取数据，也就是使用了覆盖索引，避免了回表操作，效率不错。 3 从数据页的角度看B+树 3.1 InnoDB如何存储数据 InnoDB按数据页为单位进行读写，数据页的默认大小是16KB。\n文件头：表示页的信息 页头：表示页的状态 最小和最大记录：两个虚拟的伪记录，分别记录页中最小和最大记录 用户记录：存储行记录内容 空闲空间：页中还未使用的空间 页目录：存储用户记录的相对位置，对记录起到索引作用 文件尾：校验页是否完整 在 File Header 中有两个指针，分别指向上一个数据页和下一个数据页，连接起来的页相当于一个双向的链表。\n数据页中的记录按照「主键」顺序组成单向链表，单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。\n页目录与记录的关系如下\n将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录； 每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段 页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），每个槽相当于指针指向了不同组的最后一个记录。 从图可以看到，页目录就是由多个槽组成的，槽相当于分组记录的索引。然后，因为记录是按照「主键值」从小到大排序的，所以我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录，无需从最小记录开始遍历整个页中的记录链表。\nInnoDB 对每个分组中的记录条数都是有规定的，槽内的记录就只有几条：\n第一个分组中的记录只能有 1 条记录； 最后一个分组中的记录条数范围只能在 1-8 条之间； 剩下的分组中记录条数范围只能在 4-8 条之间。 3.2 B+树是如何进行查询的 InnoDB 采用了 B+ 树作为索引。磁盘的 I/O 操作次数对索引的使用效率至关重要，因此在构造索引的时候，我们更倾向于采用“矮胖”的 B+ 树数据结构，这样所需要进行的磁盘 I/O 次数更少，而且 B+ 树 更适合进行关键字的范围查询。\nInnoDB 里的 B+ 树中的每个节点都是一个数据页\n只有叶子节点（最底层的节点）才存放了数据，非叶子节点（其他上层节）仅用来存放目录项作为索引。 非叶子节点分为不同层次，通过分层来降低每一层的搜索量； 所有节点按照索引键大小排序，构成一个双向链表，便于范围查询； B+ 树如何实现快速查找主键为 6 的记录，以上图为例子：\n从根节点开始，通过二分法快速定位到符合页内范围包含查询值的页，因为查询的主键值为 6，在[1, 7)范围之间，所以到页 30 中查找更详细的目录项； 在非叶子节点（页30）中，继续通过二分法快速定位到符合页内范围包含查询值的页，主键值大于 5，所以就到叶子节点（页16）查找记录； 接着，在叶子节点（页16）中，通过槽查找记录时，使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到主键为 6 的记录。 可以看到，在定位记录所在哪一个页时，也是通过二分法快速定位到包含该记录的页。定位到该页后，又会在该页内进行二分法快速定位记录所在的分组（槽号），最后在分组内进行遍历查找。\n3.3 聚簇索引和二级索引 聚簇索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点； 二级索引的叶子节点存放的是主键值，而不是实际数据。 因为表的数据都是存放在聚簇索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚簇索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个。\nInnoDB 在创建聚簇索引时，会根据不同的场景选择不同的列作为索引：\n如果有主键，默认会使用主键作为聚簇索引的索引键； 如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键； 在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键。 一张表只能有一个聚簇索引，那为了实现非主键字段的快速搜索，就引出了二级索引（非聚簇索引/辅助索引），它也是利用了 B+ 树的数据结构，但是二级索引的叶子节点存放的是主键值，不是实际数据。\n如果某个查询语句使用了二级索引，但是查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作「回表」，也就是说要查两个 B+ 树才能查到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作「索引覆盖」，也就是只需要查一个 B+ 树就能找到数据。\n4 为什么MySQL采用B+树作为索引 磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，操作系统一次会读写多个扇区，所以操作系统的最小读写单位是块（Block）。Linux 中的块大小为 4KB，也就是一次磁盘 I/O 操作会直接读写 8 个扇区。\n由于数据库的索引是保存到磁盘上的，因此当我们通过索引查找某行数据的时候，就需要先从磁盘读取索引到内存，再通过索引从磁盘中找到某行数据，然后读入到内存，也就是说查询过程中会发生多次磁盘 I/O，而磁盘 I/O 次数越多，所消耗的时间也就越大。\n所以，我们希望索引的数据结构能在尽可能少的磁盘的 I/O 操作中完成查询工作，因为磁盘 I/O 操作越少，所消耗的时间也就越小。\n另外，MySQL 是支持范围查找的，所以索引的数据结构不仅要能高效地查询某一个记录，而且也要能高效地执行范围查找。\n二分查找树：二叉查找树的特点是一个节点的左子树的所有节点都小于这个节点，右子树的所有节点都大于这个节点，当每次插入的元素都是二叉查找树中最大的元素，二叉查找树就会退化成了一条链表，查找数据的时间复杂度变成了 O(n)，树的高度就等于每次查询数据时磁盘 IO 操作的次数。\n自平衡二叉树：每个节点的左子树和右子树的高度差不能超过 1，会自动进行调整，不管平衡二叉查找树还是红黑树，都会随着插入的元素增多，而导致树的高度变高，这就意味着磁盘 I/O 操作次数多，会影响整体数据查询的效率。\n红黑树：\nB树：不再限制一个节点就只能有 2 个子节点，而是允许 M 个子节点 (M\u003e2)，从而降低树的高度。B 树的每一个节点最多可以包括 M 个子节点，M 称为 B 树的阶，所以 B 树就是一个多叉树。\nB 树的每个节点都包含数据（索引+记录），而用户的记录数据的大小很有可能远远超过了索引数据，这就需要花费更多的磁盘 I/O 操作次数来读到「有用的索引数据」。 查询位于底层的某个节点（比如 A 记录）过程中，「非 A 记录节点」里的记录数据会从磁盘加载到内存，但是这些记录数据是没用的，我们只是想读取这些节点的索引数据来做比较查询，而「非 A 记录节点」里的记录数据对我们是没用的，这样不仅增多磁盘 I/O 操作次数，也占用内存资源。 如果使用 B 树来做范围查询的话，需要使用中序遍历，这会涉及多个节点的磁盘 I/O 问题，从而导致整体速度下降。 B+树：\n叶子节点（最底部的节点）才会存放实际数据（索引+记录），非叶子节点只会存放索引； 所有索引都会在叶子节点出现，叶子节点之间构成一个有序链表； 非叶子节点的索引也会同时存在在子节点中，并且是在子节点中所有索引的最大（或最小）。 非叶子节点中有多少个子节点，就有多少个索引； 1）单点查询效率：B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。\n2）插入和删除效率：B+ 树有大量的冗余节点，这样使得删除一个节点的时候，可以直接从叶子节点中删除，甚至可以不动非叶子节点，这样删除非常快。B+ 树的插入也是一样，有冗余节点，插入可能存在节点的分裂（如果节点饱和），但是最多只涉及树的一条路径。而且 B+ 树会自动平衡，不需要像更多复杂的算法，类似红黑树的旋转操作等。\n3）范围查询：因为 B+ 树所有叶子节点间还有一个链表进行连接，这种设计对范围查找非常有帮助。因此，存在大量范围检索的场景，适合使用 B+树，比如数据库。而对于大量的单个索引查询的场景，可以考虑 B 树，比如 nosql 的MongoDB。\n5 索引失效 对索引使用左或左右模糊匹配： like %xx 或者 like %xx% 这两种方式，因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。\nMySQL 使用 like “%x“，索引一定会失效吗？ | 小林coding (xiaolincoding.com)\n如果表中只有两个字段，并且都是索引列，一个为主键字段，一个为要模糊匹配的字段，那么如果使用模糊匹配，会走覆盖索引，type=index，也就是扫描了整个索引树。\n扫描的索引树是二级索引树，不扫描聚簇索引是因为聚簇索引记录的东西会更多，比如聚簇索引中的叶子节点则记录了主键值、事务 id、用于事务和 MVCC 的回滚指针以及所有的剩余列。\n对索引使用函数：因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。\n不过，从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。\n对索引进行表达式计算：select * from t_user where id + 1 = 10;会导致索引失效，但是改成 where id = 10 - 1就可以走索引进行查询了。\n对索引进行隐式类型转换：例如1）varchar类型的字段，但是在where子句中使用整形输入作为匹配条件，结果会导致走全表进行扫描。但是2）如果索引字段是整型类型，查询条件中的输入参数即使字符串，是不会导致索引失效，还是可以走索引扫描。\nMySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。所以1）中相当于对索引使用了函数，而2）中将入参做了转换，所以会走索引。\n联合索引非最左匹配：在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。\n也就是说，如果我们想使用联合索引中尽可能多的列，查询条件中的各个列必须是联合索引中从最左边开始连续的列。如果我们仅仅按照第二列搜索，肯定无法走索引。\nWhere子句中的OR：在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。\n其他 MySQL单表存储数据最好不要超过2000W行;\ncount性能排序：count(*) \u003e count(1) \u003e count(主键字段) \u003e count(字段)\ncount()统计符合查询条件的记录中，函数指定的参数不为 NULL 的记录有多少个，count(1)由于1是单纯的数字，永远不为NULL，所以count(1)作用是统计有多少条记录。\ncount(*)等于count(0)，MySQL会将 * 参数转化为参数 0 来处理。所以，count(*) 执行过程跟 count(1) 执行过程基本一样的，性能没有什么差异。而且 MySQL 会对 count(*) 和 count(1) 有个优化，如果有多个二级索引的时候，优化器会使用key_len 最小的二级索引进行扫描。\n","wordCount":"714","inLanguage":"en","image":"https://roaraeonliou.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-09-26T00:00:00Z","dateModified":"2024-09-26T00:00:00Z","author":{"@type":"Person","name":"RLTEA"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://roaraeonliou.github.io/posts/interviewnotes/new/%E6%95%B0%E6%8D%AE%E5%BA%93/2.index/"},"publisher":{"@type":"Organization","name":"RLTEA BLOG","logo":{"@type":"ImageObject","url":"https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E"}}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["\\(","\\)"],["$","$"]]}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://roaraeonliou.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://roaraeonliou.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://roaraeonliou.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://roaraeonliou.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://roaraeonliou.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://roaraeonliou.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://roaraeonliou.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://roaraeonliou.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">2.Index</h1><div class=post-meta><span title='2024-09-26 00:00:00 +0000 UTC'>September 26, 2024</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;714 words&nbsp;·&nbsp;RLTEA&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/InterviewNotes/new/%e6%95%b0%e6%8d%ae%e5%ba%93/2.Index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-%e7%b4%a2%e5%bc%95%e5%9f%ba%e7%a1%80 aria-label="1 索引基础">1 索引基础</a><ul><ul><li><a href=#11-%e7%b4%a2%e5%bc%95%e7%9a%84%e5%88%86%e7%b1%bb aria-label="1.1 索引的分类">1.1 索引的分类</a><ul><li><a href=#111-%e6%8c%89%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e5%88%86btree%e7%b4%a2%e5%bc%95hash%e7%b4%a2%e5%bc%95full-text%e7%b4%a2%e5%bc%95 aria-label="1.1.1 按数据结构分：B+Tree索引、Hash索引、Full-text索引">1.1.1 按数据结构分：B+Tree索引、Hash索引、Full-text索引</a></li><li><a href=#112-%e6%8c%89%e7%89%a9%e7%90%86%e5%ad%98%e5%82%a8%e5%88%86%e8%81%9a%e7%b0%87%e7%b4%a2%e5%bc%95%e4%ba%8c%e7%ba%a7%e7%b4%a2%e5%bc%95 aria-label="1.1.2 **按物理存储分：**聚簇索引、二级索引">1.1.2 **按物理存储分：**聚簇索引、二级索引</a></li><li><a href=#113-%e6%8c%89%e5%ad%97%e6%ae%b5%e7%89%b9%e6%80%a7%e5%88%86%e4%b8%bb%e9%94%ae%e7%b4%a2%e5%bc%95%e5%94%af%e4%b8%80%e7%b4%a2%e5%bc%95%e6%99%ae%e9%80%9a%e7%b4%a2%e5%bc%95 aria-label="1.1.3 **按字段特性分：**主键索引、唯一索引、普通索引">1.1.3 **按字段特性分：**主键索引、唯一索引、普通索引</a></li><li><a href=#114-%e6%8c%89%e5%ad%97%e6%ae%b5%e4%b8%aa%e6%95%b0%e5%88%86%e5%8d%95%e5%88%97%e7%b4%a2%e5%bc%95%e8%81%94%e5%90%88%e7%b4%a2%e5%bc%95 aria-label="1.1.4 **按字段个数分：**单列索引、联合索引">1.1.4 **按字段个数分：**单列索引、联合索引</a></li></ul></li><li><a href=#12-%e7%b4%a2%e5%bc%95%e4%b8%8b%e5%a0%86 aria-label="1.2 索引下堆">1.2 索引下堆</a></li><li><a href=#13-%e7%b4%a2%e5%bc%95%e5%8c%ba%e5%88%86%e5%ba%a6 aria-label="1.3 索引区分度">1.3 索引区分度</a></li><li><a href=#14-%e8%81%94%e5%90%88%e7%b4%a2%e5%bc%95%e8%bf%9b%e8%a1%8c%e6%8e%92%e5%ba%8f aria-label="1.4 联合索引进行排序">1.4 联合索引进行排序</a></li><li><a href=#15-%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e9%9c%80%e8%a6%81%e5%bb%ba%e7%b4%a2%e5%bc%95%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e4%b8%8d%e9%9c%80%e8%a6%81 aria-label="1.5 什么时候需要建索引，什么时候不需要？">1.5 什么时候需要建索引，什么时候不需要？</a></li></ul></ul></li><li><a href=#2-%e7%b4%a2%e5%bc%95%e4%bc%98%e5%8c%96 aria-label="2 索引优化">2 索引优化</a><ul><ul><li><a href=#21-%e5%89%8d%e7%bc%80%e7%b4%a2%e5%bc%95%e4%bc%98%e5%8c%96 aria-label="2.1 前缀索引优化">2.1 前缀索引优化</a></li><li><a href=#22-%e8%a6%86%e7%9b%96%e7%b4%a2%e5%bc%95%e4%bc%98%e5%8c%96 aria-label="2.2 覆盖索引优化">2.2 覆盖索引优化</a></li><li><a href=#23-%e4%b8%bb%e9%94%ae%e7%b4%a2%e5%bc%95%e6%9c%80%e5%a5%bd%e6%98%af%e9%80%92%e5%a2%9e%e7%9a%84 aria-label="2.3 主键索引最好是递增的">2.3 主键索引最好是递增的</a></li><li><a href=#24-%e7%b4%a2%e5%bc%95%e6%9c%80%e5%a5%bd%e8%ae%be%e7%bd%ae%e4%b8%banot-null aria-label="2.4 索引最好设置为NOT NULL">2.4 索引最好设置为NOT NULL</a></li><li><a href=#25-%e9%98%b2%e6%ad%a2%e7%b4%a2%e5%bc%95%e5%a4%b1%e6%95%88 aria-label="2.5 防止索引失效">2.5 防止索引失效</a></li></ul></ul></li><li><a href=#3-%e4%bb%8e%e6%95%b0%e6%8d%ae%e9%a1%b5%e7%9a%84%e8%a7%92%e5%ba%a6%e7%9c%8bb%e6%a0%91 aria-label="3 从数据页的角度看B+树">3 从数据页的角度看B+树</a><ul><ul><li><a href=#31-innodb%e5%a6%82%e4%bd%95%e5%ad%98%e5%82%a8%e6%95%b0%e6%8d%ae aria-label="3.1 InnoDB如何存储数据">3.1 InnoDB如何存储数据</a></li><li><a href=#32-b%e6%a0%91%e6%98%af%e5%a6%82%e4%bd%95%e8%bf%9b%e8%a1%8c%e6%9f%a5%e8%af%a2%e7%9a%84 aria-label="3.2 B+树是如何进行查询的">3.2 B+树是如何进行查询的</a></li><li><a href=#33-%e8%81%9a%e7%b0%87%e7%b4%a2%e5%bc%95%e5%92%8c%e4%ba%8c%e7%ba%a7%e7%b4%a2%e5%bc%95 aria-label="3.3 聚簇索引和二级索引">3.3 聚簇索引和二级索引</a></li></ul></ul></li><li><a href=#4-%e4%b8%ba%e4%bb%80%e4%b9%88mysql%e9%87%87%e7%94%a8b%e6%a0%91%e4%bd%9c%e4%b8%ba%e7%b4%a2%e5%bc%95 aria-label="4 为什么MySQL采用B+树作为索引">4 为什么MySQL采用B+树作为索引</a></li><li><a href=#5-%e7%b4%a2%e5%bc%95%e5%a4%b1%e6%95%88 aria-label="5 索引失效">5 索引失效</a></li><li><a href=#%e5%85%b6%e4%bb%96 aria-label=其他>其他</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=1-索引基础>1 索引基础<a hidden class=anchor aria-hidden=true href=#1-索引基础>#</a></h2><h4 id=11-索引的分类>1.1 索引的分类<a hidden class=anchor aria-hidden=true href=#11-索引的分类>#</a></h4><h5 id=111-按数据结构分btree索引hash索引full-text索引>1.1.1 按数据结构分：B+Tree索引、Hash索引、Full-text索引<a hidden class=anchor aria-hidden=true href=#111-按数据结构分btree索引hash索引full-text索引>#</a></h5><p>InnoDB支持B+Tree索引和Full-Text索引，不支持Hash索引但是内存结构中有一个自适应hash索引；</p><p>MyISAM支持B+Tree索引和Full-Text索引，但是不支持Hash索引；</p><p>Memory支持B+Tree索引和Hash索引，但是不支持Full-Text索引。</p><p>InnoDB存储引擎在创建表时：如果有主键，会默认使用主键作为聚簇索引的索引键；如果没有主键，就会选择第一个不包含NULL值的唯一列所谓聚簇索引的索引键；如果都没有则会自动生成一个隐式自增ID作为聚簇索引键。</p><p>其他索引都属于辅助索引，也称为二级索引或非聚簇索引。创建的主键索引和二级索引默认使用的都是B+Tree索引。<strong>B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4次。</strong></p><p>B+Tree 是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每个节点里的数据是<strong>按主键顺序存放</strong>的。每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个双向链表。</p><p>主键索引的 B+Tree 和二级索引的 B+Tree 区别如下：</p><ul><li>主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</li><li>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</li></ul><p>通过二级索引查询会先检二级索引中的 B+Tree 的索引值，找到对应的叶子节点，然后获取主键值，然后再通过主键索引中的 B+Tree 树查询到对应的叶子节点，然后获取整行数据。<strong>这个过程叫「回表」，也就是说要查两个 B+Tree 才能查到数据</strong>。当查询的数据是能在二级索引的 B+Tree 的叶子节点里查询到，这时就不用再查主键索引查。<strong>这种在二级索引的 B+Tree 就能查询到结果的过程就叫作「覆盖索引」，也就是只需要查一个 B+Tree 就能找到数据</strong>。</p><blockquote><p>为什么InnoDB选择B+Tree作为索引的数据结构？</p><ol><li><p><em><strong>B+Tree vs B Tree</strong></em></p><p>B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。</p></li><li><p><em><strong>B+Tree vs 二叉树</strong></em></p><p>对于有 N 个叶子节点的 B+Tree，其搜索复杂度为<code>O(logdN)</code>，其中 d 表示节点允许的最大子节点个数为 d 个。</p><p>在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3<del>4 层左右，也就是说一次数据查询操作只需要做 3</del>4 次的磁盘 I/O 操作就能查询到目标数据。</p><p>而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 <code>O(logN)</code>，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。</p></li><li><p><em><strong>B+Tree vs Hash</strong></em></p><p>Hash 在做等值查询的时候效率贼快，搜索复杂度为 O(1)。</p><p>但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。</p></li></ol></blockquote><h5 id=112-按物理存储分聚簇索引二级索引>1.1.2 **按物理存储分：**聚簇索引、二级索引<a hidden class=anchor aria-hidden=true href=#112-按物理存储分聚簇索引二级索引>#</a></h5><p>从物理存储的角度来看，索引分为聚簇索引（主键索引）、二级索引（辅助索引）。</p><p>这两个区别在前面也提到了：</p><ul><li>主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</li><li>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</li></ul><p>所以，在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是覆盖索引。如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是回表。</p><h5 id=113-按字段特性分主键索引唯一索引普通索引>1.1.3 **按字段特性分：**主键索引、唯一索引、普通索引<a hidden class=anchor aria-hidden=true href=#113-按字段特性分主键索引唯一索引普通索引>#</a></h5><p>主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。</p><p>唯一索引建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。</p><p>普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。</p><p>前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。</p><h5 id=114-按字段个数分单列索引联合索引>1.1.4 **按字段个数分：**单列索引、联合索引<a hidden class=anchor aria-hidden=true href=#114-按字段个数分单列索引联合索引>#</a></h5><p>从字段个数的角度来看，索引分为单列索引、联合索引（复合索引）。</p><ul><li>建立在单列上的索引称为单列索引，比如主键索引；</li><li>建立在多列上的索引称为联合索引；</li></ul><p>使用联合索引时，存在<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了。</p><p>联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。</p><p>Q1: <code>select * from t_table where a > 1 and b = 2</code>，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？a</p><p>Q2: <code>select * from t_table where a >= 1 and b = 2</code>，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？a和b</p><p>Q3: <code>SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b = 2</code>，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？a和b</p><p>Q4: <code>SELECT * FROM t_user WHERE name like 'j%' and age = 22</code>，联合索引（name, age）哪一个字段用到了联合索引的 B+Tree？name和age</p><p><strong>联合索引的最左匹配原则，在遇到范围查询（如 >、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 >=、&lt;=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配。</strong></p><h4 id=12-索引下堆>1.2 索引下堆<a hidden class=anchor aria-hidden=true href=#12-索引下堆>#</a></h4><p>对于联合索引（a, b），在执行 <code>select * from table where a > 1 and b = 2</code> 语句的时候，只有 a 字段能用到索引，那在联合索引的 B+Tree 找到第一个满足条件的主键值（ID 为 2）后，还需要判断其他条件是否满足（看 b 是否等于 2），那是在联合索引里判断？还是回主键索引去判断呢？</p><ul><li>在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。</li><li>而 MySQL 5.6 引入的<strong>索引下推优化</strong>（index condition pushdown)， <strong>可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。</li></ul><p>当你的查询语句的执行计划里，出现了 Extra 为 <code>Using index condition</code>，那么说明使用了索引下推的优化。</p><h4 id=13-索引区分度>1.3 索引区分度<a hidden class=anchor aria-hidden=true href=#13-索引区分度>#</a></h4><p>建立联合索引时的字段顺序，对索引效率也有很大影响。越靠前的字段被用于索引过滤的概率越高，实际开发工作中<strong>建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到</strong>。</p><p>区分度就是某个字段 column 不同值的个数「除以」表的总行数</p><h4 id=14-联合索引进行排序>1.4 联合索引进行排序<a hidden class=anchor aria-hidden=true href=#14-联合索引进行排序>#</a></h4><p>针对select * from order where status = 1 order by create_time asc这条SQL，</p><p>给 status 和 create_time 列建立一个联合索引，因为这样可以避免 MySQL 数据库发生文件排序。因为在查询时，如果只用到 status 的索引，但是这条语句还要对 create_time 排序，这时就要用文件排序 filesort，也就是在 SQL 执行计划中，Extra 列会出现 Using filesort。</p><h4 id=15-什么时候需要建索引什么时候不需要>1.5 什么时候需要建索引，什么时候不需要？<a hidden class=anchor aria-hidden=true href=#15-什么时候需要建索引什么时候不需要>#</a></h4><p>索引需要占用物理空间，创建索引和维护索引要耗费时间，会降低表的增删改的效率。</p><p><strong>什么时候适用索引？</strong></p><ul><li>字段有唯一性限制的，比如商品编码；</li><li>经常用于 <code>WHERE</code> 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</li><li>经常用于 <code>GROUP BY</code> 和 <code>ORDER BY</code> 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。</li></ul><p><strong>什么时候不需要创建索引？</strong></p><ul><li><code>WHERE</code> 条件，<code>GROUP BY</code>，<code>ORDER BY</code> 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。</li><li>字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。</li><li>表数据太少的时候，不需要创建索引；</li><li>经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。</li></ul><h2 id=2-索引优化>2 索引优化<a hidden class=anchor aria-hidden=true href=#2-索引优化>#</a></h2><h4 id=21-前缀索引优化>2.1 前缀索引优化<a hidden class=anchor aria-hidden=true href=#21-前缀索引优化>#</a></h4><p>前缀索引顾名思义就是使用某个字段中字符串的前几个字符建立索引，那我们为什么需要使用前缀来建立索引呢？</p><p>使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。</p><p>不过，前缀索引有一定的局限性，例如：</p><ul><li>order by 就无法使用前缀索引；</li><li>无法把前缀索引用作覆盖索引；</li></ul><h4 id=22-覆盖索引优化>2.2 覆盖索引优化<a hidden class=anchor aria-hidden=true href=#22-覆盖索引优化>#</a></h4><p>覆盖索引是指 SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。</p><p>假设我们只需要查询商品的名称、价格，有什么方式可以避免回表呢？</p><p>我们可以建立一个联合索引，即「商品ID、名称、价格」作为一个联合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。</p><p>所以，使用覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就减少了大量的 I/O 操作。</p><h4 id=23-主键索引最好是递增的>2.3 主键索引最好是递增的<a hidden class=anchor aria-hidden=true href=#23-主键索引最好是递增的>#</a></h4><p><strong>如果我们使用自增主键</strong>，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次<strong>插入一条新记录，都是追加操作，不需要重新移动数据</strong>，因此这种插入数据的方法效率非常高。</p><p><strong>如果我们使用非自增主键</strong>，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为<strong>页分裂</strong>。<strong>页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率</strong>。</p><p>另外，主键字段的长度不要太大，因为<strong>主键字段长度越小，意味着二级索引的叶子节点越小（二级索引的叶子节点存放的数据是主键值），这样二级索引占用的空间也就越小。</strong></p><h4 id=24-索引最好设置为not-null>2.4 索引最好设置为NOT NULL<a hidden class=anchor aria-hidden=true href=#24-索引最好设置为not-null>#</a></h4><p>为了更好的利用索引，索引列要设置为 NOT NULL 约束。有两个原因：</p><ul><li>第一原因：索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为NULL 的行。</li><li>第二个原因：NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，因为 InnoDB 存储记录的时候，如果表中存在允许为 NULL 的字段，那么<a href=https://xiaolincoding.com/mysql/base/row_format.html#innodb-%E8%A1%8C%E6%A0%BC%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B>行格式</a>中<strong>至少会用 1 字节空间存储 NULL 值列表</strong>，如下图的紫色部分：</li></ul><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/9762e149c0ff01ffb1372f2a4c00f61b/aa44f68285961ed06694401ffea73a14.png alt=image-20240827002722021></p><h4 id=25-防止索引失效>2.5 防止索引失效<a hidden class=anchor aria-hidden=true href=#25-防止索引失效>#</a></h4><p>失效的情况：</p><ul><li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li><li>当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；</li><li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li><li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li></ul><p>执行计划：</p><ul><li>possible_keys 字段表示可能用到的索引；</li><li>key 字段表示实际用的索引，如果这一项为 NULL，说明没有使用索引；</li><li>key_len 表示索引的长度；</li><li>rows 表示扫描的数据行数。</li><li>type 表示数据扫描类型，我们需要重点看这个。</li></ul><p>Type：</p><ul><li>All（全表扫描）</li><li>index（全索引扫描）：和All差不多，但是不需要排序</li><li>range（索引范围扫描）：只检索给定范围的行</li><li>ref（非唯一索引扫描）：采用了非唯一索引，或者是唯一索引的非唯一性前缀。因为虽然使用了索引，但该索引列的值并不唯一，有重复。这样即使使用索引快速查找到了第一条数据，仍然不能停止，要进行目标值附近的小范围扫描。但它的好处是它并不需要扫全表，因为索引是有序的，即便有重复值，也是在一个非常小的范围内扫描。</li><li>eq_ref（唯一索引扫描）：使用主键或唯一索引时产生的访问方式，通常使用在多表联查中。比如，对两张表进行联查，关联条件是两张表的 user_id 相等，且 user_id 是唯一索引，那么使用 EXPLAIN 进行执行计划查看的时候，type 就会显示 eq_ref。</li><li>const（结果只有一条的主键或唯一索引扫描）：表示使用了主键或者唯一索引与常量值进行比较。</li></ul><p>需要说明的是 const 类型和 eq_ref 都使用了主键或唯一索引，不过这两个类型有所区别，<strong>const 是与常量进行比较，查询效率会更快，而 eq_ref 通常用于多表联查中</strong>。</p><p>Extra：</p><ul><li>Using filesort ：当查询语句中包含 group by 操作，而且无法利用索引完成排序操作的时候， 这时不得不选择相应的排序算法进行，甚至可能会通过文件排序，效率是很低的，所以要避免这种问题的出现。</li><li>Using temporary：使了用临时表保存中间结果，MySQL 在对查询结果排序时使用临时表，常见于排序 order by 和分组查询 group by。效率低，要避免这种问题的出现。</li><li>Using index：所需数据只需在索引即可全部获得，不须要再到表中取数据，也就是使用了覆盖索引，避免了回表操作，效率不错。</li></ul><h2 id=3-从数据页的角度看b树>3 从数据页的角度看B+树<a hidden class=anchor aria-hidden=true href=#3-从数据页的角度看b树>#</a></h2><h4 id=31-innodb如何存储数据>3.1 InnoDB如何存储数据<a hidden class=anchor aria-hidden=true href=#31-innodb如何存储数据>#</a></h4><p>InnoDB按数据页为单位进行读写，数据页的默认大小是16KB。</p><ul><li>文件头：表示页的信息</li><li>页头：表示页的状态</li><li>最小和最大记录：两个虚拟的伪记录，分别记录页中最小和最大记录</li><li>用户记录：存储行记录内容</li><li>空闲空间：页中还未使用的空间</li><li>页目录：存储用户记录的相对位置，对记录起到索引作用</li><li>文件尾：校验页是否完整</li></ul><p>在 File Header 中有两个指针，分别指向上一个数据页和下一个数据页，连接起来的页相当于一个<strong>双向的链表</strong>。</p><p><strong>数据页中的记录按照「主键」顺序组成单向链表</strong>，单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。</p><p>页目录与记录的关系如下</p><ul><li>将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录；</li><li>每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段</li><li>页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），<strong>每个槽相当于指针指向了不同组的最后一个记录</strong>。</li></ul><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/9762e149c0ff01ffb1372f2a4c00f61b/452340d274af098932bef2d1f7fb0687.png alt=image-20240827235202787></p><p>从图可以看到，<strong>页目录就是由多个槽组成的，槽相当于分组记录的索引</strong>。然后，因为记录是按照「主键值」从小到大排序的，所以<strong>我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录</strong>，无需从最小记录开始遍历整个页中的记录链表。</p><p>InnoDB 对每个分组中的记录条数都是有规定的，槽内的记录就只有几条：</p><ul><li>第一个分组中的记录只能有 1 条记录；</li><li>最后一个分组中的记录条数范围只能在 1-8 条之间；</li><li>剩下的分组中记录条数范围只能在 4-8 条之间。</li></ul><h4 id=32-b树是如何进行查询的>3.2 B+树是如何进行查询的<a hidden class=anchor aria-hidden=true href=#32-b树是如何进行查询的>#</a></h4><p><strong>InnoDB 采用了 B+ 树作为索引</strong>。磁盘的 I/O 操作次数对索引的使用效率至关重要，因此在构造索引的时候，我们更倾向于采用“矮胖”的 B+ 树数据结构，这样所需要进行的磁盘 I/O 次数更少，而且 B+ 树 更适合进行关键字的范围查询。</p><p>InnoDB 里的 B+ 树中的<strong>每个节点都是一个数据页</strong></p><ul><li>只有叶子节点（最底层的节点）才存放了数据，非叶子节点（其他上层节）仅用来存放目录项作为索引。</li><li>非叶子节点分为不同层次，通过分层来降低每一层的搜索量；</li><li>所有节点按照索引键大小排序，构成一个双向链表，便于范围查询；</li></ul><p>B+ 树如何实现快速查找主键为 6 的记录，以上图为例子：</p><ul><li>从根节点开始，通过二分法快速定位到符合页内范围包含查询值的页，因为查询的主键值为 6，在[1, 7)范围之间，所以到页 30 中查找更详细的目录项；</li><li>在非叶子节点（页30）中，继续通过二分法快速定位到符合页内范围包含查询值的页，主键值大于 5，所以就到叶子节点（页16）查找记录；</li><li>接着，在叶子节点（页16）中，通过槽查找记录时，使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到主键为 6 的记录。</li></ul><p>可以看到，在定位记录所在哪一个页时，也是通过二分法快速定位到包含该记录的页。定位到该页后，又会在该页内进行二分法快速定位记录所在的分组（槽号），最后在分组内进行遍历查找。</p><h4 id=33-聚簇索引和二级索引>3.3 聚簇索引和二级索引<a hidden class=anchor aria-hidden=true href=#33-聚簇索引和二级索引>#</a></h4><ul><li>聚簇索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点；</li><li>二级索引的叶子节点存放的是主键值，而不是实际数据。</li></ul><p>因为表的数据都是存放在聚簇索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚簇索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个。</p><p>InnoDB 在创建聚簇索引时，会根据不同的场景选择不同的列作为索引：</p><ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键；</li><li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键；</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键。</li></ul><p>一张表只能有一个聚簇索引，那为了实现非主键字段的快速搜索，就引出了二级索引（非聚簇索引/辅助索引），它也是利用了 B+ 树的数据结构，但是二级索引的叶子节点存放的是主键值，不是实际数据。</p><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/9762e149c0ff01ffb1372f2a4c00f61b/48deac4d5ad59fcd475861ee375d3487.png alt=image-20240827235838476></p><p><strong>如果某个查询语句使用了二级索引，但是查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作「回表」，也就是说要查两个 B+ 树才能查到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作「索引覆盖」，也就是只需要查一个 B+ 树就能找到数据。</strong></p><h2 id=4-为什么mysql采用b树作为索引>4 为什么MySQL采用B+树作为索引<a hidden class=anchor aria-hidden=true href=#4-为什么mysql采用b树作为索引>#</a></h2><p>磁盘读写的最小单位是<strong>扇区</strong>，扇区的大小只有 <code>512B</code> 大小，操作系统一次会读写多个扇区，所以<strong>操作系统的最小读写单位是块（Block）。Linux 中的块大小为 <code>4KB</code></strong>，也就是一次磁盘 I/O 操作会直接读写 8 个扇区。</p><p>由于数据库的索引是保存到磁盘上的，因此当我们通过索引查找某行数据的时候，就需要先从磁盘读取索引到内存，再通过索引从磁盘中找到某行数据，然后读入到内存，也就是说查询过程中会发生多次磁盘 I/O，而磁盘 I/O 次数越多，所消耗的时间也就越大。</p><p>所以，我们希望索引的数据结构能在尽可能少的磁盘的 I/O 操作中完成查询工作，因为磁盘 I/O 操作越少，所消耗的时间也就越小。</p><p>另外，MySQL 是支持范围查找的，所以索引的数据结构不仅要能高效地查询某一个记录，而且也要能高效地执行范围查找。</p><ol><li><p>二分查找树：<strong>二叉查找树的特点是一个节点的左子树的所有节点都小于这个节点，右子树的所有节点都大于这个节点</strong>，<strong>当每次插入的元素都是二叉查找树中最大的元素，二叉查找树就会退化成了一条链表，查找数据的时间复杂度变成了 O(n)</strong>，<strong>树的高度就等于每次查询数据时磁盘 IO 操作的次数</strong>。</p></li><li><p>自平衡二叉树：<strong>每个节点的左子树和右子树的高度差不能超过 1</strong>，会自动进行调整，<strong>不管平衡二叉查找树还是红黑树，都会随着插入的元素增多，而导致树的高度变高，这就意味着磁盘 I/O 操作次数多，会影响整体数据查询的效率</strong>。</p></li><li><p><strong>红黑树：</strong></p></li><li><p>B树：不再限制一个节点就只能有 2 个子节点，而是允许 M 个子节点 (M>2)，从而降低树的高度。B 树的每一个节点最多可以包括 M 个子节点，M 称为 B 树的阶，所以 B 树就是一个多叉树。</p><ul><li>B 树的每个节点都包含数据（索引+记录），而用户的记录数据的大小很有可能远远超过了索引数据，这就需要花费更多的磁盘 I/O 操作次数来读到「有用的索引数据」。</li><li>查询位于底层的某个节点（比如 A 记录）过程中，「非 A 记录节点」里的记录数据会从磁盘加载到内存，但是这些记录数据是没用的，我们只是想读取这些节点的索引数据来做比较查询，而「非 A 记录节点」里的记录数据对我们是没用的，这样不仅增多磁盘 I/O 操作次数，也占用内存资源。</li><li>如果使用 B 树来做范围查询的话，需要使用中序遍历，这会涉及多个节点的磁盘 I/O 问题，从而导致整体速度下降。</li></ul></li><li><p>B+树：</p><ul><li>叶子节点（最底部的节点）才会存放实际数据（索引+记录），非叶子节点只会存放索引；</li><li>所有索引都会在叶子节点出现，叶子节点之间构成一个有序链表；</li><li>非叶子节点的索引也会同时存在在子节点中，并且是在子节点中所有索引的最大（或最小）。</li><li>非叶子节点中有多少个子节点，就有多少个索引；</li></ul><p>1）单点查询效率：<strong>B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少</strong>。</p><p>2）插入和删除效率：B+ 树有大量的冗余节点，这样使得删除一个节点的时候，可以直接从叶子节点中删除，甚至可以不动非叶子节点，这样删除非常快。B+ 树的插入也是一样，有冗余节点，插入可能存在节点的分裂（如果节点饱和），但是最多只涉及树的一条路径。而且 B+ 树会自动平衡，不需要像更多复杂的算法，类似红黑树的旋转操作等。</p><p>3）范围查询：因为 <strong>B+ 树所有叶子节点间还有一个链表进行连接，这种设计对范围查找非常有帮助</strong>。因此，存在大量范围检索的场景，适合使用 B+树，比如数据库。而对于大量的单个索引查询的场景，可以考虑 B 树，比如 nosql 的MongoDB。</p></li></ol><h2 id=5-索引失效>5 索引失效<a hidden class=anchor aria-hidden=true href=#5-索引失效>#</a></h2><ol><li><p>对索引使用左或左右模糊匹配： <code>like %xx</code> 或者 <code>like %xx%</code> 这两种方式，<strong>因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。</strong></p><p><a href=https://xiaolincoding.com/mysql/index/index_issue.html>MySQL 使用 like “%x“，索引一定会失效吗？ | 小林coding (xiaolincoding.com)</a></p><p>如果表中只有两个字段，并且都是索引列，一个为主键字段，一个为要模糊匹配的字段，那么如果使用模糊匹配，会走覆盖索引，type=index，也就是扫描了整个索引树。</p><p>扫描的索引树是二级索引树，不扫描聚簇索引是因为聚簇索引记录的东西会更多，比如聚簇索引中的叶子节点则记录了主键值、事务 id、用于事务和 MVCC 的回滚指针以及所有的剩余列。</p></li><li><p>对索引使用函数：因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。</p><p>不过，从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。</p></li><li><p>对索引进行表达式计算：select * from t_user where id + 1 = 10;会导致索引失效，但是改成 where id = 10 - 1就可以走索引进行查询了。</p></li><li><p>对索引进行隐式类型转换：例如1）varchar类型的字段，但是在where子句中使用整形输入作为匹配条件，结果会导致走全表进行扫描。<strong>但是2）如果索引字段是整型类型，查询条件中的输入参数即使字符串，是不会导致索引失效，还是可以走索引扫描。</strong></p><p><strong>MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较</strong>。所以1）中相当于对索引使用了函数，而2）中将入参做了转换，所以会走索引。</p></li><li><p>联合索引非最左匹配：在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。</p><p>也就是说，如果我们想使用联合索引中尽可能多的列，查询条件中的各个列必须是联合索引中从最左边开始连续的列。如果我们仅仅按照第二列搜索，肯定无法走索引。</p></li><li><p>Where子句中的OR：在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</p></li></ol><h2 id=其他>其他<a hidden class=anchor aria-hidden=true href=#其他>#</a></h2><ol><li><p>MySQL单表存储数据最好不要超过2000W行;</p></li><li><p>count性能排序：count(*) > count(1) > count(主键字段) > count(字段)</p><p>count()<strong>统计符合查询条件的记录中，函数指定的参数不为 NULL 的记录有多少个</strong>，count(1)由于1是单纯的数字，永远不为NULL，所以count(1)作用是统计有多少条记录。</p><p>count(*)等于count(0)，MySQL会将 <code>*</code> 参数转化为参数 0 来处理。所以，<strong>count(*) 执行过程跟 count(1) 执行过程基本一样的</strong>，性能没有什么差异。而且 MySQL 会对 count(*) 和 count(1) 有个优化，如果有多个二级索引的时候，优化器会使用key_len 最小的二级索引进行扫描。</p></li></ol></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://roaraeonliou.github.io/posts/interviewnotes/new/java/1.java%E5%9F%BA%E7%A1%80/><span class=title>« Prev</span><br><span>1.Java基础</span>
</a><a class=next href=https://roaraeonliou.github.io/posts/interviewnotes/new/java/2.java%E9%9B%86%E5%90%88/><span class=title>Next »</span><br><span>2.Java集合</span></a></nav></footer><div id=comments><script src=https://giscus.app/client.js data-repo=RoaraeonLiou/roaraeonliou.github.io data-repo-id=R_kgDOMIxQ4w data-category=Announcements data-category-id=DIC_kwDOMIxQ484CgZUR data-mapping=title data-strict=1 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2024 <a href=https://roaraeonliou.github.io/>RLTEA BLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>