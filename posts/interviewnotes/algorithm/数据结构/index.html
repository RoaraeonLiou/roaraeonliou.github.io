<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>数据结构 | RLTEA BLOG</title>
<meta name=keywords content="笔记,算法"><meta name=description content="数据结构
1 线性数据结构
1.1 数组
1.2 链表
1.3 栈
1.4 队列
2 图
2.1 基本概念
2.2 图的存储
2.3 图的搜索
2.3.1 DFS
public int[] findOrder(int numCourses, int[][] prerequisites) {
    // adjacency list
    Set<Integer>[] graph = new Set[numCourses];
    for (int[] e : prerequisites) {
        // e[0] depends on e[1]
        // e[1] --> e[0]
        if (graph[e[1]] == null) {
            graph[e[1]] = new HashSet<>();
        }
        graph[e[1]].add(e[0]);
    }

    List<Integer> list = new ArrayList<>(numCourses);
    boolean[] globalVisited = new boolean[numCourses];
    boolean[] localVisited = new boolean[numCourses]; // to check cycle

    for (int i = 0; i < numCourses; ++i) {
        if (!dfs(graph, i, globalVisited, localVisited, list)) {
            return new int[0];
        }
    }

    // copy and reverse
    int[] result = new int[numCourses];
    for (int i = 0; i < numCourses; ++i) {
        result[i] = list.get(numCourses - i - 1);
    }
    return result;
}

// return: can finish
public boolean dfs(Set<Integer>[] graph, int node, boolean[] globalVisited, boolean[] localVisited, List<Integer> list) {
    if (localVisited[node]) return false;
    if (globalVisited[node]) return true;
    localVisited[node] = true;
    globalVisited[node] = true;
    Set<Integer> next = graph[node];
    if (next != null) {
        for (Integer n : next) {
            if (!dfs(graph, n, globalVisited, localVisited, list)) {
                // return false and exit, no need to reset localVisited
                return false;
            }
        }
    }
    localVisited[node] = false; // reset
    list.add(node);
    return true;
}
2.4 图的路径
2.4.1 弗洛伊德
class Solution {

    public int networkDelayTime(int[][] times, int N, int K) {
        // w[i][j]: time from [i] to [j], Integer.MAX_VALUE: inf
        int[][] w = new int[N+1][N+1];
        for (int i = 1; i <= N; ++i) {
            Arrays.fill(w[i], Integer.MAX_VALUE);
            w[i][i] = 0;
        }

        for (int[] e : times) {
            int u = e[0], v = e[1], t = e[2];
            w[u][v] = t;
        }

        for (int k = 1; k <= N; ++k) {
            for (int i = 1; i <= N; ++i) {
                for (int j = 1; j <= N; ++j) {
                    int sum;
                    if (w[i][k] == Integer.MAX_VALUE  w[k][j] == Integer.MAX_VALUE) {
                        sum = Integer.MAX_VALUE;
                    } else {
                        sum = w[i][k] + w[k][j];
                    }
                    w[i][j] = Math.min(w[i][j], sum);
                }
            }
        }

        int max = -1;
        for (int j = 1; j <= N; ++j) {
            if (w[K][j] == Integer.MAX_VALUE) return -1;
            max = Math.max(max, w[K][j]);
        }
        return max;
    }
}
2.4.2 Dijkstra
class Solution {
    public int networkDelayTime(int[][] times, int N, int K) {
        // graph[i]: List<int[]>, [to node, w]
        List<int[]>[] graph = new List[N+1];
        for (int i = 1; i <= N; ++i) {
            graph[i] = new LinkedList<>();
        }
        for (int[] e : times) {
            int from = e[0], to = e[1], w = e[2];
            graph[from].add(new int[]{to, w});
        }

        // [distance, node]
        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        // node --> min distance
        HashMap<Integer, Integer> dist = new HashMap<>();

        heap.offer(new int[]{0, K});

        while (heap.size() > 0) {
            int[] n = heap.poll();
            int distance = n[0];
            int node = n[1];
            if (dist.containsKey(node)) continue; // already determined
            dist.put(node, distance); // node determined
            for (int[] g : graph[node]) {
                int nextNode = g[0];
                int w = g[1];
                // K --> ... --> node --> nextNode
                if (dist.containsKey(nextNode)) continue; // alreay determined
                heap.offer(new int[]{distance + w, nextNode});
            }
        }

        if (dist.size() != N) return -1;
        int max = -1;
        for (int d : dist.values()) {
            max = Math.max(max, d);
        }
        return max;
    }
}
2.5 图的出入度问题
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        Map<Integer, List<Integer>> graph = new HashMap<>();
        int[] indegree = new int[numCourses];
        for (int[] e : prerequisites) {
            // e[0] depends on e[1]
            // e[1] --> e[0]
            int pre = e[1], cur = e[0];
            List<Integer> list = graph.get(pre);
            if (list == null) {
                list = new LinkedList<>();
                graph.put(pre, list);
            }
            list.add(cur);
            indegree[cur]++;
        }

        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < numCourses; ++i) {
            if (indegree[i] == 0) {
                queue.add(i);
            }
        }

        int[] result = new int[numCourses];
        int size = 0;
        while (queue.size() > 0) {
            int node = queue.poll();
            result[size++] = node;
            List<Integer> next = graph.get(node);
            if (next != null) {
                for (int n : next) {
                    indegree[n]--;
                    if (indegree[n] == 0) {
                        queue.offer(n);
                    }
                }
            }
        }

        if (size != numCourses) return new int[0];
        return result;
    }
}
2.6 最小生成树
2.6.1 Kruskal
class Solution {

    public int minimumCost(int N, int[][] connections) {
        // sort connections by cost from small to large
        Arrays.sort(connections, (a,b) -> a[2]-b[2]);

        int[] parent = new int[N+1];
        for (int i = 1; i <= N; ++i) {
            parent[i] = i;
        }

        int cost = 0;
        for (int[] edge : connections) {
            if (union(edge[0], edge[1], parent)) {
                cost += edge[2];
            }
        }

        // check if all the roots are the same
        int p = -1;
        for (int i = 1; i <= N; ++i) {
            int root = findRoot(i, parent);
            if (p == -1) {
                p = root;
            } else if (p != root) {
                return -1;
            }
        }
        return cost;
    }

    public int findRoot(int x, int[] parent) {
        while (x != parent[x]) {
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

    public boolean union(int a, int b, int[] parent) {
        a = findRoot(a, parent);
        b = findRoot(b, parent);
        if (a == b) return false;
        parent[a] = b;
        return true;
    }
}
2.6.2 Prim
class Solution {

    public int minimumCost(int N, int[][] connections) {

        int INF = Integer.MAX_VALUE;

        // graph[i][j]:
        //     INF: not reachable
        //     x: distance
        int[][] graph = new int[N+1][N+1];
        for (int i = 1; i <= N; ++i) {
            for (int j = 1; j <= N; ++j) {
                if (i == j) graph[i][j] = 0;
                else graph[i][j] = INF;
            }
        }
        for (int[] edge : connections) {
            int u = edge[0], v = edge[1], w = edge[2];
            graph[u][v] = graph[v][u] = w;
        }

        // dist[i]
        //     d: current min distance from one of added nodes
        //     INF: distance is inf, not reachable
        int[] dist = new int[N+1];
        Arrays.fill(dist, INF);
        // added nodes
        boolean[] added = new boolean[N+1];

        // set node [1] as candidates
        dist[1] = 0;

        int cost = 0;
        for (int k = 0; k < N; ++k) { // N nodes to add

            // find node with min distance
            int min = INF;
            int node = -1;
            for (int i = 1; i <= N; ++i) {
                if (!added[i] && dist[i] < min) {
                    min = dist[i];
                    node = i;
                }
            }

            // no reachable node found
            if (node == -1) {
                return -1;
            }

            // add [node]
            cost += dist[node];
            added[node] = true;

            // update dist[i] with distance from [node] to [i]
            for (int i = 1; i <= N; ++i) {
                if (added[i]) continue;
                if (graph[node][i] == INF) continue;
                dist[i] = Math.min(dist[i], graph[node][i]);
            }
        }
        return cost;
    }
}
3 堆
3.1 概念
3.2 分类
3.3 存储
3.4 操作
3.5 排序
4 树
4.1 分类
4.2 存储
4.3 遍历
5 红黑树
5.1 概念与特点
红黑树是一种自平衡二叉查找树。JDK中，TreeMap、TreeSet以及HashMap都使用了红黑树。"><meta name=author content="RLTEA"><link rel=canonical href=https://roaraeonliou.github.io/posts/interviewnotes/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.258803b0f0cc9a4a109c6fe78a9d39f2e0437217d71c5c9848255af9250f2b1b.css integrity="sha256-JYgDsPDMmkoQnG/nip058uBDchfXHFyYSCVa+SUPKxs=" rel="preload stylesheet" as=style><link rel=icon href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://roaraeonliou.github.io/posts/interviewnotes/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="数据结构"><meta property="og:description" content="数据结构
1 线性数据结构
1.1 数组
1.2 链表
1.3 栈
1.4 队列
2 图
2.1 基本概念
2.2 图的存储
2.3 图的搜索
2.3.1 DFS
public int[] findOrder(int numCourses, int[][] prerequisites) {
    // adjacency list
    Set<Integer>[] graph = new Set[numCourses];
    for (int[] e : prerequisites) {
        // e[0] depends on e[1]
        // e[1] --> e[0]
        if (graph[e[1]] == null) {
            graph[e[1]] = new HashSet<>();
        }
        graph[e[1]].add(e[0]);
    }

    List<Integer> list = new ArrayList<>(numCourses);
    boolean[] globalVisited = new boolean[numCourses];
    boolean[] localVisited = new boolean[numCourses]; // to check cycle

    for (int i = 0; i < numCourses; ++i) {
        if (!dfs(graph, i, globalVisited, localVisited, list)) {
            return new int[0];
        }
    }

    // copy and reverse
    int[] result = new int[numCourses];
    for (int i = 0; i < numCourses; ++i) {
        result[i] = list.get(numCourses - i - 1);
    }
    return result;
}

// return: can finish
public boolean dfs(Set<Integer>[] graph, int node, boolean[] globalVisited, boolean[] localVisited, List<Integer> list) {
    if (localVisited[node]) return false;
    if (globalVisited[node]) return true;
    localVisited[node] = true;
    globalVisited[node] = true;
    Set<Integer> next = graph[node];
    if (next != null) {
        for (Integer n : next) {
            if (!dfs(graph, n, globalVisited, localVisited, list)) {
                // return false and exit, no need to reset localVisited
                return false;
            }
        }
    }
    localVisited[node] = false; // reset
    list.add(node);
    return true;
}
2.4 图的路径
2.4.1 弗洛伊德
class Solution {

    public int networkDelayTime(int[][] times, int N, int K) {
        // w[i][j]: time from [i] to [j], Integer.MAX_VALUE: inf
        int[][] w = new int[N+1][N+1];
        for (int i = 1; i <= N; ++i) {
            Arrays.fill(w[i], Integer.MAX_VALUE);
            w[i][i] = 0;
        }

        for (int[] e : times) {
            int u = e[0], v = e[1], t = e[2];
            w[u][v] = t;
        }

        for (int k = 1; k <= N; ++k) {
            for (int i = 1; i <= N; ++i) {
                for (int j = 1; j <= N; ++j) {
                    int sum;
                    if (w[i][k] == Integer.MAX_VALUE  w[k][j] == Integer.MAX_VALUE) {
                        sum = Integer.MAX_VALUE;
                    } else {
                        sum = w[i][k] + w[k][j];
                    }
                    w[i][j] = Math.min(w[i][j], sum);
                }
            }
        }

        int max = -1;
        for (int j = 1; j <= N; ++j) {
            if (w[K][j] == Integer.MAX_VALUE) return -1;
            max = Math.max(max, w[K][j]);
        }
        return max;
    }
}
2.4.2 Dijkstra
class Solution {
    public int networkDelayTime(int[][] times, int N, int K) {
        // graph[i]: List<int[]>, [to node, w]
        List<int[]>[] graph = new List[N+1];
        for (int i = 1; i <= N; ++i) {
            graph[i] = new LinkedList<>();
        }
        for (int[] e : times) {
            int from = e[0], to = e[1], w = e[2];
            graph[from].add(new int[]{to, w});
        }

        // [distance, node]
        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        // node --> min distance
        HashMap<Integer, Integer> dist = new HashMap<>();

        heap.offer(new int[]{0, K});

        while (heap.size() > 0) {
            int[] n = heap.poll();
            int distance = n[0];
            int node = n[1];
            if (dist.containsKey(node)) continue; // already determined
            dist.put(node, distance); // node determined
            for (int[] g : graph[node]) {
                int nextNode = g[0];
                int w = g[1];
                // K --> ... --> node --> nextNode
                if (dist.containsKey(nextNode)) continue; // alreay determined
                heap.offer(new int[]{distance + w, nextNode});
            }
        }

        if (dist.size() != N) return -1;
        int max = -1;
        for (int d : dist.values()) {
            max = Math.max(max, d);
        }
        return max;
    }
}
2.5 图的出入度问题
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        Map<Integer, List<Integer>> graph = new HashMap<>();
        int[] indegree = new int[numCourses];
        for (int[] e : prerequisites) {
            // e[0] depends on e[1]
            // e[1] --> e[0]
            int pre = e[1], cur = e[0];
            List<Integer> list = graph.get(pre);
            if (list == null) {
                list = new LinkedList<>();
                graph.put(pre, list);
            }
            list.add(cur);
            indegree[cur]++;
        }

        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < numCourses; ++i) {
            if (indegree[i] == 0) {
                queue.add(i);
            }
        }

        int[] result = new int[numCourses];
        int size = 0;
        while (queue.size() > 0) {
            int node = queue.poll();
            result[size++] = node;
            List<Integer> next = graph.get(node);
            if (next != null) {
                for (int n : next) {
                    indegree[n]--;
                    if (indegree[n] == 0) {
                        queue.offer(n);
                    }
                }
            }
        }

        if (size != numCourses) return new int[0];
        return result;
    }
}
2.6 最小生成树
2.6.1 Kruskal
class Solution {

    public int minimumCost(int N, int[][] connections) {
        // sort connections by cost from small to large
        Arrays.sort(connections, (a,b) -> a[2]-b[2]);

        int[] parent = new int[N+1];
        for (int i = 1; i <= N; ++i) {
            parent[i] = i;
        }

        int cost = 0;
        for (int[] edge : connections) {
            if (union(edge[0], edge[1], parent)) {
                cost += edge[2];
            }
        }

        // check if all the roots are the same
        int p = -1;
        for (int i = 1; i <= N; ++i) {
            int root = findRoot(i, parent);
            if (p == -1) {
                p = root;
            } else if (p != root) {
                return -1;
            }
        }
        return cost;
    }

    public int findRoot(int x, int[] parent) {
        while (x != parent[x]) {
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

    public boolean union(int a, int b, int[] parent) {
        a = findRoot(a, parent);
        b = findRoot(b, parent);
        if (a == b) return false;
        parent[a] = b;
        return true;
    }
}
2.6.2 Prim
class Solution {

    public int minimumCost(int N, int[][] connections) {

        int INF = Integer.MAX_VALUE;

        // graph[i][j]:
        //     INF: not reachable
        //     x: distance
        int[][] graph = new int[N+1][N+1];
        for (int i = 1; i <= N; ++i) {
            for (int j = 1; j <= N; ++j) {
                if (i == j) graph[i][j] = 0;
                else graph[i][j] = INF;
            }
        }
        for (int[] edge : connections) {
            int u = edge[0], v = edge[1], w = edge[2];
            graph[u][v] = graph[v][u] = w;
        }

        // dist[i]
        //     d: current min distance from one of added nodes
        //     INF: distance is inf, not reachable
        int[] dist = new int[N+1];
        Arrays.fill(dist, INF);
        // added nodes
        boolean[] added = new boolean[N+1];

        // set node [1] as candidates
        dist[1] = 0;

        int cost = 0;
        for (int k = 0; k < N; ++k) { // N nodes to add

            // find node with min distance
            int min = INF;
            int node = -1;
            for (int i = 1; i <= N; ++i) {
                if (!added[i] && dist[i] < min) {
                    min = dist[i];
                    node = i;
                }
            }

            // no reachable node found
            if (node == -1) {
                return -1;
            }

            // add [node]
            cost += dist[node];
            added[node] = true;

            // update dist[i] with distance from [node] to [i]
            for (int i = 1; i <= N; ++i) {
                if (added[i]) continue;
                if (graph[node][i] == INF) continue;
                dist[i] = Math.min(dist[i], graph[node][i]);
            }
        }
        return cost;
    }
}
3 堆
3.1 概念
3.2 分类
3.3 存储
3.4 操作
3.5 排序
4 树
4.1 分类
4.2 存储
4.3 遍历
5 红黑树
5.1 概念与特点
红黑树是一种自平衡二叉查找树。JDK中，TreeMap、TreeSet以及HashMap都使用了红黑树。"><meta property="og:type" content="article"><meta property="og:url" content="https://roaraeonliou.github.io/posts/interviewnotes/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><meta property="og:image" content="https://roaraeonliou.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-09-26T00:00:00+00:00"><meta property="article:modified_time" content="2024-09-26T00:00:00+00:00"><meta property="og:site_name" content="RLTEA BLOG"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://roaraeonliou.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="数据结构"><meta name=twitter:description content="数据结构
1 线性数据结构
1.1 数组
1.2 链表
1.3 栈
1.4 队列
2 图
2.1 基本概念
2.2 图的存储
2.3 图的搜索
2.3.1 DFS
public int[] findOrder(int numCourses, int[][] prerequisites) {
    // adjacency list
    Set<Integer>[] graph = new Set[numCourses];
    for (int[] e : prerequisites) {
        // e[0] depends on e[1]
        // e[1] --> e[0]
        if (graph[e[1]] == null) {
            graph[e[1]] = new HashSet<>();
        }
        graph[e[1]].add(e[0]);
    }

    List<Integer> list = new ArrayList<>(numCourses);
    boolean[] globalVisited = new boolean[numCourses];
    boolean[] localVisited = new boolean[numCourses]; // to check cycle

    for (int i = 0; i < numCourses; ++i) {
        if (!dfs(graph, i, globalVisited, localVisited, list)) {
            return new int[0];
        }
    }

    // copy and reverse
    int[] result = new int[numCourses];
    for (int i = 0; i < numCourses; ++i) {
        result[i] = list.get(numCourses - i - 1);
    }
    return result;
}

// return: can finish
public boolean dfs(Set<Integer>[] graph, int node, boolean[] globalVisited, boolean[] localVisited, List<Integer> list) {
    if (localVisited[node]) return false;
    if (globalVisited[node]) return true;
    localVisited[node] = true;
    globalVisited[node] = true;
    Set<Integer> next = graph[node];
    if (next != null) {
        for (Integer n : next) {
            if (!dfs(graph, n, globalVisited, localVisited, list)) {
                // return false and exit, no need to reset localVisited
                return false;
            }
        }
    }
    localVisited[node] = false; // reset
    list.add(node);
    return true;
}
2.4 图的路径
2.4.1 弗洛伊德
class Solution {

    public int networkDelayTime(int[][] times, int N, int K) {
        // w[i][j]: time from [i] to [j], Integer.MAX_VALUE: inf
        int[][] w = new int[N+1][N+1];
        for (int i = 1; i <= N; ++i) {
            Arrays.fill(w[i], Integer.MAX_VALUE);
            w[i][i] = 0;
        }

        for (int[] e : times) {
            int u = e[0], v = e[1], t = e[2];
            w[u][v] = t;
        }

        for (int k = 1; k <= N; ++k) {
            for (int i = 1; i <= N; ++i) {
                for (int j = 1; j <= N; ++j) {
                    int sum;
                    if (w[i][k] == Integer.MAX_VALUE  w[k][j] == Integer.MAX_VALUE) {
                        sum = Integer.MAX_VALUE;
                    } else {
                        sum = w[i][k] + w[k][j];
                    }
                    w[i][j] = Math.min(w[i][j], sum);
                }
            }
        }

        int max = -1;
        for (int j = 1; j <= N; ++j) {
            if (w[K][j] == Integer.MAX_VALUE) return -1;
            max = Math.max(max, w[K][j]);
        }
        return max;
    }
}
2.4.2 Dijkstra
class Solution {
    public int networkDelayTime(int[][] times, int N, int K) {
        // graph[i]: List<int[]>, [to node, w]
        List<int[]>[] graph = new List[N+1];
        for (int i = 1; i <= N; ++i) {
            graph[i] = new LinkedList<>();
        }
        for (int[] e : times) {
            int from = e[0], to = e[1], w = e[2];
            graph[from].add(new int[]{to, w});
        }

        // [distance, node]
        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        // node --> min distance
        HashMap<Integer, Integer> dist = new HashMap<>();

        heap.offer(new int[]{0, K});

        while (heap.size() > 0) {
            int[] n = heap.poll();
            int distance = n[0];
            int node = n[1];
            if (dist.containsKey(node)) continue; // already determined
            dist.put(node, distance); // node determined
            for (int[] g : graph[node]) {
                int nextNode = g[0];
                int w = g[1];
                // K --> ... --> node --> nextNode
                if (dist.containsKey(nextNode)) continue; // alreay determined
                heap.offer(new int[]{distance + w, nextNode});
            }
        }

        if (dist.size() != N) return -1;
        int max = -1;
        for (int d : dist.values()) {
            max = Math.max(max, d);
        }
        return max;
    }
}
2.5 图的出入度问题
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        Map<Integer, List<Integer>> graph = new HashMap<>();
        int[] indegree = new int[numCourses];
        for (int[] e : prerequisites) {
            // e[0] depends on e[1]
            // e[1] --> e[0]
            int pre = e[1], cur = e[0];
            List<Integer> list = graph.get(pre);
            if (list == null) {
                list = new LinkedList<>();
                graph.put(pre, list);
            }
            list.add(cur);
            indegree[cur]++;
        }

        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < numCourses; ++i) {
            if (indegree[i] == 0) {
                queue.add(i);
            }
        }

        int[] result = new int[numCourses];
        int size = 0;
        while (queue.size() > 0) {
            int node = queue.poll();
            result[size++] = node;
            List<Integer> next = graph.get(node);
            if (next != null) {
                for (int n : next) {
                    indegree[n]--;
                    if (indegree[n] == 0) {
                        queue.offer(n);
                    }
                }
            }
        }

        if (size != numCourses) return new int[0];
        return result;
    }
}
2.6 最小生成树
2.6.1 Kruskal
class Solution {

    public int minimumCost(int N, int[][] connections) {
        // sort connections by cost from small to large
        Arrays.sort(connections, (a,b) -> a[2]-b[2]);

        int[] parent = new int[N+1];
        for (int i = 1; i <= N; ++i) {
            parent[i] = i;
        }

        int cost = 0;
        for (int[] edge : connections) {
            if (union(edge[0], edge[1], parent)) {
                cost += edge[2];
            }
        }

        // check if all the roots are the same
        int p = -1;
        for (int i = 1; i <= N; ++i) {
            int root = findRoot(i, parent);
            if (p == -1) {
                p = root;
            } else if (p != root) {
                return -1;
            }
        }
        return cost;
    }

    public int findRoot(int x, int[] parent) {
        while (x != parent[x]) {
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

    public boolean union(int a, int b, int[] parent) {
        a = findRoot(a, parent);
        b = findRoot(b, parent);
        if (a == b) return false;
        parent[a] = b;
        return true;
    }
}
2.6.2 Prim
class Solution {

    public int minimumCost(int N, int[][] connections) {

        int INF = Integer.MAX_VALUE;

        // graph[i][j]:
        //     INF: not reachable
        //     x: distance
        int[][] graph = new int[N+1][N+1];
        for (int i = 1; i <= N; ++i) {
            for (int j = 1; j <= N; ++j) {
                if (i == j) graph[i][j] = 0;
                else graph[i][j] = INF;
            }
        }
        for (int[] edge : connections) {
            int u = edge[0], v = edge[1], w = edge[2];
            graph[u][v] = graph[v][u] = w;
        }

        // dist[i]
        //     d: current min distance from one of added nodes
        //     INF: distance is inf, not reachable
        int[] dist = new int[N+1];
        Arrays.fill(dist, INF);
        // added nodes
        boolean[] added = new boolean[N+1];

        // set node [1] as candidates
        dist[1] = 0;

        int cost = 0;
        for (int k = 0; k < N; ++k) { // N nodes to add

            // find node with min distance
            int min = INF;
            int node = -1;
            for (int i = 1; i <= N; ++i) {
                if (!added[i] && dist[i] < min) {
                    min = dist[i];
                    node = i;
                }
            }

            // no reachable node found
            if (node == -1) {
                return -1;
            }

            // add [node]
            cost += dist[node];
            added[node] = true;

            // update dist[i] with distance from [node] to [i]
            for (int i = 1; i <= N; ++i) {
                if (added[i]) continue;
                if (graph[node][i] == INF) continue;
                dist[i] = Math.min(dist[i], graph[node][i]);
            }
        }
        return cost;
    }
}
3 堆
3.1 概念
3.2 分类
3.3 存储
3.4 操作
3.5 排序
4 树
4.1 分类
4.2 存储
4.3 遍历
5 红黑树
5.1 概念与特点
红黑树是一种自平衡二叉查找树。JDK中，TreeMap、TreeSet以及HashMap都使用了红黑树。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://roaraeonliou.github.io/posts/"},{"@type":"ListItem","position":2,"name":"数据结构","item":"https://roaraeonliou.github.io/posts/interviewnotes/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"数据结构","name":"数据结构","description":"数据结构 1 线性数据结构 1.1 数组 1.2 链表 1.3 栈 1.4 队列 2 图 2.1 基本概念 2.2 图的存储 2.3 图的搜索 2.3.1 DFS public int[] findOrder(int numCourses, int[][] prerequisites) { // adjacency list Set\u0026lt;Integer\u0026gt;[] graph = new Set[numCourses]; for (int[] e : prerequisites) { // e[0] depends on e[1] // e[1] --\u0026gt; e[0] if (graph[e[1]] == null) { graph[e[1]] = new HashSet\u0026lt;\u0026gt;(); } graph[e[1]].add(e[0]); } List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(numCourses); boolean[] globalVisited = new boolean[numCourses]; boolean[] localVisited = new boolean[numCourses]; // to check cycle for (int i = 0; i \u0026lt; numCourses; ++i) { if (!dfs(graph, i, globalVisited, localVisited, list)) { return new int[0]; } } // copy and reverse int[] result = new int[numCourses]; for (int i = 0; i \u0026lt; numCourses; ++i) { result[i] = list.get(numCourses - i - 1); } return result; } // return: can finish public boolean dfs(Set\u0026lt;Integer\u0026gt;[] graph, int node, boolean[] globalVisited, boolean[] localVisited, List\u0026lt;Integer\u0026gt; list) { if (localVisited[node]) return false; if (globalVisited[node]) return true; localVisited[node] = true; globalVisited[node] = true; Set\u0026lt;Integer\u0026gt; next = graph[node]; if (next != null) { for (Integer n : next) { if (!dfs(graph, n, globalVisited, localVisited, list)) { // return false and exit, no need to reset localVisited return false; } } } localVisited[node] = false; // reset list.add(node); return true; } 2.4 图的路径 2.4.1 弗洛伊德 class Solution { public int networkDelayTime(int[][] times, int N, int K) { // w[i][j]: time from [i] to [j], Integer.MAX_VALUE: inf int[][] w = new int[N+1][N+1]; for (int i = 1; i \u0026lt;= N; ++i) { Arrays.fill(w[i], Integer.MAX_VALUE); w[i][i] = 0; } for (int[] e : times) { int u = e[0], v = e[1], t = e[2]; w[u][v] = t; } for (int k = 1; k \u0026lt;= N; ++k) { for (int i = 1; i \u0026lt;= N; ++i) { for (int j = 1; j \u0026lt;= N; ++j) { int sum; if (w[i][k] == Integer.MAX_VALUE w[k][j] == Integer.MAX_VALUE) { sum = Integer.MAX_VALUE; } else { sum = w[i][k] + w[k][j]; } w[i][j] = Math.min(w[i][j], sum); } } } int max = -1; for (int j = 1; j \u0026lt;= N; ++j) { if (w[K][j] == Integer.MAX_VALUE) return -1; max = Math.max(max, w[K][j]); } return max; } } 2.4.2 Dijkstra class Solution { public int networkDelayTime(int[][] times, int N, int K) { // graph[i]: List\u0026lt;int[]\u0026gt;, [to node, w] List\u0026lt;int[]\u0026gt;[] graph = new List[N+1]; for (int i = 1; i \u0026lt;= N; ++i) { graph[i] = new LinkedList\u0026lt;\u0026gt;(); } for (int[] e : times) { int from = e[0], to = e[1], w = e[2]; graph[from].add(new int[]{to, w}); } // [distance, node] PriorityQueue\u0026lt;int[]\u0026gt; heap = new PriorityQueue\u0026lt;\u0026gt;((a, b) -\u0026gt; a[0] - b[0]); // node --\u0026gt; min distance HashMap\u0026lt;Integer, Integer\u0026gt; dist = new HashMap\u0026lt;\u0026gt;(); heap.offer(new int[]{0, K}); while (heap.size() \u0026gt; 0) { int[] n = heap.poll(); int distance = n[0]; int node = n[1]; if (dist.containsKey(node)) continue; // already determined dist.put(node, distance); // node determined for (int[] g : graph[node]) { int nextNode = g[0]; int w = g[1]; // K --\u0026gt; ... --\u0026gt; node --\u0026gt; nextNode if (dist.containsKey(nextNode)) continue; // alreay determined heap.offer(new int[]{distance + w, nextNode}); } } if (dist.size() != N) return -1; int max = -1; for (int d : dist.values()) { max = Math.max(max, d); } return max; } } 2.5 图的出入度问题 class Solution { public int[] findOrder(int numCourses, int[][] prerequisites) { Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; graph = new HashMap\u0026lt;\u0026gt;(); int[] indegree = new int[numCourses]; for (int[] e : prerequisites) { // e[0] depends on e[1] // e[1] --\u0026gt; e[0] int pre = e[1], cur = e[0]; List\u0026lt;Integer\u0026gt; list = graph.get(pre); if (list == null) { list = new LinkedList\u0026lt;\u0026gt;(); graph.put(pre, list); } list.add(cur); indegree[cur]++; } Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; numCourses; ++i) { if (indegree[i] == 0) { queue.add(i); } } int[] result = new int[numCourses]; int size = 0; while (queue.size() \u0026gt; 0) { int node = queue.poll(); result[size++] = node; List\u0026lt;Integer\u0026gt; next = graph.get(node); if (next != null) { for (int n : next) { indegree[n]--; if (indegree[n] == 0) { queue.offer(n); } } } } if (size != numCourses) return new int[0]; return result; } } 2.6 最小生成树 2.6.1 Kruskal class Solution { public int minimumCost(int N, int[][] connections) { // sort connections by cost from small to large Arrays.sort(connections, (a,b) -\u0026gt; a[2]-b[2]); int[] parent = new int[N+1]; for (int i = 1; i \u0026lt;= N; ++i) { parent[i] = i; } int cost = 0; for (int[] edge : connections) { if (union(edge[0], edge[1], parent)) { cost += edge[2]; } } // check if all the roots are the same int p = -1; for (int i = 1; i \u0026lt;= N; ++i) { int root = findRoot(i, parent); if (p == -1) { p = root; } else if (p != root) { return -1; } } return cost; } public int findRoot(int x, int[] parent) { while (x != parent[x]) { parent[x] = parent[parent[x]]; x = parent[x]; } return x; } public boolean union(int a, int b, int[] parent) { a = findRoot(a, parent); b = findRoot(b, parent); if (a == b) return false; parent[a] = b; return true; } } 2.6.2 Prim class Solution { public int minimumCost(int N, int[][] connections) { int INF = Integer.MAX_VALUE; // graph[i][j]: // INF: not reachable // x: distance int[][] graph = new int[N+1][N+1]; for (int i = 1; i \u0026lt;= N; ++i) { for (int j = 1; j \u0026lt;= N; ++j) { if (i == j) graph[i][j] = 0; else graph[i][j] = INF; } } for (int[] edge : connections) { int u = edge[0], v = edge[1], w = edge[2]; graph[u][v] = graph[v][u] = w; } // dist[i] // d: current min distance from one of added nodes // INF: distance is inf, not reachable int[] dist = new int[N+1]; Arrays.fill(dist, INF); // added nodes boolean[] added = new boolean[N+1]; // set node [1] as candidates dist[1] = 0; int cost = 0; for (int k = 0; k \u0026lt; N; ++k) { // N nodes to add // find node with min distance int min = INF; int node = -1; for (int i = 1; i \u0026lt;= N; ++i) { if (!added[i] \u0026amp;\u0026amp; dist[i] \u0026lt; min) { min = dist[i]; node = i; } } // no reachable node found if (node == -1) { return -1; } // add [node] cost += dist[node]; added[node] = true; // update dist[i] with distance from [node] to [i] for (int i = 1; i \u0026lt;= N; ++i) { if (added[i]) continue; if (graph[node][i] == INF) continue; dist[i] = Math.min(dist[i], graph[node][i]); } } return cost; } } 3 堆 3.1 概念 3.2 分类 3.3 存储 3.4 操作 3.5 排序 4 树 4.1 分类 4.2 存储 4.3 遍历 5 红黑树 5.1 概念与特点 红黑树是一种自平衡二叉查找树。JDK中，TreeMap、TreeSet以及HashMap都使用了红黑树。\n","keywords":["笔记","算法"],"articleBody":"数据结构 1 线性数据结构 1.1 数组 1.2 链表 1.3 栈 1.4 队列 2 图 2.1 基本概念 2.2 图的存储 2.3 图的搜索 2.3.1 DFS public int[] findOrder(int numCourses, int[][] prerequisites) { // adjacency list Set\u003cInteger\u003e[] graph = new Set[numCourses]; for (int[] e : prerequisites) { // e[0] depends on e[1] // e[1] --\u003e e[0] if (graph[e[1]] == null) { graph[e[1]] = new HashSet\u003c\u003e(); } graph[e[1]].add(e[0]); } List\u003cInteger\u003e list = new ArrayList\u003c\u003e(numCourses); boolean[] globalVisited = new boolean[numCourses]; boolean[] localVisited = new boolean[numCourses]; // to check cycle for (int i = 0; i \u003c numCourses; ++i) { if (!dfs(graph, i, globalVisited, localVisited, list)) { return new int[0]; } } // copy and reverse int[] result = new int[numCourses]; for (int i = 0; i \u003c numCourses; ++i) { result[i] = list.get(numCourses - i - 1); } return result; } // return: can finish public boolean dfs(Set\u003cInteger\u003e[] graph, int node, boolean[] globalVisited, boolean[] localVisited, List\u003cInteger\u003e list) { if (localVisited[node]) return false; if (globalVisited[node]) return true; localVisited[node] = true; globalVisited[node] = true; Set\u003cInteger\u003e next = graph[node]; if (next != null) { for (Integer n : next) { if (!dfs(graph, n, globalVisited, localVisited, list)) { // return false and exit, no need to reset localVisited return false; } } } localVisited[node] = false; // reset list.add(node); return true; } 2.4 图的路径 2.4.1 弗洛伊德 class Solution { public int networkDelayTime(int[][] times, int N, int K) { // w[i][j]: time from [i] to [j], Integer.MAX_VALUE: inf int[][] w = new int[N+1][N+1]; for (int i = 1; i \u003c= N; ++i) { Arrays.fill(w[i], Integer.MAX_VALUE); w[i][i] = 0; } for (int[] e : times) { int u = e[0], v = e[1], t = e[2]; w[u][v] = t; } for (int k = 1; k \u003c= N; ++k) { for (int i = 1; i \u003c= N; ++i) { for (int j = 1; j \u003c= N; ++j) { int sum; if (w[i][k] == Integer.MAX_VALUE w[k][j] == Integer.MAX_VALUE) { sum = Integer.MAX_VALUE; } else { sum = w[i][k] + w[k][j]; } w[i][j] = Math.min(w[i][j], sum); } } } int max = -1; for (int j = 1; j \u003c= N; ++j) { if (w[K][j] == Integer.MAX_VALUE) return -1; max = Math.max(max, w[K][j]); } return max; } } 2.4.2 Dijkstra class Solution { public int networkDelayTime(int[][] times, int N, int K) { // graph[i]: List, [to node, w] List\u003cint[]\u003e[] graph = new List[N+1]; for (int i = 1; i \u003c= N; ++i) { graph[i] = new LinkedList\u003c\u003e(); } for (int[] e : times) { int from = e[0], to = e[1], w = e[2]; graph[from].add(new int[]{to, w}); } // [distance, node] PriorityQueue\u003cint[]\u003e heap = new PriorityQueue\u003c\u003e((a, b) -\u003e a[0] - b[0]); // node --\u003e min distance HashMap\u003cInteger, Integer\u003e dist = new HashMap\u003c\u003e(); heap.offer(new int[]{0, K}); while (heap.size() \u003e 0) { int[] n = heap.poll(); int distance = n[0]; int node = n[1]; if (dist.containsKey(node)) continue; // already determined dist.put(node, distance); // node determined for (int[] g : graph[node]) { int nextNode = g[0]; int w = g[1]; // K --\u003e ... --\u003e node --\u003e nextNode if (dist.containsKey(nextNode)) continue; // alreay determined heap.offer(new int[]{distance + w, nextNode}); } } if (dist.size() != N) return -1; int max = -1; for (int d : dist.values()) { max = Math.max(max, d); } return max; } } 2.5 图的出入度问题 class Solution { public int[] findOrder(int numCourses, int[][] prerequisites) { Map\u003cInteger, List\u003cInteger\u003e\u003e graph = new HashMap\u003c\u003e(); int[] indegree = new int[numCourses]; for (int[] e : prerequisites) { // e[0] depends on e[1] // e[1] --\u003e e[0] int pre = e[1], cur = e[0]; List\u003cInteger\u003e list = graph.get(pre); if (list == null) { list = new LinkedList\u003c\u003e(); graph.put(pre, list); } list.add(cur); indegree[cur]++; } Queue\u003cInteger\u003e queue = new LinkedList\u003c\u003e(); for (int i = 0; i \u003c numCourses; ++i) { if (indegree[i] == 0) { queue.add(i); } } int[] result = new int[numCourses]; int size = 0; while (queue.size() \u003e 0) { int node = queue.poll(); result[size++] = node; List\u003cInteger\u003e next = graph.get(node); if (next != null) { for (int n : next) { indegree[n]--; if (indegree[n] == 0) { queue.offer(n); } } } } if (size != numCourses) return new int[0]; return result; } } 2.6 最小生成树 2.6.1 Kruskal class Solution { public int minimumCost(int N, int[][] connections) { // sort connections by cost from small to large Arrays.sort(connections, (a,b) -\u003e a[2]-b[2]); int[] parent = new int[N+1]; for (int i = 1; i \u003c= N; ++i) { parent[i] = i; } int cost = 0; for (int[] edge : connections) { if (union(edge[0], edge[1], parent)) { cost += edge[2]; } } // check if all the roots are the same int p = -1; for (int i = 1; i \u003c= N; ++i) { int root = findRoot(i, parent); if (p == -1) { p = root; } else if (p != root) { return -1; } } return cost; } public int findRoot(int x, int[] parent) { while (x != parent[x]) { parent[x] = parent[parent[x]]; x = parent[x]; } return x; } public boolean union(int a, int b, int[] parent) { a = findRoot(a, parent); b = findRoot(b, parent); if (a == b) return false; parent[a] = b; return true; } } 2.6.2 Prim class Solution { public int minimumCost(int N, int[][] connections) { int INF = Integer.MAX_VALUE; // graph[i][j]: // INF: not reachable // x: distance int[][] graph = new int[N+1][N+1]; for (int i = 1; i \u003c= N; ++i) { for (int j = 1; j \u003c= N; ++j) { if (i == j) graph[i][j] = 0; else graph[i][j] = INF; } } for (int[] edge : connections) { int u = edge[0], v = edge[1], w = edge[2]; graph[u][v] = graph[v][u] = w; } // dist[i] // d: current min distance from one of added nodes // INF: distance is inf, not reachable int[] dist = new int[N+1]; Arrays.fill(dist, INF); // added nodes boolean[] added = new boolean[N+1]; // set node [1] as candidates dist[1] = 0; int cost = 0; for (int k = 0; k \u003c N; ++k) { // N nodes to add // find node with min distance int min = INF; int node = -1; for (int i = 1; i \u003c= N; ++i) { if (!added[i] \u0026\u0026 dist[i] \u003c min) { min = dist[i]; node = i; } } // no reachable node found if (node == -1) { return -1; } // add [node] cost += dist[node]; added[node] = true; // update dist[i] with distance from [node] to [i] for (int i = 1; i \u003c= N; ++i) { if (added[i]) continue; if (graph[node][i] == INF) continue; dist[i] = Math.min(dist[i], graph[node][i]); } } return cost; } } 3 堆 3.1 概念 3.2 分类 3.3 存储 3.4 操作 3.5 排序 4 树 4.1 分类 4.2 存储 4.3 遍历 5 红黑树 5.1 概念与特点 红黑树是一种自平衡二叉查找树。JDK中，TreeMap、TreeSet以及HashMap都使用了红黑树。\n特点：\n节点非黑即红，黑色决定平衡，红色不决定平衡。 根节点总是黑色的。 每个叶子节点都是黑色的空节点。 如果节点是红色，那它的子节点一定是黑色（反之不一定），胡总和说不会有连续的红色节点。一个节点最多临时有三个节点，中间黑，左右红。 从任意节点到他的叶子节点或空子节点的每条路径，必定包含相同数量的而黑色节点。每一层都只有一个节点贡献了树高决定平衡性，也就是对应红黑树中的黑色节点。 红黑树高度不会超过2log(n+1)\n5.2 数据结构 建立在 BST 二叉搜索树的基础上，AVL、2-3 树、红黑树都是自平衡二叉树（统称 B-树）。但相比于 AVL 树，高度平衡所带来的时间复杂度，红黑树对平衡的控制要宽松一些，红黑树只需要保证黑色节点平衡即可。\npublic class Node { public Class\u003c?\u003e clazz; public Integer value; public Node parent; public Node left; public Node right; // AVL 树所需属性 public int height; // 红黑树所需属性 public Color color = Color.RED; } 5.3 平衡调整 左倾染色 染色时根据当前节点的爷爷节点，找到当前节点的父亲、叔叔节点 把父亲、叔叔节点染黑，爷爷节点染红。 爷爷节点染红是临时的，当平衡树高操作后，会把根节点染黑 右倾染色 同上\n左旋调整 一次左旋 右旋+左旋 右旋调整 一次右旋 左旋+右旋 6 布隆过滤器 6.1 原理及使用场景 使用一个较大的bit数组保存所有数据，每个元素只占用1bit。用于判断元素是否存在，结果具有概率性，加入的元素越多，误报的概率越大。\n原理：\n当加入一个元素时：使用布隆过滤器中的哈希函数堆元素值计算，得到哈希值，根据哈希值将对应下标设置为1。 当判断元素是否存在时：对给定元素再次计算，如果对应位为1，则存在，否则不存在。 布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。 使用场景\n判断是否存在：防止缓存穿透、邮箱的垃圾邮件过滤，黑名单功能等 去重：去除以及爬取过的url，对订单号去重 6.2 编码实现 import java.util.BitSet; public class MyBloomFilter { private static final int DEFAULT_SIZE = 2 \u003c\u003c 24; private static final int[] SEEDS = new int[]{3, 13, 46, 71, 91, 134}; private BitSet bits = new BitSet(DEFAULT_SIZE); private SimpleHash[] func = new SimpleHash[SEEDS.length]; public MyBloomFilter(){ for (int i = 0; i \u003c SEEDS.length; i++) { func[i] = new SimpleHash(DEFAULT_SIZE, SEEDS[i]); } } public void add(Object value){ for(SimpleHash f : func){ bits.set(f.hash(value), true); } } public boolean contains(Object value){ boolean ret = true; for(SimpleHash f : func){ ret = ret \u0026\u0026 bits.get(f.hash(value)); } return ret; } public static class SimpleHash { private int cap; private int seed; public SimpleHash(int cap, int seed) { this.cap = cap; this.seed = seed; } public int hash(Object value) { int h; if (value == null) return 0; return Math.abs(seed * (cap - 1) \u0026 ((h = value.hashCode()) ^ (h \u003e\u003e\u003e 16))); } } } public static void main(String[] args) { String value1 = \"abcdefg\"; String value2 = \"xxxxxxx\"; MyBloomFilter filter = new MyBloomFilter(); System.out.println(filter.contains(value1)); System.out.println(filter.contains(value2)); filter.add(value1); filter.add(value2); System.out.println(filter.contains(value1)); System.out.println(filter.contains(value2)); } ","wordCount":"1372","inLanguage":"en","image":"https://roaraeonliou.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-09-26T00:00:00Z","dateModified":"2024-09-26T00:00:00Z","author":{"@type":"Person","name":"RLTEA"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://roaraeonliou.github.io/posts/interviewnotes/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},"publisher":{"@type":"Organization","name":"RLTEA BLOG","logo":{"@type":"ImageObject","url":"https://roaraeonliou.github.io/%3Clink%20/%20abs%20url%3E"}}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["\\(","\\)"],["$","$"]]}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://roaraeonliou.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://roaraeonliou.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://roaraeonliou.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://roaraeonliou.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://roaraeonliou.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://roaraeonliou.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://roaraeonliou.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://roaraeonliou.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">数据结构</h1><div class=post-meta><span title='2024-09-26 00:00:00 +0000 UTC'>September 26, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1372 words&nbsp;·&nbsp;RLTEA&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/InterviewNotes/Algorithm/%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label=数据结构>数据结构</a></li><li><a href=#1-%e7%ba%bf%e6%80%a7%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label="1 线性数据结构">1 线性数据结构</a><ul><li><a href=#11-%e6%95%b0%e7%bb%84 aria-label="1.1 数组">1.1 数组</a></li><li><a href=#12-%e9%93%be%e8%a1%a8 aria-label="1.2 链表">1.2 链表</a></li><li><a href=#13-%e6%a0%88 aria-label="1.3 栈">1.3 栈</a></li><li><a href=#14-%e9%98%9f%e5%88%97 aria-label="1.4 队列">1.4 队列</a></li></ul></li><li><a href=#2-%e5%9b%be aria-label="2 图">2 图</a><ul><li><a href=#21-%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5 aria-label="2.1 基本概念">2.1 基本概念</a></li><li><a href=#22-%e5%9b%be%e7%9a%84%e5%ad%98%e5%82%a8 aria-label="2.2 图的存储">2.2 图的存储</a></li><li><a href=#23-%e5%9b%be%e7%9a%84%e6%90%9c%e7%b4%a2 aria-label="2.3 图的搜索">2.3 图的搜索</a><ul><li><a href=#231-dfs aria-label="2.3.1 DFS">2.3.1 DFS</a></li></ul></li><li><a href=#24-%e5%9b%be%e7%9a%84%e8%b7%af%e5%be%84 aria-label="2.4 图的路径">2.4 图的路径</a><ul><li><a href=#241-%e5%bc%97%e6%b4%9b%e4%bc%8a%e5%be%b7 aria-label="2.4.1 弗洛伊德">2.4.1 弗洛伊德</a></li><li><a href=#242-dijkstra aria-label="2.4.2 Dijkstra">2.4.2 Dijkstra</a></li></ul></li><li><a href=#25-%e5%9b%be%e7%9a%84%e5%87%ba%e5%85%a5%e5%ba%a6%e9%97%ae%e9%a2%98 aria-label="2.5 图的出入度问题">2.5 图的出入度问题</a></li><li><a href=#26-%e6%9c%80%e5%b0%8f%e7%94%9f%e6%88%90%e6%a0%91 aria-label="2.6 最小生成树">2.6 最小生成树</a><ul><li><a href=#261-kruskal aria-label="2.6.1 Kruskal">2.6.1 Kruskal</a></li><li><a href=#262-prim aria-label="2.6.2 Prim">2.6.2 Prim</a></li></ul></li></ul></li><li><a href=#3-%e5%a0%86 aria-label="3 堆">3 堆</a><ul><li><a href=#31-%e6%a6%82%e5%bf%b5 aria-label="3.1 概念">3.1 概念</a></li><li><a href=#32-%e5%88%86%e7%b1%bb aria-label="3.2 分类">3.2 分类</a></li><li><a href=#33-%e5%ad%98%e5%82%a8 aria-label="3.3 存储">3.3 存储</a></li><li><a href=#34-%e6%93%8d%e4%bd%9c aria-label="3.4 操作">3.4 操作</a></li><li><a href=#35-%e6%8e%92%e5%ba%8f aria-label="3.5 排序">3.5 排序</a></li></ul></li><li><a href=#4-%e6%a0%91 aria-label="4 树">4 树</a><ul><li><a href=#41-%e5%88%86%e7%b1%bb aria-label="4.1 分类">4.1 分类</a></li><li><a href=#42-%e5%ad%98%e5%82%a8 aria-label="4.2 存储">4.2 存储</a></li><li><a href=#43-%e9%81%8d%e5%8e%86 aria-label="4.3 遍历">4.3 遍历</a></li></ul></li><li><a href=#5-%e7%ba%a2%e9%bb%91%e6%a0%91 aria-label="5 红黑树">5 红黑树</a><ul><li><a href=#51-%e6%a6%82%e5%bf%b5%e4%b8%8e%e7%89%b9%e7%82%b9 aria-label="5.1 概念与特点">5.1 概念与特点</a></li><li><a href=#52-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label="5.2 数据结构">5.2 数据结构</a></li><li><a href=#53-%e5%b9%b3%e8%a1%a1%e8%b0%83%e6%95%b4 aria-label="5.3 平衡调整">5.3 平衡调整</a></li></ul></li><li><a href=#6-%e5%b8%83%e9%9a%86%e8%bf%87%e6%bb%a4%e5%99%a8 aria-label="6 布隆过滤器">6 布隆过滤器</a><ul><li><a href=#61-%e5%8e%9f%e7%90%86%e5%8f%8a%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af aria-label="6.1 原理及使用场景">6.1 原理及使用场景</a></li><li><a href=#62-%e7%bc%96%e7%a0%81%e5%ae%9e%e7%8e%b0 aria-label="6.2 编码实现">6.2 编码实现</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=数据结构>数据结构<a hidden class=anchor aria-hidden=true href=#数据结构>#</a></h1><h1 id=1-线性数据结构>1 线性数据结构<a hidden class=anchor aria-hidden=true href=#1-线性数据结构>#</a></h1><h2 id=11-数组>1.1 数组<a hidden class=anchor aria-hidden=true href=#11-数组>#</a></h2><h2 id=12-链表>1.2 链表<a hidden class=anchor aria-hidden=true href=#12-链表>#</a></h2><h2 id=13-栈>1.3 栈<a hidden class=anchor aria-hidden=true href=#13-栈>#</a></h2><h2 id=14-队列>1.4 队列<a hidden class=anchor aria-hidden=true href=#14-队列>#</a></h2><h1 id=2-图>2 图<a hidden class=anchor aria-hidden=true href=#2-图>#</a></h1><h2 id=21-基本概念>2.1 基本概念<a hidden class=anchor aria-hidden=true href=#21-基本概念>#</a></h2><h2 id=22-图的存储>2.2 图的存储<a hidden class=anchor aria-hidden=true href=#22-图的存储>#</a></h2><h2 id=23-图的搜索>2.3 图的搜索<a hidden class=anchor aria-hidden=true href=#23-图的搜索>#</a></h2><h3 id=231-dfs>2.3.1 DFS<a hidden class=anchor aria-hidden=true href=#231-dfs>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=nf>findOrder</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>numCourses</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=o>[][]</span><span class=w> </span><span class=n>prerequisites</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// adjacency list</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Set</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;[]</span><span class=w> </span><span class=n>graph</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Set</span><span class=o>[</span><span class=n>numCourses</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>e</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>prerequisites</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// e[0] depends on e[1]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// e[1] --&gt; e[0]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>graph</span><span class=o>[</span><span class=n>e</span><span class=o>[</span><span class=n>1</span><span class=o>]]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>graph</span><span class=o>[</span><span class=n>e</span><span class=o>[</span><span class=n>1</span><span class=o>]]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>HashSet</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>graph</span><span class=o>[</span><span class=n>e</span><span class=o>[</span><span class=n>1</span><span class=o>]]</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=n>e</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>list</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>ArrayList</span><span class=o>&lt;&gt;</span><span class=p>(</span><span class=n>numCourses</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>boolean</span><span class=o>[]</span><span class=w> </span><span class=n>globalVisited</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>boolean</span><span class=o>[</span><span class=n>numCourses</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>boolean</span><span class=o>[]</span><span class=w> </span><span class=n>localVisited</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>boolean</span><span class=o>[</span><span class=n>numCourses</span><span class=o>]</span><span class=p>;</span><span class=w> </span><span class=c1>// to check cycle</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>numCourses</span><span class=p>;</span><span class=w> </span><span class=o>++</span><span class=n>i</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>dfs</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span><span class=w> </span><span class=n>i</span><span class=p>,</span><span class=w> </span><span class=n>globalVisited</span><span class=p>,</span><span class=w> </span><span class=n>localVisited</span><span class=p>,</span><span class=w> </span><span class=n>list</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// copy and reverse</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[</span><span class=n>numCourses</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>numCourses</span><span class=p>;</span><span class=w> </span><span class=o>++</span><span class=n>i</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>result</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>list</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>numCourses</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>result</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// return: can finish</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>dfs</span><span class=p>(</span><span class=n>Set</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;[]</span><span class=w> </span><span class=n>graph</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>node</span><span class=p>,</span><span class=w> </span><span class=kt>boolean</span><span class=o>[]</span><span class=w> </span><span class=n>globalVisited</span><span class=p>,</span><span class=w> </span><span class=kt>boolean</span><span class=o>[]</span><span class=w> </span><span class=n>localVisited</span><span class=p>,</span><span class=w> </span><span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>list</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>localVisited</span><span class=o>[</span><span class=n>node</span><span class=o>]</span><span class=p>)</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>globalVisited</span><span class=o>[</span><span class=n>node</span><span class=o>]</span><span class=p>)</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>localVisited</span><span class=o>[</span><span class=n>node</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>globalVisited</span><span class=o>[</span><span class=n>node</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Set</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>next</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>graph</span><span class=o>[</span><span class=n>node</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>next</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>Integer</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>next</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>dfs</span><span class=p>(</span><span class=n>graph</span><span class=p>,</span><span class=w> </span><span class=n>n</span><span class=p>,</span><span class=w> </span><span class=n>globalVisited</span><span class=p>,</span><span class=w> </span><span class=n>localVisited</span><span class=p>,</span><span class=w> </span><span class=n>list</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// return false and exit, no need to reset localVisited</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>return</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>localVisited</span><span class=o>[</span><span class=n>node</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w> </span><span class=c1>// reset</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>list</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=n>node</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=24-图的路径>2.4 图的路径<a hidden class=anchor aria-hidden=true href=#24-图的路径>#</a></h2><h3 id=241-弗洛伊德>2.4.1 弗洛伊德<a hidden class=anchor aria-hidden=true href=#241-弗洛伊德>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Solution</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>networkDelayTime</span><span class=p>(</span><span class=kt>int</span><span class=o>[][]</span><span class=w> </span><span class=n>times</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>N</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>K</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// w[i][j]: time from [i] to [j], Integer.MAX_VALUE: inf</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=o>[][]</span><span class=w> </span><span class=n>w</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[</span><span class=n>N</span><span class=o>+</span><span class=n>1</span><span class=o>][</span><span class=n>N</span><span class=o>+</span><span class=n>1</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>N</span><span class=p>;</span><span class=w> </span><span class=o>++</span><span class=n>i</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>Arrays</span><span class=p>.</span><span class=na>fill</span><span class=p>(</span><span class=n>w</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>,</span><span class=w> </span><span class=n>Integer</span><span class=p>.</span><span class=na>MAX_VALUE</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>w</span><span class=o>[</span><span class=n>i</span><span class=o>][</span><span class=n>i</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>e</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>times</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>u</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>e</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=p>,</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>e</span><span class=o>[</span><span class=n>1</span><span class=o>]</span><span class=p>,</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>e</span><span class=o>[</span><span class=n>2</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>w</span><span class=o>[</span><span class=n>u</span><span class=o>][</span><span class=n>v</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>t</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>N</span><span class=p>;</span><span class=w> </span><span class=o>++</span><span class=n>k</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>N</span><span class=p>;</span><span class=w> </span><span class=o>++</span><span class=n>i</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>N</span><span class=p>;</span><span class=w> </span><span class=o>++</span><span class=n>j</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=kt>int</span><span class=w> </span><span class=n>sum</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>w</span><span class=o>[</span><span class=n>i</span><span class=o>][</span><span class=n>k</span><span class=o>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>Integer</span><span class=p>.</span><span class=na>MAX_VALUE</span><span class=w>  </span><span class=n>w</span><span class=o>[</span><span class=n>k</span><span class=o>][</span><span class=n>j</span><span class=o>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>Integer</span><span class=p>.</span><span class=na>MAX_VALUE</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=n>sum</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Integer</span><span class=p>.</span><span class=na>MAX_VALUE</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=n>sum</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>w</span><span class=o>[</span><span class=n>i</span><span class=o>][</span><span class=n>k</span><span class=o>]</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>w</span><span class=o>[</span><span class=n>k</span><span class=o>][</span><span class=n>j</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>w</span><span class=o>[</span><span class=n>i</span><span class=o>][</span><span class=n>j</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Math</span><span class=p>.</span><span class=na>min</span><span class=p>(</span><span class=n>w</span><span class=o>[</span><span class=n>i</span><span class=o>][</span><span class=n>j</span><span class=o>]</span><span class=p>,</span><span class=w> </span><span class=n>sum</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>max</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>-</span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>N</span><span class=p>;</span><span class=w> </span><span class=o>++</span><span class=n>j</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>w</span><span class=o>[</span><span class=n>K</span><span class=o>][</span><span class=n>j</span><span class=o>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>Integer</span><span class=p>.</span><span class=na>MAX_VALUE</span><span class=p>)</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=o>-</span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>max</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Math</span><span class=p>.</span><span class=na>max</span><span class=p>(</span><span class=n>max</span><span class=p>,</span><span class=w> </span><span class=n>w</span><span class=o>[</span><span class=n>K</span><span class=o>][</span><span class=n>j</span><span class=o>]</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>max</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=242-dijkstra>2.4.2 Dijkstra<a hidden class=anchor aria-hidden=true href=#242-dijkstra>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Solution</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>networkDelayTime</span><span class=p>(</span><span class=kt>int</span><span class=o>[][]</span><span class=w> </span><span class=n>times</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>N</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>K</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// graph[i]: List&lt;int[]&gt;, [to node, w]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>List</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>[]&gt;[]</span><span class=w> </span><span class=n>graph</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>List</span><span class=o>[</span><span class=n>N</span><span class=o>+</span><span class=n>1</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>N</span><span class=p>;</span><span class=w> </span><span class=o>++</span><span class=n>i</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>graph</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>LinkedList</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>e</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>times</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>from</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>e</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=p>,</span><span class=w> </span><span class=n>to</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>e</span><span class=o>[</span><span class=n>1</span><span class=o>]</span><span class=p>,</span><span class=w> </span><span class=n>w</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>e</span><span class=o>[</span><span class=n>2</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>graph</span><span class=o>[</span><span class=n>from</span><span class=o>]</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[]</span><span class=p>{</span><span class=n>to</span><span class=p>,</span><span class=w> </span><span class=n>w</span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// [distance, node]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>PriorityQueue</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>[]&gt;</span><span class=w> </span><span class=n>heap</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>PriorityQueue</span><span class=o>&lt;&gt;</span><span class=p>((</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>b</span><span class=p>)</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>a</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>b</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// node --&gt; min distance</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>HashMap</span><span class=o>&lt;</span><span class=n>Integer</span><span class=p>,</span><span class=w> </span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>dist</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>HashMap</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>heap</span><span class=p>.</span><span class=na>offer</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[]</span><span class=p>{</span><span class=n>0</span><span class=p>,</span><span class=w> </span><span class=n>K</span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>heap</span><span class=p>.</span><span class=na>size</span><span class=p>()</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>heap</span><span class=p>.</span><span class=na>poll</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>distance</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>n</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>node</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>n</span><span class=o>[</span><span class=n>1</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>dist</span><span class=p>.</span><span class=na>containsKey</span><span class=p>(</span><span class=n>node</span><span class=p>))</span><span class=w> </span><span class=k>continue</span><span class=p>;</span><span class=w> </span><span class=c1>// already determined</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>dist</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=n>node</span><span class=p>,</span><span class=w> </span><span class=n>distance</span><span class=p>);</span><span class=w> </span><span class=c1>// node determined</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>g</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>graph</span><span class=o>[</span><span class=n>node</span><span class=o>]</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kt>int</span><span class=w> </span><span class=n>nextNode</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>g</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kt>int</span><span class=w> </span><span class=n>w</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>g</span><span class=o>[</span><span class=n>1</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// K --&gt; ... --&gt; node --&gt; nextNode</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>dist</span><span class=p>.</span><span class=na>containsKey</span><span class=p>(</span><span class=n>nextNode</span><span class=p>))</span><span class=w> </span><span class=k>continue</span><span class=p>;</span><span class=w> </span><span class=c1>// alreay determined</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>heap</span><span class=p>.</span><span class=na>offer</span><span class=p>(</span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[]</span><span class=p>{</span><span class=n>distance</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>w</span><span class=p>,</span><span class=w> </span><span class=n>nextNode</span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>dist</span><span class=p>.</span><span class=na>size</span><span class=p>()</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>N</span><span class=p>)</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=o>-</span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>max</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>-</span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>d</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>dist</span><span class=p>.</span><span class=na>values</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>max</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Math</span><span class=p>.</span><span class=na>max</span><span class=p>(</span><span class=n>max</span><span class=p>,</span><span class=w> </span><span class=n>d</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>max</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=25-图的出入度问题>2.5 图的出入度问题<a hidden class=anchor aria-hidden=true href=#25-图的出入度问题>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Solution</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=nf>findOrder</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>numCourses</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=o>[][]</span><span class=w> </span><span class=n>prerequisites</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Map</span><span class=o>&lt;</span><span class=n>Integer</span><span class=p>,</span><span class=w> </span><span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;&gt;</span><span class=w> </span><span class=n>graph</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>HashMap</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>indegree</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[</span><span class=n>numCourses</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>e</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>prerequisites</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// e[0] depends on e[1]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// e[1] --&gt; e[0]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>pre</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>e</span><span class=o>[</span><span class=n>1</span><span class=o>]</span><span class=p>,</span><span class=w> </span><span class=n>cur</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>e</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>list</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>graph</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>pre</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>list</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>list</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>LinkedList</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>graph</span><span class=p>.</span><span class=na>put</span><span class=p>(</span><span class=n>pre</span><span class=p>,</span><span class=w> </span><span class=n>list</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>list</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=n>cur</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>indegree</span><span class=o>[</span><span class=n>cur</span><span class=o>]++</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Queue</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>queue</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>LinkedList</span><span class=o>&lt;&gt;</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>numCourses</span><span class=p>;</span><span class=w> </span><span class=o>++</span><span class=n>i</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>indegree</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>queue</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=n>i</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[</span><span class=n>numCourses</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>size</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>queue</span><span class=p>.</span><span class=na>size</span><span class=p>()</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>node</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>queue</span><span class=p>.</span><span class=na>poll</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>result</span><span class=o>[</span><span class=n>size</span><span class=o>++]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>node</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span><span class=w> </span><span class=n>next</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>graph</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>node</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>next</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>n</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>next</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>indegree</span><span class=o>[</span><span class=n>n</span><span class=o>]--</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>indegree</span><span class=o>[</span><span class=n>n</span><span class=o>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=n>queue</span><span class=p>.</span><span class=na>offer</span><span class=p>(</span><span class=n>n</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>size</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>numCourses</span><span class=p>)</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>result</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=26-最小生成树>2.6 最小生成树<a hidden class=anchor aria-hidden=true href=#26-最小生成树>#</a></h2><h3 id=261-kruskal>2.6.1 Kruskal<a hidden class=anchor aria-hidden=true href=#261-kruskal>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Solution</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>minimumCost</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>N</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=o>[][]</span><span class=w> </span><span class=n>connections</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// sort connections by cost from small to large</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Arrays</span><span class=p>.</span><span class=na>sort</span><span class=p>(</span><span class=n>connections</span><span class=p>,</span><span class=w> </span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=n>b</span><span class=p>)</span><span class=w> </span><span class=o>-&gt;</span><span class=w> </span><span class=n>a</span><span class=o>[</span><span class=n>2</span><span class=o>]-</span><span class=n>b</span><span class=o>[</span><span class=n>2</span><span class=o>]</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>parent</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[</span><span class=n>N</span><span class=o>+</span><span class=n>1</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>N</span><span class=p>;</span><span class=w> </span><span class=o>++</span><span class=n>i</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>parent</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>i</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>cost</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>edge</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>connections</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>union</span><span class=p>(</span><span class=n>edge</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=p>,</span><span class=w> </span><span class=n>edge</span><span class=o>[</span><span class=n>1</span><span class=o>]</span><span class=p>,</span><span class=w> </span><span class=n>parent</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>cost</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>edge</span><span class=o>[</span><span class=n>2</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// check if all the roots are the same</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>p</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>-</span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>N</span><span class=p>;</span><span class=w> </span><span class=o>++</span><span class=n>i</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>root</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>findRoot</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=w> </span><span class=n>parent</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>p</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=o>-</span><span class=n>1</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>p</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>root</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>p</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>root</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>return</span><span class=w> </span><span class=o>-</span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>cost</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>findRoot</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>x</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>parent</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>x</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>parent</span><span class=o>[</span><span class=n>x</span><span class=o>]</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>parent</span><span class=o>[</span><span class=n>x</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>parent</span><span class=o>[</span><span class=n>parent</span><span class=o>[</span><span class=n>x</span><span class=o>]]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>parent</span><span class=o>[</span><span class=n>x</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>x</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>union</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>b</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>parent</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>findRoot</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>parent</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>findRoot</span><span class=p>(</span><span class=n>b</span><span class=p>,</span><span class=w> </span><span class=n>parent</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>a</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>b</span><span class=p>)</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>parent</span><span class=o>[</span><span class=n>a</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>b</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=262-prim>2.6.2 Prim<a hidden class=anchor aria-hidden=true href=#262-prim>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>class</span> <span class=nc>Solution</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>minimumCost</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>N</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=o>[][]</span><span class=w> </span><span class=n>connections</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>INF</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Integer</span><span class=p>.</span><span class=na>MAX_VALUE</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// graph[i][j]:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>//     INF: not reachable</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>//     x: distance</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=o>[][]</span><span class=w> </span><span class=n>graph</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[</span><span class=n>N</span><span class=o>+</span><span class=n>1</span><span class=o>][</span><span class=n>N</span><span class=o>+</span><span class=n>1</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>N</span><span class=p>;</span><span class=w> </span><span class=o>++</span><span class=n>i</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>N</span><span class=p>;</span><span class=w> </span><span class=o>++</span><span class=n>j</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>i</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>j</span><span class=p>)</span><span class=w> </span><span class=n>graph</span><span class=o>[</span><span class=n>i</span><span class=o>][</span><span class=n>j</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>else</span><span class=w> </span><span class=n>graph</span><span class=o>[</span><span class=n>i</span><span class=o>][</span><span class=n>j</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>INF</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>edge</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>connections</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>u</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>edge</span><span class=o>[</span><span class=n>0</span><span class=o>]</span><span class=p>,</span><span class=w> </span><span class=n>v</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>edge</span><span class=o>[</span><span class=n>1</span><span class=o>]</span><span class=p>,</span><span class=w> </span><span class=n>w</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>edge</span><span class=o>[</span><span class=n>2</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>graph</span><span class=o>[</span><span class=n>u</span><span class=o>][</span><span class=n>v</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>graph</span><span class=o>[</span><span class=n>v</span><span class=o>][</span><span class=n>u</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>w</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// dist[i]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>//     d: current min distance from one of added nodes</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>//     INF: distance is inf, not reachable</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>dist</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[</span><span class=n>N</span><span class=o>+</span><span class=n>1</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Arrays</span><span class=p>.</span><span class=na>fill</span><span class=p>(</span><span class=n>dist</span><span class=p>,</span><span class=w> </span><span class=n>INF</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// added nodes</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>boolean</span><span class=o>[]</span><span class=w> </span><span class=n>added</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>boolean</span><span class=o>[</span><span class=n>N</span><span class=o>+</span><span class=n>1</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// set node [1] as candidates</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>dist</span><span class=o>[</span><span class=n>1</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>cost</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>k</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>N</span><span class=p>;</span><span class=w> </span><span class=o>++</span><span class=n>k</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=c1>// N nodes to add</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// find node with min distance</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>min</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>INF</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>node</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>-</span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>N</span><span class=p>;</span><span class=w> </span><span class=o>++</span><span class=n>i</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>added</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>dist</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>min</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>min</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>dist</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>node</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>i</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// no reachable node found</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>node</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=o>-</span><span class=n>1</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>return</span><span class=w> </span><span class=o>-</span><span class=n>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// add [node]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>cost</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>dist</span><span class=o>[</span><span class=n>node</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>added</span><span class=o>[</span><span class=n>node</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// update dist[i] with distance from [node] to [i]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>N</span><span class=p>;</span><span class=w> </span><span class=o>++</span><span class=n>i</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>added</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>)</span><span class=w> </span><span class=k>continue</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>graph</span><span class=o>[</span><span class=n>node</span><span class=o>][</span><span class=n>i</span><span class=o>]</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>INF</span><span class=p>)</span><span class=w> </span><span class=k>continue</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>dist</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Math</span><span class=p>.</span><span class=na>min</span><span class=p>(</span><span class=n>dist</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>,</span><span class=w> </span><span class=n>graph</span><span class=o>[</span><span class=n>node</span><span class=o>][</span><span class=n>i</span><span class=o>]</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>cost</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h1 id=3-堆>3 堆<a hidden class=anchor aria-hidden=true href=#3-堆>#</a></h1><h2 id=31-概念>3.1 概念<a hidden class=anchor aria-hidden=true href=#31-概念>#</a></h2><h2 id=32-分类>3.2 分类<a hidden class=anchor aria-hidden=true href=#32-分类>#</a></h2><h2 id=33-存储>3.3 存储<a hidden class=anchor aria-hidden=true href=#33-存储>#</a></h2><h2 id=34-操作>3.4 操作<a hidden class=anchor aria-hidden=true href=#34-操作>#</a></h2><h2 id=35-排序>3.5 排序<a hidden class=anchor aria-hidden=true href=#35-排序>#</a></h2><h1 id=4-树>4 树<a hidden class=anchor aria-hidden=true href=#4-树>#</a></h1><h2 id=41-分类>4.1 分类<a hidden class=anchor aria-hidden=true href=#41-分类>#</a></h2><h2 id=42-存储>4.2 存储<a hidden class=anchor aria-hidden=true href=#42-存储>#</a></h2><h2 id=43-遍历>4.3 遍历<a hidden class=anchor aria-hidden=true href=#43-遍历>#</a></h2><h1 id=5-红黑树>5 红黑树<a hidden class=anchor aria-hidden=true href=#5-红黑树>#</a></h1><h2 id=51-概念与特点>5.1 概念与特点<a hidden class=anchor aria-hidden=true href=#51-概念与特点>#</a></h2><p>红黑树是一种自平衡二叉查找树。JDK中，TreeMap、TreeSet以及HashMap都使用了红黑树。</p><p><strong>特点：</strong></p><ul><li>节点非黑即红，黑色决定平衡，红色不决定平衡。</li><li>根节点总是黑色的。</li><li>每个叶子节点都是黑色的空节点。</li><li>如果节点是红色，那它的子节点一定是黑色（反之不一定），胡总和说不会有连续的红色节点。一个节点最多临时有三个节点，中间黑，左右红。</li><li>从任意节点到他的叶子节点或空子节点的每条路径，必定包含相同数量的而黑色节点。每一层都只有一个节点贡献了树高决定平衡性，也就是对应红黑树中的黑色节点。</li></ul><p>红黑树高度不会超过2log(n+1)</p><h2 id=52-数据结构>5.2 数据结构<a hidden class=anchor aria-hidden=true href=#52-数据结构>#</a></h2><p>建立在 BST 二叉搜索树的基础上，AVL、2-3 树、红黑树都是自平衡二叉树（统称 B-树）。但相比于 AVL 树，高度平衡所带来的时间复杂度，红黑树对平衡的控制要宽松一些，红黑树只需要保证黑色节点平衡即可。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Node</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Class</span><span class=o>&lt;?&gt;</span><span class=w> </span><span class=n>clazz</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Integer</span><span class=w> </span><span class=n>value</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Node</span><span class=w> </span><span class=n>parent</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Node</span><span class=w> </span><span class=n>left</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Node</span><span class=w> </span><span class=n>right</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// AVL 树所需属性</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>height</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 红黑树所需属性</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=n>Color</span><span class=w> </span><span class=n>color</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Color</span><span class=p>.</span><span class=na>RED</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h2 id=53-平衡调整>5.3 平衡调整<a hidden class=anchor aria-hidden=true href=#53-平衡调整>#</a></h2><ol><li>左倾染色</li></ol><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/05bf51e027ac5702f2348fbce87ceca7/5084ac0c221090ae180941eb02b262c2.png alt=image.png></p><ul><li>染色时根据当前节点的爷爷节点，找到当前节点的父亲、叔叔节点</li><li>把父亲、叔叔节点染黑，爷爷节点染红。</li><li>爷爷节点染红是临时的，当平衡树高操作后，会把根节点染黑</li></ul><ol><li>右倾染色</li></ol><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/05bf51e027ac5702f2348fbce87ceca7/e3b5d4d5a856ab3d21e3521e91f45fe5.png alt=image.png></p><p>同上</p><ol><li>左旋调整<ul><li>一次左旋</li></ul></li></ol><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/05bf51e027ac5702f2348fbce87ceca7/c6e2e85aff2ceffd1dfd6e5dd21acc4a.png alt=image.png></p><ul><li>右旋+左旋</li></ul><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/05bf51e027ac5702f2348fbce87ceca7/b4086ac80edb809e514ef57aee8389d6.png alt=image.png></p><ol><li>右旋调整<ul><li>一次右旋</li></ul></li></ol><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/05bf51e027ac5702f2348fbce87ceca7/9200f4771fa2a691045859ed2c75b315.png alt=image.png></p><ul><li>左旋+右旋</li></ul><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/05bf51e027ac5702f2348fbce87ceca7/ae2b21f1769bc8739d463e02392b273c.png alt=image.png></p><h1 id=6-布隆过滤器>6 布隆过滤器<a hidden class=anchor aria-hidden=true href=#6-布隆过滤器>#</a></h1><p><img loading=lazy src=https://raw.githubusercontent.com/roaraeonliou/roaraeonliou.github.io/static/05bf51e027ac5702f2348fbce87ceca7/e60da6c35cc7475befe41ec47e13d138.png alt=image.png></p><h2 id=61-原理及使用场景>6.1 原理及使用场景<a hidden class=anchor aria-hidden=true href=#61-原理及使用场景>#</a></h2><p>使用一个较大的bit数组保存所有数据，每个元素只占用1bit。用于判断元素是否存在，结果具有概率性，加入的元素越多，误报的概率越大。</p><p><strong>原理：</strong></p><ul><li>当加入一个元素时：使用布隆过滤器中的哈希函数堆元素值计算，得到哈希值，根据哈希值将对应下标设置为1。</li><li>当判断元素是否存在时：对给定元素再次计算，如果对应位为1，则存在，否则不存在。</li><li><strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></li></ul><p><strong>使用场景</strong></p><ul><li>判断是否存在：防止缓存穿透、邮箱的垃圾邮件过滤，黑名单功能等</li><li>去重：去除以及爬取过的url，对订单号去重</li></ul><h2 id=62-编码实现>6.2 编码实现<a hidden class=anchor aria-hidden=true href=#62-编码实现>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=nn>java.util.BitSet</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>MyBloomFilter</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>DEFAULT_SIZE</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>2</span><span class=w> </span><span class=o>&lt;&lt;</span><span class=w> </span><span class=n>24</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>final</span><span class=w> </span><span class=kt>int</span><span class=o>[]</span><span class=w> </span><span class=n>SEEDS</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=kt>int</span><span class=o>[]</span><span class=p>{</span><span class=n>3</span><span class=p>,</span><span class=w> </span><span class=n>13</span><span class=p>,</span><span class=w> </span><span class=n>46</span><span class=p>,</span><span class=w> </span><span class=n>71</span><span class=p>,</span><span class=w> </span><span class=n>91</span><span class=p>,</span><span class=w> </span><span class=n>134</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>BitSet</span><span class=w> </span><span class=n>bits</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>BitSet</span><span class=p>(</span><span class=n>DEFAULT_SIZE</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>SimpleHash</span><span class=o>[]</span><span class=w> </span><span class=n>func</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>SimpleHash</span><span class=o>[</span><span class=n>SEEDS</span><span class=p>.</span><span class=na>length</span><span class=o>]</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=nf>MyBloomFilter</span><span class=p>(){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>SEEDS</span><span class=p>.</span><span class=na>length</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>func</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>SimpleHash</span><span class=p>(</span><span class=n>DEFAULT_SIZE</span><span class=p>,</span><span class=w> </span><span class=n>SEEDS</span><span class=o>[</span><span class=n>i</span><span class=o>]</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>add</span><span class=p>(</span><span class=n>Object</span><span class=w> </span><span class=n>value</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=p>(</span><span class=n>SimpleHash</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>func</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>bits</span><span class=p>.</span><span class=na>set</span><span class=p>(</span><span class=n>f</span><span class=p>.</span><span class=na>hash</span><span class=p>(</span><span class=n>value</span><span class=p>),</span><span class=w> </span><span class=kc>true</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=nf>contains</span><span class=p>(</span><span class=n>Object</span><span class=w> </span><span class=n>value</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kt>boolean</span><span class=w> </span><span class=n>ret</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=p>(</span><span class=n>SimpleHash</span><span class=w> </span><span class=n>f</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>func</span><span class=p>){</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>ret</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ret</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>bits</span><span class=p>.</span><span class=na>get</span><span class=p>(</span><span class=n>f</span><span class=p>.</span><span class=na>hash</span><span class=p>(</span><span class=n>value</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>ret</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kd>class</span> <span class=nc>SimpleHash</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>cap</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>private</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>seed</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>public</span><span class=w> </span><span class=nf>SimpleHash</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>cap</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>seed</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>this</span><span class=p>.</span><span class=na>cap</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>cap</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>this</span><span class=p>.</span><span class=na>seed</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>seed</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>public</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>hash</span><span class=p>(</span><span class=n>Object</span><span class=w> </span><span class=n>value</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kt>int</span><span class=w> </span><span class=n>h</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>value</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>return</span><span class=w> </span><span class=n>Math</span><span class=p>.</span><span class=na>abs</span><span class=p>(</span><span class=n>seed</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=p>(</span><span class=n>cap</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>1</span><span class=p>)</span><span class=w> </span><span class=o>&amp;</span><span class=w> </span><span class=p>((</span><span class=n>h</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>value</span><span class=p>.</span><span class=na>hashCode</span><span class=p>())</span><span class=w> </span><span class=o>^</span><span class=w> </span><span class=p>(</span><span class=n>h</span><span class=w> </span><span class=o>&gt;&gt;&gt;</span><span class=w> </span><span class=n>16</span><span class=p>)));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>main</span><span class=p>(</span><span class=n>String</span><span class=o>[]</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>String</span><span class=w> </span><span class=n>value1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;abcdefg&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>String</span><span class=w> </span><span class=n>value2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;xxxxxxx&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>MyBloomFilter</span><span class=w> </span><span class=n>filter</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>MyBloomFilter</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>filter</span><span class=p>.</span><span class=na>contains</span><span class=p>(</span><span class=n>value1</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>filter</span><span class=p>.</span><span class=na>contains</span><span class=p>(</span><span class=n>value2</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>filter</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=n>value1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>filter</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=n>value2</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>filter</span><span class=p>.</span><span class=na>contains</span><span class=p>(</span><span class=n>value1</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>filter</span><span class=p>.</span><span class=na>contains</span><span class=p>(</span><span class=n>value2</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://roaraeonliou.github.io/tags/%E7%AC%94%E8%AE%B0/>笔记</a></li><li><a href=https://roaraeonliou.github.io/tags/%E7%AE%97%E6%B3%95/>算法</a></li></ul><nav class=paginav><a class=prev href=https://roaraeonliou.github.io/posts/interviewnotes/operatingsystem/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E9%9D%A2%E8%AF%95%E9%87%8D%E7%82%B9%E9%97%AE%E9%A2%98/><span class=title>« Prev</span><br><span>操作系统-面试重点问题</span>
</a><a class=next href=https://roaraeonliou.github.io/posts/interviewnotes/messagequeue/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97rabbitmq/><span class=title>Next »</span><br><span>消息队列RabbitMQ</span></a></nav></footer><div id=comments><script src=https://giscus.app/client.js data-repo=RoaraeonLiou/roaraeonliou.github.io data-repo-id=R_kgDOMIxQ4w data-category=Announcements data-category-id=DIC_kwDOMIxQ484CgZUR data-mapping=title data-strict=1 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2024 <a href=https://roaraeonliou.github.io/>RLTEA BLOG</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>